<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[centos-docker]]></title>
    <url>%2F2018%2F03%2F19%2Fcentos-docker%2F</url>
    <content type="text"><![CDATA[CentOS 安装 Docker安装1、Docker 软件包已经包括在默认的 CentOS-Extras 软件源里。因此想要安装 docker，只需要运行下面的 yum 命令：1yum install docker-io -y 2、直接yum安装，安装成功后查看版本1docker -v 3、启动docker1service docker start 4、设置开机启动1chkconfig docker on 配置因为国内访问 Docker Hub 较慢, 可以使用腾讯云提供的国内镜像源, 加速访问 Docker Hub依次执行以下命令123echo "OPTIONS='--registry-mirror=https://mirror.ccs.tencentyun.com'" &gt;&gt; /etc/sysconfig/dockersystemctl daemon-reloadservice docker restart 使用下载镜像下载一个官方的 CentOS 镜像到本地1docker pull centos 下载好的镜像就会出现在镜像列表里1docker images 运行容器这时我们可以在刚才下载的 CentOS 镜像生成的容器内操作了。生成一个 centos 镜像为模板的容器并使用 bash shell 1docker run -it centos /bin/bash 这个时候可以看到命令行的前端已经变成了 [root@(一串 hash Id)] 的形式, 这说明我们已经成功进入了 CentOS 容器。在容器内执行任意命令, 不会影响到宿主机, 如下1mkdir -p /data/simple_docker 可以看到 /data 目录下已经创建成功了 simple_docker 文件夹1ls /data 退出容器1exit 查看宿主机的 /data 目录, 并没有 simple_docker 文件夹, 说明容器内的操作不会影响到宿主机1ls /data 保存容器查看所有的容器信息， 能获取容器的id1docker ps -a 然后执行如下命令，保存镜像：123# docker commit -m="备注" 你的CONTAINER_ID 你的IMAGE[root@VM_125_124_centos ~]# docker commit -m="CentOS-Linux" 7c2cefa961ac centossha256:a251055119b4a3a8631c5a5118e8492cbf711fee985fdad8bf469b2ea0284330 #####]]></content>
  </entry>
  <entry>
    <title><![CDATA[CentOS7中安装 Redis]]></title>
    <url>%2F2018%2F03%2F02%2Fcentos-redis%2F</url>
    <content type="text"><![CDATA[CentOS7中安装 Redis下载：1https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/redis/redis-2.6.14.tar.gz 安装：1、安装 GCC：1yum install gcc -y 2、解压 redis:12[root@centos-linux ~]# cd /usr/local/ [root@centos-linux local]# tar -xvf /opt/redis-2.6.14.tar.gz 3、编译安装：123[root@centos-linux local]# cd redis-2.6.14/ [root@centos-linux redis-2.6.14]# make MALLOC=libc [root@centos-linux src]# make &amp;&amp; make install 使用：启动 Redis:1nohup redis-server /usr/local/redis-2.6.14/redis.conf &lt;/dev/null &amp;&gt;/dev/null &amp; 停止：1redis-cli shutdown 重启：1redis-cli restart]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 安装 Nginx]]></title>
    <url>%2F2018%2F02%2F25%2Fcentos-nginx%2F</url>
    <content type="text"><![CDATA[CentOS7 安装 Nginx在 CentOS 中使用 yum 直接来安装 Nginx的话会出现如下错误，原因是Nginx这个软件不是 yum源中自带的，所以需要手动来配置添加 Nginx 的 yum 源。 12345678[root@centos-linux ~]# yum install nginx 已加载插件：fastestmirror Loading mirror speeds from cached hostfile * base: ftp.sjtu.edu.cn * extras: ftp.sjtu.edu.cn * updates: ftp.sjtu.edu.cn 没有可用软件包 nginx。 错误：无须任何处理 1、添加 yum源1[root@centos-linux ~]# rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 2、安装 Nginx12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758yum install nginx 已加载插件：fastestmirror nginx | 2.9 kB 00:00:00 nginx/x86_64/primary_db | 34 kB 00:00:02 Loading mirror speeds from cached hostfile * base: ftp.sjtu.edu.cn * extras: ftp.sjtu.edu.cn * updates: ftp.sjtu.edu.cn 正在解决依赖关系 --&gt; 正在检查事务 ---&gt; 软件包 nginx.x86_64.1.1.14.0-1.el7_4.ngx 将被 安装 --&gt; 解决依赖关系完成 依赖关系解决 ========================================================================================================================= Package 架构 版本 源 大小 =========================================================================================================================正在安装: nginx x86_64 1:1.14.0-1.el7_4.ngx nginx 750 k 事务概要=========================================================================================================================安装 1 软件包总下载量：750 k安装大小：2.6 MIs this ok [y/d/N]: y6Is this ok [y/d/N]: yDownloading packages:nginx-1.14.0-1.el7_4.ngx.x86_64.rpm | 750 kB 00:00:41 Running transaction checkRunning transaction testTransaction test succeededRunning transaction警告：RPM 数据库已被非 yum 程序修改。 正在安装 : 1:nginx-1.14.0-1.el7_4.ngx.x86_64 1/1 ----------------------------------------------------------------------Thanks for using nginx!Please find the official documentation for nginx here:* http://nginx.org/en/docs/Please subscribe to nginx-announce mailing list to getthe most important news about nginx:* http://nginx.org/en/support.htmlCommercial subscriptions for nginx are available on:* http://nginx.com/products/---------------------------------------------------------------------- 验证中 : 1:nginx-1.14.0-1.el7_4.ngx.x86_64 1/1 已安装: nginx.x86_64 1:1.14.0-1.el7_4.ngx 完毕！ 3、查看Nginx的软件包信息12345678910111213141516171819202122232425262728293031323334[root@centos-linux ~]# rpm -ql nginx/etc/logrotate.d/nginx/etc/nginx/etc/nginx/conf.d/etc/nginx/conf.d/default.conf/etc/nginx/fastcgi_params/etc/nginx/koi-utf/etc/nginx/koi-win/etc/nginx/mime.types/etc/nginx/modules/etc/nginx/nginx.conf/etc/nginx/scgi_params/etc/nginx/uwsgi_params/etc/nginx/win-utf/etc/sysconfig/nginx/etc/sysconfig/nginx-debug/usr/lib/systemd/system/nginx-debug.service/usr/lib/systemd/system/nginx.service/usr/lib64/nginx/usr/lib64/nginx/modules/usr/libexec/initscripts/legacy-actions/nginx/usr/libexec/initscripts/legacy-actions/nginx/check-reload/usr/libexec/initscripts/legacy-actions/nginx/upgrade/usr/sbin/nginx/usr/sbin/nginx-debug/usr/share/doc/nginx-1.14.0/usr/share/doc/nginx-1.14.0/COPYRIGHT/usr/share/man/man8/nginx.8.gz/usr/share/nginx/usr/share/nginx/html/usr/share/nginx/html/50x.html/usr/share/nginx/html/index.html/var/cache/nginx/var/log/nginx 4、Nginx 的简单操作关闭防火墙:1systemctl stop firewalld.service 查看 Nginx版本：1nginx -v 启动 Nginx服务：1systemctl start nginx 停止 Nginx服务：1systemctl stop nginx 重启 Nginx 服务：1systemctl restart nginx 查看 Nginx 服务状态：12345678910111213[root@centos-linux html]# systemctl status nginx● nginx.service - nginx - high performance web server Loaded: loaded (/usr/lib/systemd/system/nginx.service; disabled; vendor preset: disabled) Active: active (running) since 一 2018-05-14 07:04:11 CST; 7min ago Docs: http://nginx.org/en/docs/ Process: 1928 ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf (code=exited, status=0/SUCCESS) Main PID: 1929 (nginx) CGroup: /system.slice/nginx.service ├─1929 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf └─1930 nginx: worker process5月 14 07:04:10 centos-linux systemd[1]: Starting nginx - high performance web server...5月 14 07:04:11 centos-linux systemd[1]: Started nginx - high performance web server.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去掉CentOS中取消滴滴滴的声音]]></title>
    <url>%2F2018%2F02%2F22%2Fcentos-inputrc%2F</url>
    <content type="text"><![CDATA[去掉CentOS中取消滴滴滴的声音在CentOS中，我们常用Tab键进行命令补全，但是系统总是提示滴滴声，让人很烦躁。 即使把音频设备关掉，或者虚拟机的音频设备也关掉，还是有这个声音。 如果不喜欢这个声音，可以通过修改配置去掉它。用vim编辑” /etc/inputrc“ 文件，在”vim“的命令模式下，用键盘方向键进行定位， 找到“#set bell-style none”，用X 删除语句前方的#号，就可以了。“:wq”进行文件保存，并对系统进行重启以后，既可以去掉这个烦扰的声音了。 代码示例：123# do not bell on tab-completionset bell-style nonereboot]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端页面基础CSS布局+Reset原有样式]]></title>
    <url>%2F2018%2F02%2F05%2Fmobile-css%2F</url>
    <content type="text"><![CDATA[移动端页面基础CSS布局+Reset原有样式代码如下： 12345678910111213141516171819202122232425262728293031/*reset css*/*,::before,::after&#123; margin: 0; padding: 0; /*清除移动端的默认的 点击高亮效果*/ -webkit-tap-highlight-color: transparent; /* 设置 所有的box-sizing 移动端所有盒子以边框开始计算宽度 使用百分比布局*/ -webkit-box-sizing: border-box; box-sizing: border-box;&#125;body&#123; /*sans-serif: 设备默认字体*/ font-family:"Microsoft Sans Serif",sans-serif; font-size: 14px; color: #333;&#125;a&#123; color: #333;&#125;a:hover&#123; text-decoration: none;&#125;input&#123; border:none; outline: none; /*清除移动默认的表单样式*/ -webkit-appearance: none;&#125;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Mobile</tag>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML常用标签&lt;meta /&gt;和&lt;link /&gt;详解]]></title>
    <url>%2F2017%2F12%2F04%2Fhtml-head%2F</url>
    <content type="text"><![CDATA[meta标签：定义： 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。 标签位于文档的头部，不包含任何内容。 标签的属性定义了与文档相关联的名称/值对。 示例：123456789101112131415161718192021222324252627282930313233343536&lt;meta charset="utf-8"&gt;&lt;meta http-equiv="x-ua-compatible" content="ie=edge"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;&lt;!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags --&gt;&lt;meta name="keywords" content="your,keywords,here,comma,separated,no,spaces"&gt;&lt;meta name="description" content="150 chars"&gt;&lt;meta name="subject" content="your website's subject"&gt;&lt;meta name="language" content="en"&gt;&lt;meta name="robots" content="index,follow"&gt;&lt;meta name="googlebot" content="index,follow"&gt;&lt;meta name="google" content="nositelinkssearchbox"&gt;&lt;meta name="google-site-verification" content="verification_token"&gt;&lt;meta name="revised" content="Sunday, July 18th, 2010, 5:15 pm"&gt;&lt;meta name="abstract" content=""&gt;&lt;meta name="topic" content=""&gt;&lt;meta name="summary" content=""&gt;&lt;meta name="classification" content="business"&gt;&lt;meta name="author" content="name, email@example.com"&gt;&lt;meta name="designer" content=""&gt;&lt;meta name="reply-to" content="email@example.com"&gt;&lt;meta name="owner" content=""&gt;&lt;meta name="url" content="https://example.com/"&gt;&lt;meta name="identifier-URL" content="https://example.com/"&gt;&lt;meta name="directory" content="submission"&gt;&lt;meta name="category" content=""&gt;&lt;meta name="coverage" content="Worldwide"&gt;&lt;meta name="distribution" content="Global"&gt;&lt;meta name="rating" content="General"&gt;&lt;meta name="referrer" content="never"&gt;&lt;meta name="revisit-after" content="7 days"&gt;&lt;meta http-equiv="refresh" content="300;url=https://example.com/"&gt;&lt;!-- Cache Control --&gt;&lt;meta http-equiv="Expires" content="0"&gt;&lt;meta http-equiv="Pragma" content="no-cache"&gt;&lt;meta http-equiv="Cache-Control" content="no-cache"&gt; link标签：定义： 标签定义文档与外部资源的关系。 标签最常见的用途是链接样式表。 示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;link rel="copyright" href="copyright.html"&gt;&lt;link rel="stylesheet" href="https://example.com/styles.css"&gt;&lt;link rel="alternate" href="https://feeds.feedburner.com/martini" type="application/rss+xml" title="RSS"&gt;&lt;link rel="alternate" href="https://example.com/feed.atom" type="application/atom+xml" title="Atom 0.3"&gt;&lt;link rel="alternate" href="https://es.example.com/" hreflang="es"&gt;&lt;link rel="me" href="https://google.com/profiles/thenextweb" type="text/html"&gt;&lt;link rel="archives" href="https://example.com/2003/05/" title="May 2003"&gt;&lt;link rel="index" href="https://example.com/" title="DeWitt Clinton"&gt;&lt;link rel="start" href="https://example.com/photos/pattern_recognition_1_about/" title="Pattern Recognition 1"&gt;&lt;link rel="prev" href="https://example.com/opensearch/opensearch-and-openid-a-sure-way-to-get-my-attention/" title="OpenSearch and OpenID? A sure way to get my attention."&gt;&lt;link rel="search" href="/search.xml" type="application/opensearchdescription+xml" title="Viatropos"&gt;&lt;link rel="self" type="application/atom+xml" href="https://example.com/atomFeed.php?page=3"&gt;&lt;link rel="first" href="https://example.com/atomFeed.php"&gt;&lt;link rel="next" href="https://example.com/atomFeed.php?page=4"&gt;&lt;link rel="previous" href="https://example.com/atomFeed.php?page=2"&gt;&lt;link rel="last" href="https://example.com/atomFeed.php?page=147"&gt;&lt;link rel="shortlink" href="https://example.com/?p=43625"&gt;&lt;link rel="canonical" href="https://example.com/2010/06/9-things-to-do-before-entering-social-media.html"&gt;&lt;link rel="amphtml" href="https://www.example.com/url/to/amp-version.html"&gt;&lt;link rel="EditURI" href="https://example.com/xmlrpc.php?rsd" type="application/rsd+xml" title="RSD"&gt;&lt;link rel="pingback" href="https://example.com/xmlrpc.php"&gt;&lt;link rel="webmention" href="https://example.com/webmention"&gt;&lt;link rel="manifest" href="manifest.json"&gt;&lt;link rel="author" href="humans.txt"&gt;&lt;!-- Prefetching, preloading, prebrowsing --&gt;&lt;link rel="dns-prefetch" href="//example.com/"&gt;&lt;link rel="preconnect" href="https://www.example.com/"&gt;&lt;link rel="prefetch" href="https://www.example.com/"&gt;&lt;link rel="prerender" href="https://example.com/"&gt;&lt;link rel="subresource" href="styles.css"&gt;&lt;link rel="preload" href="image.png"&gt;&lt;!-- More info: https://css-tricks.com/prefetching-preloading-prebrowsing/ --&gt;&lt;!-- Favicons --&gt;&lt;!-- For IE 10 and below --&gt; &lt;!-- No link, just place a file called favicon.ico in the root directory --&gt;&lt;!-- For IE 11, Chrome, Firefox, Safari, Opera --&gt; &lt;link rel="icon" href="path/to/favicon-16.png" sizes="16x16" type="image/png"&gt;&lt;link rel="icon" href="path/to/favicon-32.png" sizes="32x32" type="image/png"&gt;&lt;link rel="icon" href="path/to/favicon-48.png" sizes="48x48" type="image/png"&gt;&lt;link rel="icon" href="path/to/favicon-62.png" sizes="62x62" type="image/png"&gt;&lt;!-- More info: https://bitsofco.de/all-about-favicons-and-touch-icons/ --&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『Docker』- Containter]]></title>
    <url>%2F2017%2F11%2F27%2Fdocker-containter%2F</url>
    <content type="text"><![CDATA[Docker - 容器概述容器是应用程序层的一个抽象，将代码和依赖关系打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为孤立进程运行。容器占用的空间少于虚拟机（容器图像的大小通常为几十MB），并且几乎立即启动。 Docker - 控制容器建立网站监控:我们需要安装一个Nginx 的Web服务器，Web 服务器可以使网站文件和程序通过浏览器来访问。 步骤一：创建和启动新容器： 12345678➜ ~ docker run --detach --name web nginx:latestUnable to find image 'nginx:latest' locallylatest: Pulling from library/nginxbc95e04b23c0: Pull complete f3186e650f4e: Pull complete 9ac7d6621708: Pull complete Digest: sha256:b81f317384d7388708a498555c28a7cce778a8f291d90021208b3eba3fe74887Status: Downloaded newer image for nginx:latest 运行此命令，Docker 会从 DockerHub 上的 Nginx 库下载安装 nginx&quot;latest镜像，然后运行该软件，在 Docker安装好 Ningx 之后，终端中会打印出一段很长的字符,如下所示：1f17172c2890529a380b3e011b631d60a2c2f263199d088c16208d5b24a431d40 这个字符是Nginx容器的唯一标识符，每次使用docker run的时候被容器所创建的唯一标识。 步骤二：运行交互式容器 Docker命令行工具是一个基于终端的很好的交互式终端程序，要开始使用交互式容器，要运行一下命令： 1docker run --interactive --tty --link web:web --name web_test busybox:latest /bin/sh 选项： --interactive -i：此选项告诉 Docker 保持标准输入流(stdin，标准输入) --tty-t：此选项告诉 Docker 为容器分配一个虚拟终端 步骤三：对容器进行操作]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『Docker』- Introduction & QuickStart]]></title>
    <url>%2F2017%2F11%2F04%2Fdocker-introduction%2F</url>
    <content type="text"><![CDATA[Docker - 概述Docker包括了一个命令行程序、一个后台守护进程、以及一组远程服务。它解决了常见的软件问题，并且简化了安装、运行、发布和删除程序。这一切的实现是通过使用一项 UNIX 技术，称之为容器。 容器与虚拟机:容器:容器是应用程序层的一个抽象，将代码和依赖关系打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为孤立进程运行。容器占用的空间少于虚拟机（容器图像的大小通常为几十MB），并且几乎立即启动。 虚拟机:虚拟机（VM）是将一台服务器变成多台服务器的物理硬件的抽象。管理程序允许多台虚拟机在单台机器上运行。每个VM都包含一个操作系统的完整副本，一个或多个应用程序，必需的二进制文件和库 - 占用数十GB。 VM也可能启动缓慢。 Docker - 版本Docker有两个版本：Community Edition（CE）社区版和Enterprise Edition（EE）企业版。 社区版适合希望开始使用Docker并尝试使用基于容器的应用程序的开发人员和小型团队。 Docker CE有两个更新通道，稳定和优势： 稳定给你每一个季度的可靠的更新 Edge每个月都会为您提供新功能 企业版（EE）专为企业级开发人员和IT团队而设计，他们在大规模生产中构建，发布和运行关键业务应用程序。 Reference：https://docs.docker.com/engine/installation/ Docker - 特点 Docker能够通过容器提供更小的操作系统占用空间，从而缩小开发规模。 有了容器，跨不同部门的团队（如开发人员，质量保证人员和操作人员）可以更轻松地跨应用程序进行无缝工作。 您可以在任何物理和虚拟机，甚至是云上的任何位置部署Docker容器。 由于Docker容器非常轻便，所以它们非常容易扩展。 Docker - 组件Docker有以下组件： Docker for Mac - 它允许在Mac OS上运行Docker容器。 Docker for Linux - 它允许在Linux操作系统上运行Docker容器。 Docker for Windows - 它允许在Windows操作系统上运行Docker容器。 Docker Engine - 用于构建Docker镜像和创建Docker容器。 Docker Hub - 这是用来托管各种Docker镜像的注册表。 Docker Compose - 用于定义使用多个Docker容器的应用程序。 Docker - 应用场景Docker提供了轻量级的虚拟化，几乎没有其他任何额外开销。其次，相比于虚拟机，我们可以在同一台机器上创建更多数量的容器。Docker 另外一个特点是启动和停止都能在几秒钟完成。 简化配置：同一个Docker的配置可以在不同的环境中使用，这样降低了硬件要求和应用环境之间耦合度。 代码管理：Docker给应用提供了一个从开发到上线均一致的环境，让代码的流水线变得简单不少。 隔离应用：有很多种原因会让你选择在一个机器上运行不同的应用，这时候隔离应用会非常有用 整合服务器：通过虚拟机来整合多个应用，Docker隔离应用的能力使得Docker可以整合多个服务器以降低成本 调试能力：Docker 提供了许多的工具，这些工具不一定针对容器，却适用于容器 多租户环境：Docker 在多租户的环境中可以避免关键应用的重写 快速部署：传统的部署模式是安装-&gt;配置-&gt;运行，Docker的部署模式是：复制-&gt;运行 ​ ​ Docker - 安装配置由于 Docker 的局限性，Docker 只能运行在64位的系统中。 1getconf LONG_BIT CentOS:系统要求:要安装Docker CE，您需要维护版本的CentOS 7。不支持或测试归档版本。 必须启用centos-extras存储库。此存储库默认情况下处于启用状态，但如果您已禁用该存储库，则需要重新启用该存储库。 卸载旧版本:老版本的Docker被称为docker或docker-engine。如果安装了这些，请卸载它们以及相关的依赖项。 1234$ sudo yum remove docker \ docker-common \ docker-selinux \ docker-engine 如果yum报告说没有安装这些软件包，那也没关系。 /var/lib/docker/包括图像，容器，卷和网络的内容将被保留。Docker CE包现在被称为docker-ce。 安装Docker CE:yum 安装:更新 yum 软件源缓存，并安装 docker-ce 。 12$ sudo yum makecache fast$ sudo yum install docker-ce shell安装：在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS系统上可以使用这套脚本安装： 12$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh --mirror Aliyun 或者使用 wget： 1sudo wget -qO- https://get.docker.com/ | sh 执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 edge 版本安装在系统中。 其他安装方式请参考官网所提供的文档: Reference：https://docs.docker.com/engine/installation/linux/docker-ce/centos/#prerequisites Docker - Hello World在安装好 Docker 之后，可以再命令行终端中输入: 1➜ ~ docker run hello-world 之后，Docker被激活，开始下载各种组件，并最终打印出Hello from Docker!，在这个过程成 Docker依照流程做了如下事情： docker runDocker 在本机寻找镜像Docker在 DockerHub 上寻找该镜像是否安装？Docker下载该镜像DockerHub是是否存在？是在本机中安装此镜像Docker 创建了一个新的容器并启动改该程序容器运行起来了 当第二次执行docker run hello-world的时候，Docker 会检查是否安装了hello-world 这个镜像，如果已经安装，Docker 会创建一个新的容器并启动该程序。 参考资料:Docker Get Started：https://docs.docker.com/get-started/ 8 Ways to Use Docker in the Real World:http://blog.flux7.com/blogs/docker]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『Node.js - Express』 - QuickStart]]></title>
    <url>%2F2017%2F10%2F28%2Fcentos-express%2F</url>
    <content type="text"><![CDATA[安装 NodeJS安装 NodeJS在终端中，使用下面的命令安装 NodeJS： 12curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -yum -y install nodejs curl –silent –location https://rpm.nodesource.com/setup_8.x | sudo bash -yum -y install nodejs 安装完成后，可使用下面的命令测试安装结果：node -v 安装 Express创建工作目录使用下面的命令在服务器创建一个工作目录： 1mkdir -p /data/release/hello 然后进入此工作目录： 1cd /data/release/hello 初始化项目通过 npm init 命令为你的应用创建一个 package.json 文件。 需要了解 package.json 是如何起作用的，请参考 Specifics of npm’s package.json handling。 npm init此命令将要求你输入几个参数，例如此应用的名称和版本。 除 entry point: (index.js) 参数外，其他参数你可以直接按 “回车” 键接受默认设置即可。对于 entry point: (index.js) 参数，键入 app.js或者你所希望的名称，这是当前应用的入口文件；如果你希望采用默认的 index.js 文件名，只需按 “回车” 键即可。 安装 Express接下来安装 Express 并将其保存到依赖列表中： 1npm install express --save 如果只是临时安装 Express，不想将它添加到依赖列表中，只需略去 --save 参数即可 npm install express。 Hello World创建 app.js在 hello 目录中，创建 app.js，然后将下列代码复制进去： 12345678910var express = require('express');var app = express();app.get('/', function (req, res) &#123; res.send('Hello World!');&#125;);var server = app.listen(3000, function () &#123; console.log('Example app listening on port 3000!');&#125;); 完成后，使用 Ctrl + S 保存文件。 上面的代码启动一个服务并监听从 3000 端口进入的所有连接请求。他将对所有 (/) URL 或 路由 返回 “Hello World!” 字符串。对于其他所有路径全部返回 404 Not Found** 。 启动应用通过如下命令启动此应用：node app.js然后在浏览器中打开 http://119.29.130.84:3000 并查看输出结果。（如果访问不成功，可能是机器安全组禁用了 3000 端口所致，你可以前往控制台修改安全组配置。）该步骤完成后，可使用 Ctrl + C 终止运行。 Express 应用生成器安装 Express 应用生成器通过应用生成器工具 express 可以快速创建一个应用的骨架。通过如下命令安装： 1npm install express-generator -g -h 选项可以列出所有可用的命令行选项：express -h,将得到输出： 123456789101112Usage: express [options] [dir]Options: --version output the version number -e, --ejs add ejs engine support --pug add pug engine support --hbs add handlebars engine support -H, --hogan add hogan.js engine support -v, --view &lt;engine&gt; add view &lt;engine&gt; support (dust|ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade) -c, --css &lt;engine&gt; add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css) --git add .gitignore -f, --force force on non-empty directory -h, --help output usage information 创建项目进入工作目录：cd /data/release执行如下命令，在当前工作目录下创建一个命名为 myapp的应用：express myapp 完成后。生成的应用程序具有以下目录结构： 1234567891011121314151617181920# tree myapp/myapp/|-- app.js|-- bin| `-- www|-- package.json|-- public| |-- images| |-- javascripts| `-- stylesheets| `-- style.css|-- routes| |-- index.js| `-- users.js`-- views |-- error.jade |-- index.jade `-- layout.jade7 directories, 9 files 启动应用进入该应用目录：cd myapp然后安装所有依赖包：npm install，安装所需的依赖包。 然后启动这个应用： （MacOS 或 Linux 平台）：DEBUG=myapp npm start (Windows 平台输入)：set DEBUG=myapp &amp; npm start 然后在浏览器中打开 http://localhost:3000 网址就可以看到这个应用了。（该步骤完成后，可使用 Ctrl + C 终止运行。） 基本路由Express 路由简介路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问。每一个路由都可以有一个或者多个处理器函数，当匹配到路由时，这些函数将被执行。 路由的定义由如下结构组成： app.METHOD(PATH, HANDLER) 其中： app 是一个 express 实例； METHOD 是某个 HTTP 请求方式 中的一个 PATH 是服务器端的路径； HANDLER 是当路由匹配到时需要执行的函数 一个简单的 Express 路由修改 hello 项目 返回开始创建的 hello 项目：cd /data/release/hello 编辑 app.js，参考修改如下： 1234567891011121314151617181920212223242526var express = require('express');var app = express();// 对网站首页的访问返回 "Hello World!" 字样app.get('/', function (req, res) &#123; res.send('Hello World!');&#125;);// 网站首页接受 POST 请求app.post('/', function (req, res) &#123; res.send('Got a POST request');&#125;);// /user 节点接受 PUT 请求app.put('/user', function (req, res) &#123; res.send('Got a PUT request at /user');&#125;);// /user 节点接受 DELETE 请求app.delete('/user', function (req, res) &#123; res.send('Got a DELETE request at /user');&#125;);var server = app.listen(3000, function () &#123; console.log('Example app listening on port 3000!');&#125;); 启动应用node app.js。 （该步骤完成后，可使用 Ctrl + C 终止运行。）测试你可以使用 curl 命令或 Postman 等工具进行测试。如在本地终端执行： curl -X POST http://localhost:3000 curl -X PUT http://localhost:3000/user curl -X DELETE http://localhost:3000/user 静态文件利用 Express 托管静态文件通过 Express 内置的 express.static 可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等。创建静态目录创建 public 目录：mkdir -p /data/release/hello/public**在 public 目录下，创建 hello.html，然后复制下列代码到 hello.html 中： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 修改应用编辑 app.js，参考修改如下： 12345678var express = require('express');var app = express();app.use(express.static('public'));var server = app.listen(3000, function () &#123; console.log('Example app listening on port 3000!');&#125;); 我们在 app.js 中将静态资源文件所在的目录作为参数传递给 express.static 中间件，这样就可以提供静态资源文件的访问了。启动应用node app.js在浏览器中打开 http://localhost:3000/hello.html网址就可以看到这个文件了。你还可以将本地的文件通过拖拽至左边目录树的 public 目录上传文件来测试。假设在 public 目录放置了图片、CSS 和 JavaScript 文件，你就可以从浏览器中访问： http://localhost:3000/images/kitten.jpghttp://localhost:3000/css/style.csshttp://localhost:3000/js/app.jshttp://localhost:3000/images/bg.pnghttp://localhost:3000/hello.html static 中间件更多用法 多个目录如果你的静态资源存放在多个目录下面，你可以多次调用 express.static 中间件：·· 12app.use(express.static('public'));app.use(express.static('files')); 访问静态资源文件时，express.static 中间件会根据目录添加的顺序查找所需的文件。指定路径如果你希望所有通过 express.static 访问的文件都存放在一个“虚拟（virtual）”目录（即目录根本不存在）下面，可以通过为静态资源目录指定一个挂载路径的方式来实现，如下所示： 12345678var express = require('express');var app = express();app.use('/static', express.static('public'));var server = app.listen(3000, function () &#123; console.log('Example app listening on port 3000!');&#125;); 参考修改如下：app.js启动应用：node app.js现在，你就可以通过带有 “/static” 前缀的地址来访问 public 目录下面的文件了。 如：http://localhost:3000/static/hello.html]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『NoSQL - MongoDB』CRUD]]></title>
    <url>%2F2017%2F10%2F23%2Fmongodb-crud%2F</url>
    <content type="text"><![CDATA[前言本文从讲解了 MongoDB 的数据导入导出，以及 CRUD 操作。 数据下载: JSON示例数据:(美国马萨诸塞州邮政代码-&gt;点击下载)。 12345678910&#123; "_id" : "01001", #序号 "city" : "AGAWAM", #城市 "loc" : [ #坐标 -72.622739, 42.070206 ], "pop" : 15338, #标记 "state" : "MA" #州缩写&#125; 其他 JSON 数据下载:http://jsonstudio.com/resources/ MongoDB - 导入数据:简介:mongoimport工具从由其他第三方导出工具创建或可能的[扩展JSON]，CSV或TSV导出导入内容`mongoexport。 mongoimport是以系统命令行运行，而不是MongoShell。 操作：json 导入：示例代码： 1mongoimport --db jsonar --collection zips --file /Users/Desktop/zips.json –db：数据库名称 –collection：集合名称 –file：文件路径 csv导入：示例代码： 1mongoimport --db users --collection contacts --type csv --headerline --file /opt/backups/contacts.csv –type: 文件类型 注意事项:mongoimport支持UTF-8编码的数据文件。使用其他编码会产生错误。 Reference：https://docs.mongodb.com/manual/reference/program/mongoimport/index.html MongoDB - 导出数据:简介：mongoexport 是一个实用程序，可以生成一个JSON或CSV导出存储在MongoDB实例中的数据。 mongoimport是以系统命令行运行，而不是MongoShell。 操作:json导出:1mongoexport --db jsonar --collection zips --out ~/Desktop/zips.json csv导出:1mongoexport --db jsonar --collection zips --out ~/Desktop/zips.csv –out 参数指定了导出的文件类型以及文件路径，更多导出方式请参考官方文档。 Reference：https://docs.mongodb.com/manual/reference/program/mongoexport/index.html MongoDB - 插入文档:在向 MongoDB 数据库中执行插入操作的时候，如果集合(collection)不存在，插入操作会自动创建一个集合(当然，MongoDB 也提供了db.createCollection(&quot;emp&quot;);方法来创建集合)，存储于集合中的每一个文档都需要一个唯一的_id字段作为 primary_key。如果一个插入文档操作遗漏了_id 字段，MongoDB驱动会自动为_id字段生成一个 [ObjectId]，这种情况同样适用于带有参数的 [upsert: true]的 update 操作。 MongoDB主要提供了以下三个方法向集合插入文档: db.collection.insertOne() db.collection.insertMany() db.collection.insert() insertOne:db.collection.insertOne()将单个文档插入到集合中。 示例代码： 123db.inventory.insertOne(... &#123; item: "canvas", qty: 100, tags: ["cotton"], size: &#123; h: 28, w: 35.5, uom: "cm" &#125; &#125;... ) 运行结果: 1234&#123; "acknowledged" : true, "insertedId" : ObjectId("59eee499cbb5fc46080e6d87")&#125; insertOne() 返回一个结果文档，该结果文档中列举了插入文档的_id 字段值为ObjectId(&quot;59eee499cbb5fc46080e6d87&quot;)。 insertMany:db.collection.insertMany()可以将多个文档插入到集合中。 示例代码： 12345db.inventory.insertMany([... &#123; item: "journal", qty: 25, tags: ["blank", "red"], size: &#123; h: 14, w: 21, uom: "cm" &#125; &#125;,... &#123; item: "mat", qty: 85, tags: ["gray"], size: &#123; h: 27.9, w: 35.5, uom: "cm" &#125; &#125;,... &#123; item: "mousepad", qty: 25, tags: ["gel", "blue"], size: &#123; h: 19, w: 22.85, uom: "cm" &#125; &#125;... ]) 运行结果: 12345678&#123; "acknowledged" : true, "insertedIds" : [ ObjectId("59eeeb7dcbb5fc46080e6d89"), ObjectId("59eeeb7dcbb5fc46080e6d8a"), ObjectId("59eeeb7dcbb5fc46080e6d8b") ]&#125; insertMany() 返回包含新插入的文档_id字段值的文档。 insert:db.collection.insert() 将单个文档或多个文档插入到集合中。 插入单个文档:示例代码: 1db.products.insert( &#123; item: "card", qty: 15 &#125; ) 运行结果: 1WriteResult(&#123; "nInserted" : 1 &#125;) 插入多个文档：示例代码： 1234567db.products.insert( [ &#123; _id: 11, item: "pencil", qty: 50, type: "no.2" &#125;, &#123; item: "pen", qty: 20 &#125;, &#123; item: "eraser", qty: 25 &#125; ]) 运行结果： 12345678910BulkWriteResult(&#123; "writeErrors" : [ ], "writeConcernErrors" : [ ], "nInserted" : 3, "nUpserted" : 0, "nMatched" : 0, "nModified" : 0, "nRemoved" : 0, "upserted" : [ ]&#125;) MongoDB - 读取文档:MongoDB 提供了 db.collection.find() 方法从集合中读取文档。此方法返回一个游标，要访问文档，需要迭代游标。但是，在MongoShell中，如果返回的游标未使用var关键字分配给变量，那么光标自动迭代最多20次，打印到结果中的前20个文档。(可以使用 DBQuery.shellBatchSize 来改变迭代次数的默认值 20。) 要查询集合中的所有文档，需要将空文档作为查询过滤器参数传递给find方法。 基础查询:查询 zips 集合中的全部数据，示例代码: 1db.zips.find(&#123;&#125;); 运行结果： 12345&#123; "_id" : "01001", "city" : "AGAWAM", "loc" : [ -72.622739, 42.070206 ], "pop" : 15338, "state" : "MA" &#125;&#123; "_id" : "01002", "city" : "CUSHMAN", "loc" : [ -72.51565, 42.377017 ], "pop" : 36963, "state" : "MA" &#125;&#123; "_id" : "01005", "city" : "BARRE", "loc" : [ -72.108354, 42.409698 ], "pop" : 4546, "state" : "MA" &#125;&#123; "_id" : "01007", "city" : "BELCHERTOWN", "loc" : [ -72.410953, 42.275103 ], "pop" : 10579, "state" : "MA" &#125;&#123; "_id" : "01008", "city" : "BLANDFORD", "loc" : [ -72.936114, 42.182949 ], "pop" : 1240, "state" : "MA" &#125; 如果觉得返回结果太乱，可以使用.pretty()来格式化显示。 查询时也可以指定不需要显示的字段，示例代码： 1db.zips.find(&#123;&#125;,&#123;"loc":0&#125;) 运行结果: 1234567891011121314151617181920212223/* 1 */&#123; "_id" : "01001", "city" : "AGAWAM", "pop" : 15338, "state" : "MA"&#125;/* 2 */&#123; "_id" : "01002", "city" : "CUSHMAN", "pop" : 36963, "state" : "MA"&#125;/* 3 */&#123; "_id" : "01005", "city" : "BARRE", "pop" : 4546, "state" : "MA"&#125; 对于设置的显示字段严格来讲就称为数据的投影操作，如果不需要显示的字段设置“0”，而需要显示的字段设置“1”。 查询时也可以指定相等条件，语法db.集合名称.find({查询条件} [,{设置显示的字段}]。 示例代码： 1db.inventory.find( &#123; city: "SPRINGFIELD" &#125; ) 运行结果: 1234567891011121314151617181920212223242526272829303132333435/* 1 */&#123; "_id" : "01103", "city" : "SPRINGFIELD", "loc" : [ -72.588735, 42.1029 ], "pop" : 2323, "state" : "MA"&#125;/* 2 */&#123; "_id" : "01104", "city" : "SPRINGFIELD", "loc" : [ -72.577769, 42.128848 ], "pop" : 22115, "state" : "MA"&#125;/* 3 */&#123; "_id" : "01105", "city" : "SPRINGFIELD", "loc" : [ -72.578312, 42.099931 ], "pop" : 14970, "state" : "MA"&#125; 关系运算:在MongoDB里面支持的关系查询操作：大于（$gt）、小于（$lt）、大于等于（$gte）、小于等于（$lte）、不等于（$ne）、等于（key:value、$eq）。 查询pop大于20000的数据: $gt:1db.zips.find(&#123;pop:&#123;$gt:20000&#125;&#125;) $lt:查询pop小于1000的数据 : 1db.zips.find(&#123;pop:&#123;$lt:1000&#125;&#125;) $gte:查询pop 大于等于90000的数据： 1db.zips.find(&#123;pop:&#123;$gte:90000&#125;&#125;) $lte:查询 pop 小于等于10的数据： 1db.zips.find(&#123;pop:&#123;$lte:10&#125;&#125;) $ne:查询 pop 不等于100的数据: 1db.zips.find(&#123;pop:&#123;$ne:100&#125;&#125;) $eq:查询 pop 等于100的数据: 1db.zips.find(&#123;pop:&#123;$eq:100&#125;&#125;) 逻辑运算:逻辑运算主要就是三种类型：与（$and）、或（$or）、非（$not、$nor）。 $and:查询 pop为等于10000和city 存在的数据(显式$and查询): 1db.zips.find(&#123;$and:[&#123;pop:&#123;$ne:10000&#125;&#125;,&#123;city:&#123;$exists:true&#125;&#125;]&#125;) 查询pop值再10000 - 20000之间的数据(隐式$and查询)： 1db.zips.find(&#123;pop:&#123;$gte:10000,$lte:20000&#125;&#125;) $or:查询city 为SPRINGFIELD或者pop 大于10000的数据： 1db.zips.find(&#123;$or:[&#123;city:"SPRINGFIELD"&#125;,&#123;pop:&#123;$gte:10000&#125;&#125;]&#125;) $nor:查询city 不为SPRINGFIELD或者 pop 小于10000的数据(进行或的取反操作): 1db.zips.find(&#123;$nor:[&#123;city:"SPRINGFIELD"&#125;,&#123;pop:&#123;$gte:10000&#125;&#125;]&#125;) 求模运算:$mod:求模运算使用“$mod”来完成，语法“{$mod : [数字,余数]}”。 1db.zips.find(&#123;pop:&#123;$mod:[100,10]&#125;&#125;) 范围查询:“$in”（在范围之中）、“$nin”（不在范围之中） $in:查询 city 为AGAWAM、CUSHMAN、SPRINGFIELD三个值的数据: 1db.zips.find(&#123;city:&#123;$in:["AGAWAM","CUSHMAN","SPRINGFIELD"]&#125;&#125;) $nin:查询 city 中不含AGAWAM、CUSHMAN、SPRINGFIELD三个值的数据: 1db.zips.find(&#123;city:&#123;$nin:["AGAWAM","CUSHMAN","SPRINGFIELD"]&#125;&#125;) 数组查询:MongoDB中，需要针对于数组数据查询操作，可以使用几个运算符：$all、$size、$slice、$elemMatch。 $all:查询loc 有42.070206的数据: 1db.zips.find(&#123;loc:&#123;$all:[42.070206]&#125;&#125;) 虽然“$all”计算可以用于数组上，但是也可以用于一个数据的匹配上。 查询loc 有-72.108354和42.409698的数据： 1db.zips.find(&#123;loc:&#123;$all:[-72.108354,42.409698]&#125;&#125;) $size:查询 loc中字段数量为2的数据： 1db.zips.find(&#123;loc:&#123;$size:2&#125;&#125;) $slice:查询 loc中city为SPRINGFIELD并且字段数量为2的数据： 1db.zips.find(&#123;city:"SPRINGFIELD"&#125;,&#123;loc:&#123;$slice:1&#125;&#125;) 查询 loc中city为SPRINGFIELD的数据数据跳过第一条数据返回两条数据： 1db.zips.find(&#123;city:"SPRINGFIELD"&#125;,&#123;loc:&#123;$slice:[1,2]&#125;&#125;) 下标查询:查询 loc中数组的第二个字段，值为42.070206的数据: 1db.zips.find(&#123;"loc.1":42.070206&#125;) 既然在集合里面现在保存的是数组信息，那么数组就可以利用索引操作，使用“key.index”的方式来定义索引。 条件过滤：$where:查询 pop 值小于10的数据: 1db.zips.find(&#123;$where:"this.pop &lt; 10"&#125;); 查询 pop 值小于10的数据和id大于10000的值: 1db.zips.find(&#123;"$and":[&#123;"$where":"this.pop &lt; 10"&#125;,&#123;"$where":"this._id &gt; 10000"&#125;]&#125;) 正则匹配:在 MongoDB 中，如果想模糊查询，那就要使用正则表达式来匹配，而且正则表达式使用的是语言Perl兼容的正则表达式的形式。如果要想实现正则使用，则按照如下的定义格式： ·基础语法：{key : 正则标记}； ·完整语法：{key : {“$regex” : 正则标记 , “$options” : 选项}}。 指令 释义 语法 i 忽略字母大小写 m 在每行的开始或结尾匹配具有多行值的字符串(多行查找) x 空白字符串除了被转义的或在字符类中意外的完全被忽略 需要$ regex与$ options语法 s 匹配所有的字符（圆点、“.”），包括换行内容。 需要$ regex与$ options语法 查询 state中以 K 开头的数据(^)： 1db.zips.find(&#123;state:/^K/&#125;) 查询 state中包含 k 的数据(不区分大小写)： 12db.zips.find(&#123;state:/k/i&#125;)db.zips.find(&#123;state:&#123;$regex:/K/i&#125;&#125;) 两种写法均可实现。 数据排序:MongoDB中数据的排序操作使用“sort()”函数，在进行排序的时候可以有两个顺序：升序（1）、降序（-1）。 查询 pop 数据进行升序排序： 1db.zips.find(&#123;&#125;).sort(&#123;pop:1&#125;) 查询 id 数据进行降序排序: 1db.zips.find(&#123;&#125;).sort(&#123;_id:-1&#125;) 数据分页: skip(n)：表示跨过多少数据行； limit(n)：取出的数据行的个数限制。 查询从0开始每页显示10条数据根据 id升序排序： 123db.zips.find(&#123;&#125;).skip(0).limit(10).sort(&#123;&quot;_id&quot;:1&#125;)db.zips.find(&#123;&#125;).skip(10).limit(10).sort(&#123;&quot;_id&quot;:1&#125;) 其他查询：$exists:查询 pop 的值存在且不含1000-5000之间的数据: 1db.zips.find( &#123; pop: &#123; $exists: true, $nin: [ 1000, 5000 ] &#125; &#125; ) MongoDB - 更新文档:在MongoDB中，对于数据的更新操作提供了两类函数：save()、update()。 方法名称 使用介绍 db.collection.updateOne() 即使可能有多个文档通过过滤条件匹配到，但是也最多也只更新一个文档。 db.collection.updateMany() 更新所有通过过滤条件匹配到的文档 db.collection.replaceOne() 即使可能有多个文档通过过滤条件匹配到，但是也最多也只替换一个文档。 db.collection.update() 即使可能有多个文档通过过滤条件匹配到，但是也最多也只更新或者替换一个文档。 默认情况下db.collection.update()只更新一个文档。要更新多个文档，请使用 multi 选项。 修改器:$set：$set用来指定一个键的值 $unset: $unset用来将键完全删除 $inc:用于，增加和减少：1、键不存在时创建一个键2、增加已有键的值对于分析数据、因果关系、投票或者其他变化数值的地方，使用这个非常方便。 save:save() 方法通过传入的文档来替换已有文档. 示例代码： 12345678910db.zips.save(&#123; "_id" : "01001", "city" : "AGAWAM", "loc" : [ -72.622739, 42.070206 ], "pop" : 15338, "state" : "ZHN"&#125;) 运行结果: 1WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;) update:语法: 12345678910db.collection.update( &lt;query&gt;, &lt;update&gt;, &#123; upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt;, collation: &lt;document&gt; &#125;) upsert：布尔值可选。如果设置为true，则在没有文档与查询条件匹配时创建新文档。默认值为false，在找不到匹配项时不插入新文档。 示例代码： 1db.zips.update(&#123; _id: 01001&#125;,&#123;"city":"ShenZhen","state":"ZHN"&#125;,&#123;upsert: true&#125;) 运行结果: 1WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;) updateOne:语法： 123456789db.collection.updateOne( &lt;filter&gt;, &lt;update&gt;, &#123; upsert: &lt;boolean&gt;, writeConcern: &lt;document&gt;, collation: &lt;document&gt; &#125;) 示例代码: 1db.zips.updateOne(&#123;"_id":"01002"&#125;,&#123;$set:&#123;state:"CHN"&#125;&#125;) 运行结果: 1&#123; "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 &#125; updateMany:语法: 123456789db.collection.updateMany( &lt;filter&gt;, &lt;update&gt;, &#123; upsert: &lt;boolean&gt;, writeConcern: &lt;document&gt;, collation: &lt;document&gt; &#125;) 参数说明: 参数 类型 详解 filter document 更新的选择条件，与find()方法中的查询选择器使用方式相同，可以 指定一个空文档{}来更新集合中的所有文档。 update document 使用更新操作符，如$ set，$ unset或$ rename。 使用update（）模式的更改参数的值：value引发错误。 upsert boolean 可选参数。当为true时，updateMany() 如果没有文档与过滤器匹配，则创建新文档。 更新与过滤器匹配的文档。 为了避免多个提前插入，请确保过滤器字段被唯一索引。 默认为false。 writeConcern document 可选参数。描述MongoDB对独立mongod或复制集合或分片集群的写操作所请求的确认级别，省略使用默认的写入关注。 collation document 可选参数。 指定要用于操作的排序规则。 排序规则允许用户指定用于字符串比较的特定于语言的规则，例如字母和重音符号的规则。 示例代码: 1db.zips.updateMany(&#123; "state" : "CHN" &#125;,&#123; $set: &#123; pop: "1000"&#125;&#125;,&#123;upsert:true&#125;); 运行结果: 1&#123;"acknowledged" : true, "matchedCount" : 1.0, "modifiedCount" : 0.0&#125; replaceOne:语法： 123456789db.collection.replaceOne( &lt;filter&gt;, &lt;replacement&gt;, &#123; upsert: &lt;boolean&gt;, writeConcern: &lt;document&gt;, collation: &lt;document&gt; &#125;) 示例代码： 1db.zips.replaceOne(&#123; "state" : "CHN" &#125;,&#123; "pop" : 0, "state" : "CHINA"&#125;); 运行结果: 1&#123;"acknowledged" : true,"matchedCount" : 1.0,"modifiedCount" : 1.0&#125; MongoDB - 删除文档:MongoDB提供以下方法来删除集合的文档： 方法 说明 db.collection.deleteOne() 最多删除与指定过滤器匹配的单个文档，即使多个文档可能与指定的过滤器匹配。 db.collection.deleteMany() 删除与指定过滤器匹配的所有文档。 db.collection.remove() 删除单个文档或与指定过滤器匹配的所有文档。 deleteOne：语法： 1234567db.collection.deleteOne( &lt;filter&gt;, &#123; writeConcern: &lt;document&gt;, collation: &lt;document&gt; &#125;) 选项说明: filter：类型为 document；使用查询运算符指定删除条件，指定一个空文档{}删除集合中返回的第一个文档。 writeConcern：类型为document；可选参数；描述MongoDB对独立mongod或复制集合或分片集群的写操作所请求的确认级别，省略使用默认的写入关注。 collation：类型为document；可选参数；指定要用于操作的排序规则。 排序规则允许用户指定用于字符串比较的特定于语言的规则，例如字母和重音符号的规则。 示例代码: 1db.zips.deleteOne(&#123;state:"CHINA"&#125;,&#123;&#125;) 运行结果： 1&#123;"acknowledged" : true,"deletedCount" : 1.0&#125; deleteMany:语法： 1234567db.collection.deleteMany( &lt;filter&gt;, &#123; writeConcern: &lt;document&gt;, collation: &lt;document&gt; &#125;) 删除所有符合 state:&quot;MA&quot;的数据： 1db.zips.deleteMany(&#123;state:"MA"&#125;,&#123;&#125;) 运行结果: 1&#123;"acknowledged" : true,"deletedCount" : 472.0&#125; 删除所有符合state中以R开头的数据(不区分大小写)： 1db.zips.deleteMany(&#123;state:/^R/i&#125;,&#123;&#125;) 运行结果: 1&#123;"acknowledged" : true,"deletedCount" : 70.0&#125; remove：romeve函数有两个选项： 删除条件：满足条件的数据被删除； 是否只删除一个数据，如果设置为true或者是1表示只删除一个。 语法: 1234db.collection.remove( &lt;query&gt;, &lt;justOne&gt;) 选项说明： query:类型为document；使用查询运算符指定删除条件，需要清空集合，可以指定为{}。 justOne:类型为document；可选参数；要将删除限制为只有一个文档，请设置为true。省略使用默认值false并删除符合删除条件的所有文档。 删除 pop 小于2000的数据: 1db.zips.remove(&#123;pop:&#123;$lt:2000&#125;&#125;) 运行结果： 1Removed 12436 record(s) in 180ms 删除 city 为MASON的数据，只删除一个: 1db.zips.remove(&#123;city:"MASON"&#125;,&#123;justOne:true&#125;) 运行结果: 1Removed 1 record(s) in 1ms 删除_id 中带有9的数据： 1db.zips.remove(&#123;_id:/9/&#125;) 运行结果: 1Removed 5255 record(s) in 91ms 清空集合zips中的所有内容: 1db.zips.remove(&#123;&#125;) 运行结果: 1Removed 11235 record(s) in 136ms 删除zips 集合: 1db.zips.drop() 运行结果: 1true 参考资料：查询运算符：https://docs.mongodb.com/manual/reference/operator/query/ MongoDB-CRUD：https://docs.mongodb.com/manual/crud/ MongoDB-writeConcern：https://docs.mongodb.com/manual/reference/write-concern/]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『NoSQL - MongoDB』Mongo Shell]]></title>
    <url>%2F2017%2F10%2F18%2Fmongodb-shell%2F</url>
    <content type="text"><![CDATA[前言本文从介绍了MongoShell 的配置、脚本、数据类型和其他指令。 MongoShell - 简介MongoShell是一个互动的JavaScript接口的MongoDB，可以使用MongoShell来查询和更新数据以及执行管理操作。 MongoShell是MongoDB发行版的一个组件， 安装并启动MongoDB后，将MongoShell连接到正在运行的MongoDB实例，MongoDB手册中的大多数示例使用 MongoShell，然而，许多驱动程序也提供了与MongoDB类似的接口。 启动MongoShell：在启动MongoShell之前请确保MongoDB 实例在运行，在Terminal 中键入Mongo则可以直接启动。 示例代码： 1234567891011➜ ~ mongoMongoDB shell version v3.4.3connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.3Server has startup warnings:2017-10-19T10:41:29.922+0800 I CONTROL [initandlisten]2017-10-19T10:41:29.923+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2017-10-19T10:41:29.923+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted.2017-10-19T10:41:29.923+0800 I CONTROL [initandlisten]&gt; db.version()3.4.3 选项/参数:当没有任何参数运行mongo时，mongo shell将尝试连接到端口27017上的localhost接口上运行的MongoDB实例。 链接选项:如果需要链接非27017端口或者远程实例，则可以使用以下语法来链接: 1mongo --username &lt;user&gt; --password &lt;pass&gt; --host &lt;host&gt; --port 28015 或者简写为: 1mongo -u &lt;user&gt; -p &lt;pass&gt; --host &lt;host&gt; --port 28015 .mongorc.js文件:当启动的时候，mongo检查用户HOME目录下的一个JavaScript文件.mongorc.js，如果找到mongo在首次显示提示信息前解析.mongorc.js的内容。如果你使用shell执行一个JavaScript文件或计算表达式，要么通过在命令行使用–eval选项或者指定一个.js文件给mongo，mongo会在完成JavaScript的处理后读取.mongorc.js文件。你可以使用–norc选项来阻止加载.mongorc.js。 使用MongoShell:测试数据:(这个 employee 对象是包含 3 个员工记录的数组) 1234567891011121314151617 &#123; "employees":[ &#123; "firstName":"Bill", "lastName":"Gates" &#125;, &#123; "firstName":"George", "lastName":"Bush" &#125;, &#123; "firstName":"Thomas", "lastName":"Carter" &#125; ]&#125; 显示当前正在使用的数据库： 12&gt; dbtest 查看所有数据库: 123456&gt; show dbsadmin 0.000GBlocal 0.000GB&gt; show databasesadmin 0.000GBlocal 0.000GB 使用show dbs或者show databases可以达到同样的效果。 切换到另一个数据库: 12&gt; use mydbswitched to db mydb 可以切换到一个不存在数据库，当创建集合时，这个数据库会被自动创建。 插入一条数据:12345&gt; db.emp.insertOne(&#123;x : 1&#125;);&#123; "acknowledged" : true, "insertedId" : ObjectId("59e87617052057c4236c259a")&#125; 其中 db指的是当前的数据库，emp 指的是要插入的集合的名称。 查看当前数据库中所有集合： 12&gt; show collectionsemp 查看集合中的数据: 12&gt; db.emp.find()&#123; "_id" : ObjectId("59e87617052057c4236c259a"), "x" : 1 &#125; 格式化输出结果:要格式化打印结果，可以将.pretty()添加到操作中，如下所示： 12345&gt; db.emp.find().pretty()&#123; "_id": ObjectId("59e87617052057c4236c259a"), "x": 1&#125; 此外，可以在 mongo shell中使用下面的显式打印方法： print() 无格式打印 print(tojson()) 用 JSON 格式打印，等效于 printjson() printjson() 用 JSON 格式打印，等效于 print(tojson()) shell 中的多行操作：如果你的代码行以左括号 (&#39;(&#39;)，左大括号 (&#39;{&#39;)或左中括号 (&#39;[&#39;) 结束，那么随后的一行将以省略号 (&quot;...&quot;) 开始，直到你输入对应的右括号 (&#39;)&#39;)，右大括号 (&#39;}&#39;)或右中括号 (&#39;]&#39;) 。 mongoshell在执行代码以前将一直等待右括号，右大括号或右中括号，如下例所示： 1234&gt; if ( x &gt; 0 ) &#123;... count++;... print (x);... &#125; 也可以通过按下两次回车键来结束这次输入: 1234&gt; if (x &gt; 0......&gt; 退出 shell 操作:在MongoShell中输入quit()或者按下 Ctrl+C的组合键方式来结束 shell。 MongoShell - 配置自定义提示符：可以通过在 MongoShell中设置变量 prompt 的值来修改提示符的内容。prompt 变量可以存储字符串以及JavaScript代码。 如果 prompt 为返回字符串的函数， mongo 则会在每个提示符中展示动态信息。 显示当前Shell的操作数：显示当前MongoShell 的操作数量，示例代码： 1234cmdCount = 1;prompt = function() &#123; return (cmdCount++) + "&gt; ";&#125; 配置好之后，提示符会变成这样: 1231&gt;2&gt;3&gt; 显示数据库和主机名:示例代码: 12345host = db.serverStatus().host;prompt = function() &#123; return db+"@"+host+"$ ";&#125; 提示符将会变成如下样式： 1test@HostName$ 显示Mongo服务的启动时间以及文档数:示例代码： 123prompt = function() &#123; return "Uptime:"+db.serverStatus().uptime+" Documents:"+db.stats().objects+" &gt; ";&#125; 提示符将会变成如下样式： 1Uptime:90104 Documents:0 &gt; 以上关于 prompt的相关配置均可以在 MongoShell中直接输入配置，也可以将其写入再.mongorc.js文件中。 使用外部编辑器：可以通过在启动 MongoShell之前设置 EDITOR环境变量来在MongoShell中使用自己的编辑器。 12➜ ~ export EDITOR=vim➜ ~ mongo 进入MongoShell 之后，可以输入edit 使用之前定义的 vim 编辑器来编辑代码。 示例代码： 定义函数: 1function myFunc () &#123; &#125; 使用指定的编辑器来编辑函数： 1edit myFunc 此命令可以打开 Vim 编辑会话。当编辑完成之后，保存并退出编辑会话。 调用函数: 直接在 shell 中输入函数名可以查看函数体，输入函数名() 可以调用函数。 修改批处理大小：db.collection.find()方法是从集合中检索文档的JavaScript方法。db.collection.find()方法返回一个游标到结果;然而，在mongo shell中，如果返回的游标未使用var关键字分配给变量，则光标自动迭代最多20次，以打印到与查询匹配的前20个文档。 mongo shell将提示键入它再次迭代20次。 可以设置 DBQuery.shellBatchSize 属性来修改默认的 20 篇文档数。 示例代码: 1DBQuery.shellBatchSize = 10; 改为10。 MongoShell - 脚本我们可以在操作MongoDB中的数据或执行管理操作的JavaScript中为mongo shell编写脚本。 打开新链接：在MongoShell或者 JavaScript文件中，可以使用 Mongo() 构造函数来实例化数据库连接： 123new Mongo()new Mongo(&lt;host&gt;)new Mongo(&lt;host:port&gt;) 考虑下面的示例，实例化一个到本机默认端口上运行的MongoDB实例的新连接，并且使用 getDB()方法将全局的 db 变量设置为 myDatabase: 12conn = new Mongo();db = conn.getDB(&quot;mydb&quot;); 如果连接到一个需要读取控制的MongoDB实例，你可以使用 db.auth()方法进行授权。 此外，你可以使用 connect() 方法连接到MongoDB实例。下面的示例 连接到运行在 localhost 非默认端口 27020 上的MongoDB实例，并且设置了全局的 db 变量： 1db = connect(&quot;localhost:27020/mydb&quot;); 交互式 shell 和mongo 脚本的区别: 要使用db全局变量，请使用getDB()方法或connect()方法。可以将数据库引用分配给非db以外的变量。 默认情况下，在mongo shell中的写入操作使用写入的{w：1}。如果执行批量操作，请使用Bulk()方法。 不能在JavaScript文件中使用任何shell 指令，因为它们不是有效的JavaScript,下文附对照表。 交互模式下，mongo打印包含所有游标内容的操作结果。在脚本中，可以使用JavaScript的 print()函数或返回格式化的JSON的mongo specific printjson()函数。 下表将最常见的mongo shell助手映射到JavaScript等效项: Shell 指令 JavaScript 操作方式 show dbs , show databases db.adminCommand(‘listDatabases’) use db = db.getSiblingDB(‘‘) show collections db.getCollectionNames() show users db.getUsers() show roles db.getRoles({showBuiltinRoles: true}) show log db.adminCommand({ ‘getLog’ : ‘‘ }) show logs db.adminCommand({ ‘getLog’ : ‘*’ }) it cursor = db.collection.find()if ( cursor.hasNext() ){ cursor.next();} –evel选项：使用–eval选项来将mongo传递给一个JavaScript代码片段。 123456➜ ~ mongo mydb --eval "printjson(db.getCollectionNames())" MongoDB shell version v3.4.3connecting to: mongodb://127.0.0.1:27017/mydbMongoDB server version: 3.4.3[ "emp", "stores" ] 执行 JavaScript 文件：MongoShell 可以 指定一个 .js 文件， mongo 将会直接运行JavaScript。 1mongo localhost:27017/test myjsfile.js 该操作在连接到localhost 接口 27017 端口 mongod 实例上 test database 的:program:mongo shell 中执行 myjsfile.js 脚本。 可以在MongoShell中使用 load() 函数运行 .js文件，如下所示： 1load(&quot;demo.js&quot;) 该函数导入并运行了 demo.js 文件。 load() 方法可接受相对路径和绝对路径。如果 mongo shell 当前的工作目录位于 /data/db， 而文件demo.js 位于 /data/db/scripts 目录，那么下面两种在 mongo 中的调用将会是同样的效果。 12load(&quot;scripts/myjstest.js&quot;)load(&quot;/data/db/scripts/demo.js&quot;) MongoShell - 数据类型MongoDB BSON提供了除 JSON之外其它数据类型的支持。 Drivers提供了对这些数据类型在主机语言的本地化支持，MongoShell 也提供了一些帮助类来支持这些数据类型在 mongo JavaScript shell 中的使用。 检查类型：如果想要确定字段类型，MongoShell提供了 instanceof 和 typeof 操作符。 instanceof:instanceof 返回一个布尔值来验证一个值是否为某些类型的实例。 typeof:typeof 返回一个字段的类型。 数据类型:日期类型:MongoShell 提供了多种方法返回日期，要么通过字符串要么通过 Date 对象。 Date() 方法返回当前日期为一个字符串。 new Date() 构造函数返回一个使用 ISODate() 包装返回的 Date 对象。 ISODate() 构造函数返回一个使用 ISODate() 包装返回的 Date 对象。 内部来看， ref:document-bson-type-date 对象被存储为一个表示距离 Unix 纪元（1970年1月1日）毫秒数的64位整数，这就意味着一个可表示的日期范围：从距离过去到将来的29亿年。 返回string:如果想要返回日期为一个字符串，使用 Date() 方法。 示例代码: 123451&gt; var mydate = Date(); # 创建日期类型的变量2&gt; mydate # 查看变量的值Mon Oct 23 2017 14:30:47 GMT+0800 (CST)3&gt; typeof(mydate) # 获取查看变量的类型string 返回Date:MongoShell使用ISODate帮助程序包装Date类型的对象。但是，对象仍然是Date类型。 123456789101&gt; var myDate = new Date();2&gt; var myISODate = new ISODate();3&gt; myDateISODate("2017-10-23T06:59:56.039Z")4&gt; myISODateISODate("2017-10-23T07:00:09.831Z")5&gt; myDate instanceof Date # 验证类型true6&gt; myISODate instanceof Date # 验证类型true ObjectId:MongoShell围绕ObjectId数据类型提供ObjectId()包装器类。 示例代码: 121&gt; new ObjectId(); # 生成一个 ObjectIdObjectId("59ed998b6d3acf0e7aac525c") NumberLong:默认情况下，MongoShell将所有数字视为浮点值(floating-point values)。MongoShell提供NumberLong()包装器来处理64位整数。 示例代码： 12311&gt; NumberLong("2090845886852") # NumberLong()包装器接受long作为字符串：NumberLong("2090845886852") NumberInt:NumberInt() 构造函数来显式指定 32位整数。 NumberDecimal:NumberDecimal()构造函数限制指定 128位 基于十进制的浮点值，能够以精确的精度仿效十进制近似值。 这个功能专为处理 monetary data 的应用而设计，例如金融、税务以及科学计算等。 MongoShell - 其他命令历史命令:可以使用向上和向下箭头键检索MongoShell中发出的以前的命令。命令历史存储在~/.dbshell文件中。 示例代码: 1cat ~/.dbshell 常用命令: 命令 说明 help 查看帮助 db.help() 查看数据库的操作帮助 db..help() 显示集合的操作文档(集合可以是不存在的) show dbs 显示当前服务器上所有数据库的列表 use 切换数据库到 &lt;db&gt;(数据库可以是不存在的) show collections 显示当前数据库的所有集合的列表 show users 显示当前数据库的用户列表 show roles 显示用于当前数据库的用户定义和内置的所有角色的列表。 show profile 显示最近的五个操作命令 show databases 显示所有可用数据库列表。 load() 加载执行JavaScript脚本文件 命令行启动选项:MongoShell 启动时可以使用一些选项。 选项 说明 –help 显示命令行选项 –nodb 启动MongoShell而不连接到数据库 –shell 与 js 文件一起使用 参考资料:MongoDB 中文社区: http://www.mongoing.com/docs/mongo.html MongoDB 官网文档: https://docs.mongodb.com/manual/mongo/ MongoShell引用方法: https://docs.mongodb.com/manual/reference/method/]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『NoSQL - MongoDB』Introduction & QuickStart]]></title>
    <url>%2F2017%2F10%2F17%2Fmongodb-quickstart%2F</url>
    <content type="text"><![CDATA[前言本文从MongoDB 的简介、特点、优点、趋势、等几个方面来介绍了MongoDB。 MongoDB - 简介MongoDB（来自于英文单词“Humongous”）是可以应用于各种规模的企业、各个行业以及各类应用程序的开源数据库。MongoDB是专为可扩展性，高性能和高可用性而设计的数据库。它可以从单服务器部署扩展到大型、复杂的多数据中心架构。利用内存计算的优势，MongoDB能够提供高性能的数据读写操作。 MongoDB的本地复制和自动故障转移功能使您的应用程序具有很高可靠性和操作灵活性。 MongoDB - 概念在mongodb中基本的概念是文档、集合、数据库。 SQL术语/概念 MongoDB术语/概念 解释/说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table joins 表连接,MongoDB不支持 primary key primary key 主键,MongoDB自动将_id字段设置为主键 MongoDB - 特点临时(Ad hoc)查询:MongoDB支持字段，范围查询，正则表达式搜索。查询可以返回特定的文档字段，并且还包括用户定义的JavaScript函数。查询也可以配置为返回给定大小的结果的随机抽样。 索引:MongoDB文档中的字段可以使用主索引和辅助索引进行索引。 复制:MongoDB提供高可用性与副本集。副本集由两个或多个数据副本组成。每个副本集成员可以在任何时候以主副本的角色起作用。默认情况下，所有写入和读取都在主副本上完成。辅助副本使用内置复制维护主数据的副本。当主副本失败时，副本集会自动进行选举过程，以确定哪个辅助应该成为主要副本。辅助功能可以选择性地提供读取操作，但是数据默认情况下才最终保持一致。 负载均衡:MongoDB使用分片水平缩放。用户选择一个分片键，它确定集合中的数据将如何分发。数据被分割为范围（基于分片键）并分布在多个分片上。（碎片是一个或多个奴隶的主人）。或者，碎片密钥可以被散列以映射到分片 - 实现均匀的数据分发。 MongoDB可以在多台服务器上运行，平衡负载或复制数据，以防止硬件故障时系统启动并运行。 文件存储:MongoDB可以用作具有负载平衡和数据复制功能的文件系统，通过多台机器存储文件。 此功能被称为网格文件系统，包含在MongoDB的驱动程序。MongoDB向开发人员公开了文件操作和内容的功能。GridFS用于Nginx 和lighttpd的插件。GridFS将文件划分为部分或块，并将这些块中的每一个作为单独的文档存储。 聚合:MapReduce可用于批量处理数据和聚合操作。 聚合框架使用户能够获得使用SQL。聚合框架包括可以从多个文档加入文档的$ lookup运算符，以及诸如标准偏差的统计运算符。 服务器端JavaScript执行:JavaScript可用于查询，聚合功能（如MapReduce），并直接发送到要执行的数据库。 覆盖的集合:MongoDB支持固定大小的集合，称为封顶集合。这种类型的集合维护插入顺序，一旦达到指定的大小，就像一个循环队列。 MongoDB - 优点MongoDB优于RDBMS: 模式少 MongoDB是一个文档数据库，其中一个集合持有不同的文档。文档的数量，内容和大小可能因文档而异。 单个对象的结构是清楚的。 没有复杂的连接。 深度查询能力。MongoDB支持使用几乎与SQL一样强大的基于文档的查询语言对文档进行动态查询。 MongoDB易于扩展。 将应用程序对象转换/映射到不需要的数据库对象。 使用内部存储器存储（加窗）工作集，实现数据更快的访问。 为什么要使用MongoDB？ 面向文档的存储 数据以JSON样式文档的形式存储。 任何属性的索引 复制和高可用性 自动分片 丰富的查询 快速就地更新 MongoDB的专业支持 MongoDB的应用场景？ 大数据 内容管理和交付 移动和社会基础设施 用户数据管理 数据中心 MongoDB - 趋势搜索指数：百度指数：http://index.baidu.com/?tpl=trend&amp;word=mongodb 谷歌趋势：https://trends.google.com/trends/explore?date=today%205-y&amp;q=MongoDB 分别对比了五年内的搜索结果，整体呈上升趋势，近一年内趋于平缓。 流行程度：数据来源于 DB-Engines，DB-Engines是一个收集和呈现数据库管理系统（DBMS）的网站。 DB-Engines目前市场上数据库的人气排名列表，列表每月更新一次。 MongoDB 综合排名第四位，文档类数据库排名第一位。 DB-Engines：https://db-engines.com/en/ranking DB-Engines的排名主要根据5个因素来进行：Google以及Bing搜索引擎的关键字搜索数量、Google Trends的搜索数量、Indeed网站中的职位搜索量、LinkedIn中提到关键字的个人资料数以及Stackoverflow上相关的问题和关注者数量。 MongoDB - 安装安装:MongoDB 官网提分别供了基于 Linux、OS X、Windows 系统上的安装教程。 在 OS X系统中，官方建议使用 Homebrew 来安装，步骤如下： 更新 HomeBrew： 1brew update 安装 MongoDB： 1brew install mongodb 其他安装操作： 安装具有TLS / SSL支持的MongoDB二进制文件: 1brew install mongodb --with-openssl 安装用于测试和开发的最新版本： 1brew install mongodb --devel 参考资料：http://www.mongoing.com/docs/installation.html 配置：安装完成 MoongoDB 之后，需要在当前用户的根目录下为 MongoDB 数据库添加环境变量，由于采用了 HomeBrew来安装的 MongoDB，对 Homebrew 不熟悉的人可能不清楚安装在哪里了，这时可以使用 brew info 来查看。 示例代码: (省略部分内容) 123456789101112131415# 查看 MongoDB 的安装信息➜ ~ brew info mongodbmongodb: stable 3.4.9 (bottled), devel 3.5.11==&gt; Dependencies ……==&gt; Requirements ……==&gt; Options ……--with-boost ……--with-sasl ……--without-openssl ……--devel ……==&gt; CaveatsTo have launchd start mongodb now and restart at login: brew services start mongodbOr, if you don't want/need a background service you can just run: mongod --config /usr/local/etc/mongod.conf 123456# 配置MongoDB环境变量➜ ~ vim .bash_profileexport PATH=/usr/local/Cellar/mongodb/3.4.3/bin:$&#123;PATH&#125;➜ ~ source .bash_profile MongoDB的默认数据目录为/data/db，如需要修改，可以在 MongoDB 的配置文件中修改dbPath选项。 路径如下： 1➜ ~ cat /usr/local/etc/mongod.conf MongoDB - 启动安装配置完成之后，打开 terminal，输入mongod,直至出现I NETWORK [thread1] waiting for connections on port 27017字样则算启动成功，然后再打开另一终端窗口，输入 mongo，则可以直接进入 MongoShell 界面。 学习资料 MongoDB University： MongoDB 官方课程:https://university.mongodb.com/courses/catalog Github: MongoDB 代码托管:https://github.com/mongodb/mongo TutorialsPoint: MongoDB 教程文档:http://www.tutorialspoint.com/mongodb/ 云栖社区(AliYun): 阿里云云栖社区MonbgoDB 资料汇总:http://t.cn/RO3HQgI MongoDB YouTube:MongoDB在Youtube 订阅频道:https://www.youtube.com/user/MongoDB MongoDB Tutorial for Beginners： MongoDB 初学者教程: MongoDB Tutorial for Beginners(UP主:The Net Ninja) 参考资料DB-Engines: https://db-engines.com MongoDB Manual: https://docs.mongodb.com/manual/]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用 Now.sh来免费部署你的项目？]]></title>
    <url>%2F2017%2F09%2F10%2Fnowsh-note%2F</url>
    <content type="text"><![CDATA[前言 ZEIT：Our Mission，Make Cloud Computing as Easy and Accessible as Mobile computing. ZEIT是美国 (域名Ip指向美国华盛顿州西雅图市)一家提供云部署服务的公司，旗下的 Now.sh提供了Realtime global deployments(全球化实时部署)服务。 Now.sh 提供了免费的OSS 服务，配置如下： 名称 配置 带宽 1GB* 日志 100MB* 部署 ∞ 并发实例 3 域 - † MAX文件大小/存储空间 1MB / 1GB 自动增长支持 不支持 团队协作人数 支持 图例： *超出此限额时，您需支付“按需”的价格。服务不中断，不会造成停机。 †对于某些开源项目，我们赞助了自定义域的支持。请联系我们，以确定您是否适用。 ‡在免费计划中，您的代码将是公开的和开源的，可通过所有部署的路径URL提供。/_src Reference：https://zeit.co/pricing Now.sh - 简介：now allows you to take your JavaScript (Node.js) or Docker powered websites, applications and services to the cloud with ease, speed and reliability. In practical terms, any directory that contains a package.json or Dockerfile can be transported to the cloud with one command: now. Every time you deploy a project, now will provide you with a new, unique URL (even before the upload has finished). These URLs will look like this (my-app is your automatically determined application name): my-app-erkgfjtrna.now.sh. When it’s time to take your deployment to production, you simply pick an appropriate alias (a custom domain). Reference：https://zeit.co/now#whats-now Now.sh - 安装：基于客户端进行安装：客户端下载地址：https://zeit.co/download 安装过程就不一一赘述了，因为我也没安装过。我觉得使用homebrew或npm之类的工具安装使用会更方便一些。 基于 npm 进行安装：示例代码： 123456789101112➜ npm install -g now/usr/local/bin/now -&gt; /usr/local/lib/node_modules/now/download/dist/now&gt; now@8.2.2 postinstall /usr/local/lib/node_modules/now&gt; node download/install.js&gt; For the source code, check out: https://github.com/zeit/now-cli&gt; Downloading now CLI 8.2.2 [====================] 100%+ now@8.2.2added 1 package in 15.18s 如果你还不会使用 npm (Node Package Manager)，请翻阅之前发布的 npm使用教程。 Reference:https://www.npmjs.com/package/now Now.sh - CLI:以下是所有可用命令的完整列表，以及您可以使用的命令和您每天工作时应记住的命令： Syntax Description now deploy [path] 使用此命令时，当前目录中的文件将被上传到now.sh，并将创建一个新的部署。之后，您将立即收到其网址，以便与全球其他人分享。 now ls\list [app] 显示所有部署的列表。如果被定义，它将仅列出该命名空间下的部署。 now rm\remove [id] 从now.sh平台中删除部署。该参数可以是您之前的部署的URL或主机名。 now ln\alias [id] [url] 在现有部署上配置别名或自定义域名。 now domains [name] 允许您直接从命令行管理域名。 now certs [cmd] 默认情况下，now.sh将自动为您的部署配置证书。使用此子命令，您可以看到他们何时到期。 now secrets [name] 如果您需要将敏感信息存储在只能由其中运行的代码访问的部署上。这可以通过使用它来实现，它允许您以安全的方式存储应用程序所需的功能（如API令牌或密码） now dns [name] 列出使用zeit.world为域创建的所有DNS记录。该列表不包括由名称服务器自动生成的记录（如默认记录，为记录自动创建的记录等）。SOA``A / AAAA``ALIAS now open 运行此子命令将在默认浏览器的当前目录中打开项目的最新部署（别名此时无效） now billing\cc 轻松添加或删除帐户中的信用卡，并调整结算方式。 now upgrade\downgrade [plan] 从命令行界面切换您的计划。即使命令运行后，我们也不要求您使用Web界面。整个过程直接发生在你的终端上。 now help 显示终端中的子命令和选项列表 now login 登录你的 ZEIT账户 Reference：https://zeit.co/docs/features/now-cli Now.sh - 使用：要使用 Now.sh就必须要再 https://zeit.co 注册一个账户，只需要输入你的邮箱就好了，然后在本地进行认证，认证过程中需要输入你注册时所用的邮箱，然后打开邮箱点击链接进行认证。 示例代码： 123456➜ ~ now login&gt; We sent an email to youremail@gmail.com. Please follow the steps provided inside it and make sure the security code matches Silly Water Buffalo.✔ Email confirmed✔ Fetched your personal details&gt; Ready! Authentication token and personal details saved in "~/.now" 邮件内容： 12345678Hi!Login attempt from Shenzhen, ChinaVerify that the provided security code matches Confident African Civetbefore proceeding. Then please follow this link to verify your email address. Now.sh - 部署： Now.sh is free for open-source projects and static deployments. It supports Dockerfile, package.json and static sites out of the box. All builds are reproducible and executed in the cloud. 译：Now.sh对于开源项目和静态部署是免费的。它支持Dockerfile，package.json和静态网站开箱即用。所有的构建都是可重现的，并在云中执行。 现在你可以使用now命令来部署任何 web应用程序，现在 Now.sh 支持三种类型的部署： Static - 静态网页应用 Node.js - Node.js 应用 Docker - Docker应用(适用于所有其他应用) Static 部署：通过静态部署，可以将本地资源部署到 Now.sh 上，需要部署请访问应用程序目录并运行此命令： 1➜ yourproject/ now 如果你的静态 web 项目中包含index.html文件，则项目可正常显示，否则只会显示文件和文件夹(用来做 ftp 服务器也不错)。 For all static deployments, you will be charged only for the bandwidth. You do not pay for computing resources and storage. 对于所有静态部署，您将仅为带宽收费。您不支付计算资源和存储空间。 Node.js 部署:如果您的应用程序目录中有一个package.json文件，那么Now.sh会认为有效的Node.js部署。这是一个简单的Node.js部署在微服务的帮助下。 Node.js 应用必须要用以下两个文件才能被 Now.sh 识别。 index.js示例代码： 123module.exports = () =&gt; (&#123; date: new Date&#125;) package.json示例代码： 12345678910&#123; "name": "get-started-node", "version": "0.1.0", "dependencies": &#123; "micro": "latest" &#125;, "scripts": &#123; "start": "micro" &#125;&#125; 然后要部署此应用程序，请访问应用程序根目录并运行此命令： 1➜ yourproject/ now Docker 部署：如果您的应用程序目录包含一个Docker文件，那么现在考虑一个有效的Docker部署。它将基于Dockerfile构建一个docker映像，并基于此启动容器。 要部署一个简单的Go HTTP服务器，创建一个目录并添加这两个文件： hello.go示例代码： 1234567891011121314151617package mainimport ( "io" "net/http")func main() &#123; http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) &#123; io.WriteString(w, "Hello world!") &#125;) err := http.ListenAndServe(":8000", nil) if err != nil &#123; panic(err) &#125;&#125; Dockerfile示例代码： 12345FROM golang:alpineADD . /go/src/zeit/helloRUN go install zeit/helloCMD ["/go/bin/hello"]EXPOSE 8000 部署总结：项目在部署完成之后，我们会得到一个链接，可以通过这个链接来访问部署的项目。 123456789101112➜ Index now&gt; Deploying ~/WorkDir/Index under usrename&gt; Warning! Skipping file /Users/Uname/WorkDir/Index/img/background.jpg (size exceeded 1MB)&gt; Warning! 1 of the files exceeded the limit for your plan.&gt; Please run `now upgrade` to upgrade.&gt; Ready! https://index-xxxxxxxxx.now.sh (copied to clipboard) [2s]&gt; You (Username) are on the OSS plan. Your code and logs will be made public.&gt; NOTE: You can use `now --public` to skip this prompt&gt; Synced 3 files (877.42KB) [41s]&gt; Initializing…&gt; Deployment complete! 每次更新部署后， url 都会生成一个新的，但是老的 url 都还是可以用的。如果最终网站要产品化，可以很容易的绑定自己的域名。 Reference： https://zeit.co/docs/getting-started/deployment Now.sh - 域名：当我们部署完应用程序的时，Now.sh 会为我们生成一个唯一部署URL，如果我们修改项目后进行多次部署，Now.sh 会生成多个 URL 为我们的项目，使用这些特定的 URL 可以访问不同版本的应用，但是这些URL 不容易记住，每次部署新版本都会更新地址，因此我们需要一个固定的域名。我们将使用now alias命令将域名映射到应用的其中一个部署URL。 需要说明的是，自定义域仅适用于付费计划。如果您要为自己的应用使用自定义域，则需要升级您的帐户。具体价格请参考：https://zeit.co/pricing 使用now alias命令的四种不同的方法是： 使用now.sh提供的域名 使用now.sh管理的自定义域名 使用自定义域，由now管理的DNS 使用带有CNAME的自定义域名 使用now.sh提供的域名这种方法是使用域名的最简单方法。要立即使用now.sh 后缀获取域名，只需运行以下命令即可，示例代码 ： 1$ now alias https://my-web-app-avvuiuuwto.now.sh my-web-app 现在可以使用https://my-web-app.now.sh来访问部署的项目。 ###使用now.sh管理的自定义域 如果您想为自己的应用使用自定义域，最简单的方法是使用now为您的应用购买域名。 只需运行以下alias命令，示例代码： 1$ now alias https://my-web-app-avvuiuuwto.now.sh my-web-app.com 在这里，我们正在尝试将my-web-app.com域名分配给上述部署URL。如果域名可用，您可以在不离开终端的情况下确认并购买。 确认后，现在将处理您的所有技术细节，并允许您的用户使用https://my-web-app.com访问您的应用程序。 在这个过程中，now.sh将为我们的域名设置一个域加密SSL证书。 使用自定义域，由Now管理的DNS如果您已经有域名，这是您最好的选择。使用此方法，现在将处理您的域名的所有DNS管理。 首先，您需要将域名的域名服务器指向我们的全球DNS服务。这是怎么做到的: 访问您的域名提供商，并找到可以添加自定义nameserver的地方。 从此列表中选择两个或多个nameservers。 将now.sh 提供的nameserver设置为您的自定义域名的nameserver。 这里呢需要将我们购买的域名的解析权交给 now 来做，本网站域名再 godaddy购买，然后将其解析权交给 Dnspod ，使用管理起来更方便，跟 now.sh 原理一致。 例如，假设您的域名是my-custom-domain.com,设置name后，只需运行以下alias命令： 1$ now alias https://my-web-app-avvuiuuwto.now.sh my-custom-domain.com 然后，您可以使用https://my-custom-domain.com访问您的应用程序。 您也可以使用my-custom-domain.com的子域，如下所示： 1$ now alias https://my-web-app-avvuiuuwto.now.sh ui.my-custom-domain.com 在这个过程中，now.sh将为我们的域名设置一个域加密SSL证书。 Reference：Godaddy注册的域名如何使用DNSPod？ Reference：now.sh 提供的 Nameservers 使用带有CNAME的自定义域名如果您正在管理您的域名的DNS设置，您可以使用此选项。 例如，假设您有一个名为my-app.work的域名，并且您已经有一个DNS设置。要映射应用程序的一个部署URL的 ui.my-app.work 域名，请访问您的DNS提供程序，并为ui.my-app.work添加指向alias.zeit.co的CNAME记录。之后，运行以下命令： 1$ now alias https://my-web-app-avvuiuuwto.now.sh ui.my-app.work 现在您可以使用https://ui.my-app.work访问您的应用程序。 Reference：https://zeit.co/docs/getting-started/assign-a-domain-name Now.sh - 日志：日志很重要，因为它可以让您看到应用程序中发生的情况，尤其是在发生异常时。now可以保存所有部署的日志，并允许您搜索它们，让我们来看看如何访问日志： 通过CLI：通过现在的CLI访问日志很简单，调用这个命令： 1$ now logs [deployment-url] 您还可以使用应用的域名来搜索日志： 1$ now logs my-web-app.com 有关now日志的更多信息，请运行help命令： 1$ now logs --help 这是一个预先查看 now的日志命令，让您检查最后10个HTTP GET请求: 1$ now logs -a -q "GET" -n 10 my-web-app.com 通过Dashboard：您还可以通过您的Web信息板访问和搜索日志，网址为https://zeit.co/dashboard。 单击信息中心内的任何部署URL，然后开始搜索日志。 Reference：https://zeit.co/docs/getting-started/logs Now.sh - 注意事项：使用 Now.sh来部署应用的优势： 自带的 https 真正的一键部署，不用自己管理服务器，将 severless 进行到底 不翻墙，访问速度很棒 其他注意事项： 为了节省资源，应用一段时间不用就会被 frozen （冻结），但是只要我们去敲链接去访问，就会自动 unfrozen ，只不过初次访问速度会受影响。 在 Now.sh提供的免费服务中，您的代码将是公开的和开源的，如果介意可升级账户或放弃使用。 参考资料： ZEIT-官网 ZEIT-Github ZEIT-Twitter Github Now-CLI NpmJS Now Asynchronous HTTP microservices]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Now.sh</tag>
        <tag>Deployments</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『构建工具-Gradle』相关内容整理]]></title>
    <url>%2F2017%2F09%2F02%2Fgradle-node%2F</url>
    <content type="text"><![CDATA[Gradle - 简介：Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。 当前其支持的语言限于Java、Groovy和Scala，计划未来将支持更多的语言。Gradle，这是一个构建系统(工具)，我们认为这是Java（JVM）世界中构建技术的巨大飞跃。 Gradle提供了： 一个非常灵活的通用构建工具，如Ant。 一种可切换的，像 maven 一样的基于约定约定优于配置的构建框架 强大的多工程构建支持 强大的依赖管理(基于 ApacheIvy) 对已有的 maven 和 ivy 仓库的全面支持 支持传递性依赖管理，而不需要远程仓库或者 pom.xml 或者 ivy 配置文件 ant 式的任务和构建是 gradle 的第一公民 基于 groovy，其 build 脚本使用 groovy dsl 编写 具有广泛的领域模型支持你的构建 Reference：https://docs.gradle.org/4.1/userguide/introduction.html Gradle - 概述：基于声明的构建和基于约定的构建Gradle的核心是基于Groovy的丰富的可扩展的域特定语言（DSL）。Gradle通过提供可以根据需要进行组合的声明性语言元素将声明式构建推送到一个新的层次。这些元素还为Java，Groovy，OSGi，Web和Scala项目提供了逐个常规的支持。更重要的是，这种声明性语言是可扩展的。添加您自己的新语言元素或增强现有的元素，从而提供简洁，可维护和易于理解的构建。 为以依赖为基础的编程方式提供语言支持声明性语言优点在于通用任务图，你可以将其充分利用在构建中. 它提供了最大限度的灵活性，以让 Gradle 适应你的特殊需求。 构建结构化Gradle 的灵活和丰富性最终能够支持在你的构建中应用通用的设计模式。 例如，它可以很容易地将你的构建拆分为多个可重用的模块，最后再进行组装，但不要强制地进行模块的拆分。 不要把原本在一起的东西强行分开（比如在你的项目结构里），从而避免让你的构建变成一场噩梦。 最后，你可以创建一个结构良好，易于维护，易于理解的构建。 深度 APIGradle 允许你在构建执行的整个生命周期，对它的核心配置及执行行为进行监视并自定义。 Gradle 的扩展Gradle 有非常良好的扩展性。 从简单的单项目构建，到庞大的多项目构建，它都能显著地提升你的效率。 这才是真正的结构化构建。通过最先进的增量构建功能，它可以解决许多大型企业所面临的性能瓶颈问题。 多项目构建Gradle 对多项目构建的支持非常出色。项目依赖是首先需要考虑的问题。 我们允许你在多项目构建当中对项目依赖关系进行建模，因为它们才是你真正的问题域。 Gradle 遵守你的布局。 Gradle 提供了局部构建的功能。 如果你在构建一个单独的子项目，Gradle 也会帮你构建它所依赖的所有子项目。 你也可以选择重新构建依赖于特定子项目的子项目。 这种增量构建将使得在大型构建任务中省下大量时间。 多种方式管理依赖不同的团队喜欢用不同的方式来管理他们的外部依赖。 从 Maven 和 Ivy 的远程仓库的传递依赖管理，到本地文件系统的 jar 包或目录，Gradle 对所有的管理策略都提供了方便的支持。 Gradle 是第一个构建集成工具Ant tasks 是最重要的。而更有趣的是，Ant projects 也是最重要的。 Gradle 对任意的 Ant 项目提供了深度导入，并在运行时将 Ant 目标(target)转换为原生的 Gradle 任务(task)。 你可以从 Gradle 上依赖它们(Ant targets)，增强它们，甚至在你的 build.xml 上定义对 Gradle tasks 的依赖。Gradle 为属性、路径等等提供了同样的整合。 Gradle 完全支持用于发布或检索依赖的 Maven 或 Ivy 仓库。 Gradle 同样提供了一个转换器，用于将一个 Maven pom.xml 文件转换为一个 Gradle 脚本。Maven 项目的运行时导入的功能将很快会有。 易于移植Gradle 能适应你已有的任何结构。因此，你总可以在你构建项目的同一个分支当中开发你的 Gradle 构建脚本，并且它们能够并行进行。 我们通常建议编写测试，以保证生成的文件是一样的。 这种移植方式会尽可能的可靠和减少破坏性。这也是重构的最佳做法。 GroovyGradle 的构建脚本是采用 Groovy 写的，而不是用 XML。 但与其他方法不同，它并不只是展示了由一种动态语言编写的原始脚本的强大。 那样将导致维护构建变得很困难。 Gradle 的整体设计是面向被作为一门语言，而不是一个僵化的框架。 并且 Groovy 是我们允许你通过抽象的 Gradle 描述你个人的 story 的黏合剂。 Gradle 提供了一些标准通用的 story。这是我们相比其他声明性构建系统的主要特点。 我们的 Groovy 支持也不是简单的糖衣层，整个 Gradle 的 API 都是完全 groovy 化的。只有通过 Groovy才能去运用它并对它提高效率。 The Gradle wrapperGradle Wrapper 允许你在没有安装 Gradle 的机器上执行 Gradle 构建。 这一点是非常有用的。比如，对一些持续集成服务来说。 它对一个开源项目保持低门槛构建也是非常有用的。 Wrapper 对企业来说也很有用，它使得对客户端计算机零配置。 它强制使用指定的版本，以减少兼容支持问题。 自由和开源Gradle 是一个开源项目，并遵循 ASL 许可。 Reference：https://docs.gradle.org/4.1/userguide/overview.html Gradle - 安装：关于 Gradle 的安装官网上为我们提供了非常详细的过程，如果你使用的是 MacOS，那么建议使用 Homebrew 进行安装，简单快捷。 1234567891011121314➜ ~ brew install gradle # 安装Gradle➜ ~ gradle -v # 查看版本信息------------------------------------------------------------Gradle 4.1------------------------------------------------------------Build time: 2017-08-07 14:38:48 UTCRevision: 941559e020f6c357ebb08d5c67acdb858a3defc2Groovy: 2.4.11Ant: Apache Ant(TM) version 1.9.6 compiled on June 29 2015JVM: 1.8.0_121 (Oracle Corporation 25.121-b13)OS: Mac OS X 10.12.6 x86_64 配置Gradle的环境变量： 1GRADLE_HOME=/usr/local/gradle Reference：https://docs.gradle.org/4.1/userguide/installation.html Gradle - 构建基础：Projects &amp; tasks:projects 和 tasks是 Gradle 中最重要的两个概念。 任何一个 Gradle 构建都是由一个或多个 projects 组成。每个 project 包括许多可构建组成部分。 这完全取决于你要构建些什么。举个例子，每个 project 或许是一个 jar 包或者一个 web 应用，它也可以是一个由许多其他项目中产生的 jar 构成的 zip 压缩包。一个 project 不必描述它只能进行构建操作。它也可以部署你的应用或搭建你的环境。不要担心它像听上去的那样庞大。 Gradle 的 build-by-convention 可以让您来具体定义一个 project 到底该做什么。 每个 project 都由多个 tasks 组成。每个 task 都代表了构建执行过程中的一个原子性操作。如编译，打包，生成 javadoc，发布到某个仓库等操作。 build.gradle文件：示例代码： 12345task hello &#123; doLast &#123; println 'Hello world!' &#125;&#125; 在命令行里, 进入脚本所在的文件夹然后输入 gradle -q hello 来执行构建脚本，示例代码： 1gradle -q hello Hello world! 这里发生了什么? 这个构建脚本定义了一个独立的 task, 叫做 hello, 并且加入了一个 action. 当你运行 gradle hello, Gradle 执行叫做 hello 的 task, 也就是执行了你所提供的 action. 这个 action 是一个包含了一些 Groovy 代码的闭包(closure 这个概念不清楚的同学好好谷歌下). 如果你认为这些看上去和 Ant 的 targets 很相像, 好吧, 你是对的. Gradle tasks 和 Ant 的 targets 是对等的. 但是你将会会看到, Gradle tasks 更加强大. 我们使用一个不同于 Ant 的术语 task, 看上去比 target 更加能直白. 不幸的是这带来了一个术语冲突, 因为 Ant 称它的命令, 比如 javac 或者 copy, 叫 tasks. 所以当我们谈论 tasks, 是指 Gradle 的 tasks. 如果我们讨论 Ant 的 tasks (Ant 命令), 我们会直接称呼 ant task. -q. 代表 quite 模式. 它不会生成 Gradle 的日志信息 (log messages), 所以用户只能看到 tasks 的输出. 它使得的输出更加清晰. 你并不一定需要加入这个选项. Gradle - 构建项目：创建项目目录：示例代码： 12➜ ~ mkdir gradle-app➜ ~ cd gradle-app 使用 Gradle Wrapper构建：示例代码： 1234➜ gradle-app gradle wrapperBUILD SUCCESSFUL in 0s1 actionable task: 1 executed 以下是 Gradle Wrapper 生成的文件。 示例代码： 12345678910➜ gradle-app tree.├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew└── gradlew.bat2 directories, 4 files gradlew : 这是一个可执行文件，应用于运行gradle构建任务 gradlew.bat : 同上，运行再 windows/doc 平台。 gradle/wrapper/gradle-wrapper.properties ：gradle包装器配置文件 gradle-wrapper.properties：示例代码： 123456➜ gradle-app cat gradle/wrapper/gradle-wrapper.propertiesdistributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\://services.gradle.org/distributions/gradle-4.1-bin.zip 初始化你创建的项目：示例代码： 12345678910➜ gradle-app ./gradlew initDownloading https://services.gradle.org/distributions/gradle-4.1-bin.zip................................................................Unzipping /Users/UName/.gradle/wrapper/dists/gradle-4.1-bin/c3kp51zwwt108wc78u68yt7vs/gradle-4.1-bin.zip to /Users/UName/.gradle/wrapper/dists/gradle-4.1-bin/c3kp51zwwt108wc78u68yt7vsSet executable permissions for: /Users/UName/.gradle/wrapper/dists/gradle-4.1-bin/c3kp51zwwt108wc78u68yt7vs/gradle-4.1/bin/gradleBUILD SUCCESSFUL in 18s2 actionable tasks: 1 executed, 1 up-to-date 现在可以再次查看下项目： 123456789101112➜ gradle-app tree.├── build.gradle├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew├── gradlew.bat└── settings.gradle2 directories, 6 files 相较于之前，则多了build.gradle和settings.gradle两个文件。 build.gradle:123456789101112131415161718192021222324252627282930/* * 此构建文件是由Gradle'init'任务生成的。 * * 这个生成的文件包含一个注释掉的示例Java项目，让你开始。 * 有关更多详细信息，请参阅Gradle中的Java Quickstart一章 * 用户指南可在https://docs.gradle.org/4.1/userguide/tutorial_java_projects.html *//*// 应用 JAVA 插件来添加项目对 JAVA 的支持apply plugin: 'java'// 此处可以声明在何处找到项目的依赖关系repositories &#123; //项目空间引用远程仓库--- jcenter(),您可以在这里声明任何Maven / Ivy /文件库。 jcenter()&#125;// 声明生产和测试代码的依赖关系dependencies &#123; // 生产代码在编译时使用SLF4J logging API compile 'org.slf4j:slf4j-api:1.7.25' // 声明您希望在测试中使用的最喜欢的测试框架的依赖关系. // Gradache测试任务也支持TestNG. 只需要testCompile 依赖于 // testCompile 'org.testng:testng:6.8.1' ，和添加 // 'test.useTestNG()' 到你的构建脚本中。 testCompile 'junit:junit:4.12'&#125;*/ settings.gradle:123456789101112131415161718➜ gradle-app cat settings.gradle/* * 此设置文件是由Gradle'init'任务生成的。 * * 设置文件用于指定要在构建中包含哪些项目，在单个项目中构建此文件可以为空或甚至删除。 * * 在用户指南中可以找到有关在Gradle中配置多项目构建的详细信息 * https://docs.gradle.org/4.1/userguide/multi_project_builds.html *//*// 作为多项目构建的一部分 来声明项目使用'include'方法include 'shared'include 'api'include 'services:webservice'*/rootProject.name = 'gradle-app' 继续完善项目：整个项目的目录结构如下,与 Maven 工程目录结构无差别: 目录 说明 src/main/java JAVA 源码 src/main/resources 生产资源文件 src/test/java 测试源码 src/test/resources 测试资源文件 1234567891011121314151617181920212223242526➜ gradle-app tree.├── build.gradle├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradle-app.iml # 导入 IDEA 后生成的文件├── gradlew├── gradlew.bat├── settings.gradle└── src ├── main │ └── java │ └── ws │ └── object │ └── gradle │ └── App.java └── test └── java └── ws └── object └── gradle └── AppTest.java13 directories, 9 files App.java 123456789101112package ws.object.gradle;public class App&#123; public String getAppId() &#123; return "hello-world"; &#125; public static void main( String[] args ) &#123; System.out.println( "Hello World!" ); &#125;&#125; AppTest.java 123456789101112131415package ws.object.gradle;import junit.framework.TestCase;/** * Unit test for simple App. */public class AppTest extends TestCase &#123; public void testAppId() &#123; App app = new App(); assertEquals("App ID", "hello-world", app.getAppId()); &#125;&#125; 构建创建的项目：现在我们已经创建了App.java和AppTest.java，我们准备好构建项目。 这可以通过执行如下所示的构建任务来完成。示例代码： 1234➜ gradle-app ./gradlew buildBUILD SUCCESSFUL in 1s4 actionable tasks: 4 executed 让项目跑起来：使用内置的jar库运行应用程序，示例代码： 12➜ gradle-app java -cp build/libs/gradle-app.jar ws.object.gradle.AppHello World! 或者您可以使用内置的类文件夹运行，示例代码： 12➜ gradle-app java -cp build/classes/java/main/ ws.object.gradle.AppHello World! 参考资料：Gradle Official Website Gradle Wikipedia Gradle Github Building Java Projects with Gradle]]></content>
      <categories>
        <category>Build Tools</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot - Actuator QuickStart]]></title>
    <url>%2F2017%2F08%2F22%2Fspringboot-actuator%2F</url>
    <content type="text"><![CDATA[Spring Boot - Actuator简介:Spring Boot Actuator模块提供了一个监控和管理生产环境的模块，可以使用http、jmx、ssh、telnet等拉管理和监控应用。审计（Auditing）、 健康（health）、数据采集（metrics gathering）会自动加入到应用里面。 Spring Boot - Actuator的特点:Spring Boot Actuator的关键特性是在应用程序里提供了众多的Web站点，通过他们可以来了解应用程序运行时的内部状况。Actuator为Spring Boot项目带来了许多有用的特性，包括： 管理端点 合理的异常处理以及默认的”/error”映射端点 获取应用信息的”/info”端点 当启用Spring Security时，会有一个审计事件框架 SpringBoot - Actuator 的端点：Spring Boot Actuator提供了13个 端点，有了它，你可以知道 Bean 在 Spring应用上下文里是如何组装在一起的，掌握应用程序可以获取的环境属性信息，获取运行时度量信息的快照…… HTTP方法 路径 描述 GET /aotoconfig 提供一份自动配置报告，记录哪些自动配置条件通过那些没通过 GET /configprops 描述配置属性(包含默认值)如何注入 Bean GET /beans 描述应用程序上下文里全部的 Bean，以及他们的关系 GET /dump 获取线程活动的快照 GET /env 获取全部环境属性 GET /env/{name} 根据名称来获取特定的环境属性值 GET /health 报告应用程序的健康指标，这些值由 HealthIndicator 的实现来提供 GET /info 获取应用程序的定制信息，这些信息由 info 开头的属性提供 GET /mappings 描述全部的 URL 路径，以及它们和控制器(包含 Actuator 端点)的映射关系 GET /metrics 报告各种应用程序度量信息，比如内存用量和 HTTP 请求次数 GET /metrics/{name} 根据名称来获取应用程序的度量信息 POST /shutdown 关闭应用程序，要求 endpoints，shutdown，enabled 设置为 True GET /trace 提供基本的 HTTP 请求跟踪信息(时间戳、HTTP 请求头等) SpringBoot - Actuator的使用：需要启动 Actuator 的端点，只需要在项目中引入Actuator的起步依赖即可。 在 Maven 中使用：示例代码： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 在 Gradle 中使用：示例代码： 1compile 'org.springframework.boot:spring-boot-starter-actuator']]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot - 多环境配置(.properties & .yml)]]></title>
    <url>%2F2017%2F08%2F15%2Fspringboot-configuration%2F</url>
    <content type="text"><![CDATA[在Spring Boot的配置文件中，有两种后缀的配置文件，分别是.properties文件和.yml文件。Spring Boot 提供了对应用进行自动化配置。相比以前 XML 的配置方式，很多显式方式申明是不需要的。大多数默认的配置足够实现开发功能，从而更快速开发。 Spring Boot - 两种类型的配置文件 *.properties属性文件；属于最常见的一种； *.yml是yaml格式的文件，yaml是一种非常简洁的标记语言。 .properties文件配置：示例代码： 1234blog.config.title=&quot;柒索&quot;blog.config.subtitle=&quot;我见诸君多傻逼，料诸君见我应如是。&quot;blog.config.url=&quot;http://object.ws&quot;blog.config.number=4000 .yml文件配置：示例代码： 123456blog: config: title: "柒索" subtitle: "我见诸君多傻逼，料诸君见我应如是。" url: "http://object.ws" number: $&#123;random.int&#125; 可以看出两种配置文件的写法yaml 文件的方式更简洁一些，所以推荐使用 yaml 文件来作为 Spring Boot 的配置文件。 Spring Boot - 自定义配置：在配置文件中使用随机数：Spring Boot的属性配置文件中可以通过${random}来产生int值、long值或者string字符串，来支持属性的随机值。 示例代码： 123456789blog: config: url: "http://object.ws" strval: $&#123;random.value&#125; # 产生随机字符串 number: $&#123;random.int&#125; # 产生随机Int类型数值 longnum: $&#123;random.long&#125; # 产生随机 Long类型数值 test1: $&#123;random.int[10]&#125; # 产生10以内的的随机数 test2: $&#123;random.int[10,30]&#125; # 产生10-30之间的随机数 refval: $&#123;blog.config.url&#125;and$&#123;blog.config.strval&#125; # 参数之间的互相引用 自定义配置项代码演示：Spring Boot 为我们提供了许多默认的配置项，但是在开发的过程中，总是会有一些业务需要我们自定义配置，如下代码演示如何使用自定义配置： 示例代码：application.yml 123456blog: config: title: "柒索" subtitle: "我见诸君多傻逼，料诸君见我应如是。" url: "http://object.ws" number: $&#123;random.int&#125; 示例代码：BlogController.java 123456789101112131415161718192021222324252627package ws.object.springboot.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class BlogController &#123; @Value("$&#123;blog.config.title&#125;") String Title; @Value("$&#123;blog.config.subtitle&#125;") String subTitle; @Value("$&#123;blog.config.url&#125;") String Url; @Value("$&#123;blog.config.number&#125;") int Number; @RequestMapping(value = "/blog") public String Blog()&#123; return " Title:"+Title+ " subTitle:"+subTitle+ " URL:"+Url+ " Number:"+Number; &#125;&#125; 之后在浏览器输入http://localhost:8080/blog 就能看到配置在 .yml 文件中的值已经显示在页面里了。 Spring Boot - 多环境配置：在现实的开发环境中，我们需要不同的配置环境，在不同环境下可以配置不同的参数文件，便于部署，提高效率减少出错率，常见配置格式为application-{profile}.properties，其中{profile}对应你的环境标识，比如：dev(开发环境)、test(测试环境)、vis(演示环境)、prod(生产环境)。 application-test.yml：测试环境 application-dev.yml：开发环境 application-prod.yml：生产环境 如何使用？我们只需要在application.yml文件中加上： 123spring: profiles: active: test 其中application-dev.yml: 12server: port: 8080 application-test.yml 12server: port: 8081 启动项目之后，会发现程序的端口不再是8080，而是8081。 Spring Boot - 配置文件优先级：把所有配置全都打在一个jar包里，显然不是最好的做法，更常见的做法是把配置文件放在jar包外面，可以在需要时，不动java代码的前提下修改配置，spring-boot会按以下顺序加载配置文件 application.properties或application.yml： 先查找jar文件同级目录下的 ./config 子目录 有无配置文件 （外置) 再查找jar同级目录 有无配置文件（外置) 再查找config这个package下有无配置文件（内置) 最后才是查找classpath 下有无配置文件（内置) Spring Boot - 常见参数配置：Spring.io-Sring Boot常见配置属性列表 参考资料： 阮一峰-YAML 语言教程 Spring.io-Sring Boot常见配置属性列表]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot - Introduction & QuickStart]]></title>
    <url>%2F2017%2F08%2F10%2Fspringboot-quickstart%2F</url>
    <content type="text"><![CDATA[Spring Boot - 简介： Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. Spring.io Spring Boot - 核心特性： Spring Boot Starter：将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的依赖中。 自动配置：Spring Boot的自动配置特性利用了Spring 4对条件化配置的支持，合理的推测应用所需要的Bean并自动化配置它们。 命令行接口(CLI)：Spring Boot CLI 发挥了Groovy的优势，并结合自动配置进一步简化Spring应用程序的开发。 Actuator：Actuator为Spring Boot应用添加了一定的管理特性。 Spring Boot - QuickStart：使用Spring Initalizr构建Spring Boot项目:要想使用Spring Initalizr，最简单直接的办法就是打开 http://start.spring.io，使用Spring Initalizr的web界面来构建Spring Boot项目。打开Spring Initalizr的web界面后，根据自己需求选择合适的选项： 示例代码： Generate a Maven Project with Java and Spring Boot 1.5.6123Group: ws.object.springbootArtifact: SpringBootDependencies: Web JPA #可多选 如果在当前页面找不到你所需要的依赖，请点击 Switch to the full version ,打开后就能看到可用依赖的完整列表。 填写完成之后，点击Generate Project，Spring Initalizr就会为你生成一个名为SpringBoot.zip的文件，解压后项目结构如下： 123456789101112131415161718192021222324252627➜ unzip SpringBoot.zip➜ tree ./SpringBoot./SpringBoot├── mvnw├── mvnw.cmd├── pom.xml└── src ├── main │ ├── java │ │ └── ws │ │ └── object │ │ └── springboot │ │ └── SpringBoot │ │ └── Application.java │ └── resources │ ├── application.properties │ ├── static │ └── templates └── test └── java └── ws └── object └── springboot └── SpringBoot └── ApplicationTests.java16 directories, 6 files 如你所见，项目中基本没有代码，除了几个空目录之外，还包含了以下几样东西： pom.xml : Maven工程的主要配置文件。 Application.java ： 一个带有main()方法的类，用于引导启动应用程序。 ApplicationTests.java ：一个空的JUnit测试类，它加载了Spring Boot自动配置的Spring应用上下文。 application.properties ：一个空的properties配置文件，可以根据需要添加配置属性。 static目录 ： 放置Web应用程序的静态内容(js，css，images…)。 templates目录 ： 放置用于呈现模型数据的模板文件。 mvnw和mvnw.cmd文件：分别是Windows系统和类Unix系统下Maven的配置文件。 参考资料：Stack Overflow - What is the purpose of mvnw and mvnw.cmd files? 使用IntelliJ IDEA构建Spring Boot项目：打开 IntelliJ IDEA，到Welcome to IntelliJ IDEA 界面，选择 Create New Project，左侧列表栏找到Spring Initalizr，选择自己需要的Project SDk，还有Initalizr Service URL ，Next，填写相关信息： 名称 说明 示例 Group Maven工程组的标识 ws.object.springboot Artifact Maven工程的标识与项目名称一致 SpringBoot Type 项目的构建方式 Maven Project Packaging 打包方式 Jar Java Version Java的版本信息 1.8 Language 编程语言 Java Version 项目版本号 0.0.1-SNAPSHOT Name 项目名称 SpringBoot Description 项目简介 …… 当前页填写完成之后，点击Next，选择项目所需要的依赖，选择完成之后，进入到下一页选择项目的存放路径等信息，然后项目就构建完成了。 使用Spring Boot CLI构建Spring Boot项目：Spring Boot CLI中有一些命令，可以帮我们快速构建Spring Boot项目，示例代码： 12345678910111213141516171819202122232425262728293031➜ mkdir SpringBoot &amp;&amp; cd SpringBoot➜ SpringBoot spring initUsing service at https://start.spring.ioContent saved to 'demo.zip'➜ SpringBoot lsdemo.zip➜ SpringBoot unzip demo.zipArchive: demo.zip inflating: mvnw creating: .mvn/ creating: .mvn/wrapper/ creating: src/ creating: src/main/ creating: src/main/java/ creating: src/main/java/com/ creating: src/main/java/com/example/ creating: src/main/java/com/example/demo/ creating: src/main/resources/ creating: src/test/ creating: src/test/java/ creating: src/test/java/com/ creating: src/test/java/com/example/ creating: src/test/java/com/example/demo/ inflating: .gitignore inflating: .mvn/wrapper/maven-wrapper.jar inflating: .mvn/wrapper/maven-wrapper.properties inflating: mvnw.cmd inflating: pom.xml inflating: src/main/java/com/example/demo/DemoApplication.java inflating: src/main/resources/application.properties inflating: src/test/java/com/example/demo/DemoApplicationTests.java 解压完成之后，使用Tree命令查看一下目录结构： 1234567891011121314151617181920212223➜ SpringBoot tree ../SpringBoot../SpringBoot├── demo.zip├── mvnw├── mvnw.cmd├── pom.xml└── src ├── main │ ├── java │ │ └── com │ │ └── example │ │ └── demo │ │ └── DemoApplication.java │ └── resources │ └── application.properties └── test └── java └── com └── example └── demo └── DemoApplicationTests.java12 directories, 7 files 然后将构建好的项目导入到 IDEA或者 Eclipse中就好了。 Spring Boot - CLI：使用Homebrew安装Spring Boot CLI：示例代码： 123456789101112➜ ~ brew --version # 查看Homebrew版本信息Homebrew 1.3.1➜ ~ brew tap pivotal/tap # 安装Pivotal的tap==&gt; Tapping pivotal/tap ……➜ ~ brew install springboot # 安装Spring Boot==&gt; Installing springboot from pivotal/tap==&gt; Downloading ……➜ ~ spring --version # 查看版本Spring CLI v1.5.6.RELEASE pivotal/tap：Prvotal是Spring以及Spring Boot背后的公司，通过它的tap可以安装Spring Boot。tap是向Homebrew添加额外仓库的一种途径。 Spring Boot CLI:1$ spring init 这条命令会下载一个demo.zip文件，与之前使用spring init构建的项目一样的结构。 1$ spring init -dweb,jpa,security # 使用-d或--dependencies来指定依赖 与spring init命令一样，但是在pom.xml中添加了Spring Boot的Web，JPA，Security起步依赖。 1$ spring init -dweb,jpa,security --build gradle # --build 指定项目使用Grandle构建 使用Gradle来构建项目，默认情况下是使用Maven来构建的。 1$ spring init -dweb,jpa,security --build gradle -p war # -p或者-packaging 默认情况下，无论是Maven或Gradle构建项目成功之后都会产生一个可执行的JAR文件，如果你需要一个war文件，可以通过-p 参数来指定。 1$ spring init -dweb,jpa,security --build gradle ~/Project/SpringBoot 这里的最后一个参数可以指定你的demo.zip文件的解压目录。如果你希望CLI生成的项目解压到当前目录，可以使用 —extract或者-x参数。 1$ spring help 也可以使用 spring help来查看其他命令，并了解如何使用。 Spring Boot Maven Plugin:在pom.xml中配置插件：示例代码： 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 插件的指令详解：1➜ mvn spring-boot:help 显示spring-boot-maven-plugin的帮助信息。调用mvn spring-boot：help -Ddetail = true -Dgoal = &lt;goal-name&gt;显示参数细节。 1➜ mvn spring-boot:build-info 根据当前的内容生成一个build-info.properties文件,在你的Maven Project中。 1➜ mvn spring-boot:repackage 重新包装现有的JAR和WAR存档，以便可以从中执行命令行使用java -jar。使用layout = NONE也可以简单地使用使用嵌套依赖关系打包一个JAR（没有主类，因此不可执行）。 1➜ mvn spring-boot:run 运行基于Maven构建的Spring Boot应用程序。 1➜ mvn spring-boot:start 启动Spring Boot应用程序。通常使用这个命令在应用程序在测试之前启动的集成测试场景中。 1➜ mvn spring-boot:stop 停止由“start”目标开始的应用程序。通常测试套件完成后调用。 参考资料： Spring Boot-Spring.io Spring Boot-Github Spring Boot-Reference.pdf]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HighCharts - 学习笔记整理]]></title>
    <url>%2F2017%2F08%2F05%2Fhightcharts-note%2F</url>
    <content type="text"><![CDATA[HighCharts概述：HighCharts是用JavaScript编写的图表库，可以在Web应用中使用，开源，个人及非商可以任用。 HighCharts特点： 兼容性 - 支持所有主流浏览器和移动平台（android、iOS等）。 多设备 - 支持多种设备，如手持设备 iPhone/iPad、平板等。 免费使用 - 开源免费。 轻量 - highcharts.js 内核库大小只有 35KB 左右。 配置简单 - 使用 json 格式配置 动态 - 可以在图表生成后修改。 多维 - 支持多维图表 配置提示工具 - 鼠标移动到图表的某一点上有提示信息。 时间轴 - 可以精确到毫秒。 导出 - 表格可导出为 PDF/ PNG/ JPG / SVG 格式 输出 - 网页输出图表。 可变焦 - 选中图表部分放大，近距离观察图表； 外部数据 - 从服务器载入动态数据。 文字旋转 - 支持在任意方向的标签旋转。 HighCharts构成：界面构成：在Highcharts中，一个图表通常由图表区，标题，绘图区，坐标轴，图例，数据列等几个部分组成。 代码构成： 标题（Title）： 图表标题，包含标题和副标题（subTitle），其中副标题是非必须的。 坐标轴（Axis）： 坐标轴包含x轴（xAxis）和y轴（yAxis）。通常情况下，x轴显示在图表的底部，y轴显示在图表的左侧。多个数据列可以共同使用同一个坐标轴，为了对比或区分数据，Highcharts提供了多轴的支持。 数据列（Series）： 数据列即图表上一个或多个数据系列，比如曲线图中的一条曲线，柱状图中的一个柱形。 数据提示框（Tooltip）： 当鼠标悬停在某点上时，以框的形式提示该点的数据，比如该点的值、数据单位等。数据提示框内提示的信息完全可以通过格式化函数动态指定。 图例（Legend）： 图例是图表中用不同形状、颜色、文字等 标示不同数据列，通过点击标示可以显示或隐藏该数据列。 版权标签（Credits）： 显示在图表右下方的包含链接的文字，默认是Highcharts官网地址。通过指定credits.enabled=false即可不显示该信息。 导出功能（Exporting）： 通过引入 exporting.js即可增加图表导出为常见文件功能。 示线（PlotLines）： 可以在图表上增加一条标示线，比如平均值线，最高值线等。 示区（PlotBands）： 可以在图表添加不同颜色的区域带，标示出明显的范围区域。 HighCharts配置：HighCharts常用配置项: 配置项 说 明 chart 图表基本配置项 colors 全局颜色 credits 版权信息配置项 data 高级数据模块配置项 defs 定义SVG风格模式适配项 drilldown 下钻功能配置项 exporting 导出功能配置项 labels 标签配置项 legend 图例配置项 loading 加载动画配置项 navigation 导航配置项 noData 无数据模块配置项 pane 面板模块配置项 plotOptions 绘图区配置项 responsive 响应式适配配置项 series 数据列配置项 subtitle 副标题配置项 title 标题配置项 tooltip 提示框配置项 xAxis x轴配置项 yAxis y轴配置项 zAxis z轴配置项 HighCharts图表容器配置：1、通过 dom 调用 highcharts() 函数的方式123$(&quot;#container&quot;).highcharts(&#123; // Highcharts 配置 &#125;); 2、通过 chart.renderTo 来指定123456var charts = new Highcharts.Chart(&#123; // Highcharts 配置 chart : &#123; renderTo : &quot;container&quot; // 注意这里一定是 ID 选择器 &#125;&#125;); 3、通过构造函数123var charts = new Highcharts.Chart(&apos;container&apos;, &#123; // Highcharts 配置&#125;); Highcharts图表样式配置：图表样式属性包括 border、backgroundColor、margin、spacing、style等 边框：包括 borderColor、borderRadius、borderWidth 背景：包括 backgroundColor 外边距：包括 margin、marginTop、marginRight、marginBottom、marginLeft 内边距：包括 spacing、spacingTop、spacingRight、spacingBottom、spacingLeft 其他样式：其他属性例如字体等属性，实例代码 示例代码： 12345678chart: &#123; style: &#123; fontFamily: &quot;&quot;, fontSize: &apos;12px&apos;, fontWeight: &apos;bold&apos;, color: &apos;#006cee&apos; &#125;&#125; 另外还可以通过 chart.className来绑定 CSS 类并给定 CSS 样式。 ​ HIghcharts图表绘图配置：图表绘图区的可配置属性有： plotBackgroundColor ： 绘图区背景颜色 plotBackgroundImage ： 绘图区背景图片 plotBorderColor ： 绘图区边框颜色 plotBorderWidth ： 绘图区边框宽度 plotShadow ： 绘图投影 Highcharts图表常用事件： click ：图表点击事件，效果见 在线演示 load ：图表加载完后事件，效果见 在线演示 addSeries ：图表增加序列事件，效果见 在线演示 drilldown ：图表下钻事件，效果见 在线演示 drillup ： 图表上钻事件，效果见 在线演示 redraw ：图表重绘事件，效果见 在线演示 selection ： 图表范围选择事件，效果见 在线演示 beforePrint ： 图表打印前事件，效果见 在线演示 afterPrint ： 图表打印后事件,效果见 在线演示 Highcharts图表：直线图 - (line)：示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;折线图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1000px; height: 500px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var chart = new Highcharts.Chart('container', &#123; chart: &#123; type: 'line', //指定图表的类型，默认是折线图（line） style: &#123; fontFamily: "Microsoft YaHei", fontSize: '18px', fontWeight: 'bold' &#125; &#125; ,title: &#123; text: '不同城市的月平均气温', // 标题 x: -20 // 相对于水平对齐的偏移量，可以是负数，单位是px &#125;, subtitle: &#123; text: '数据来源: xxx.com', // 副标题 x: -20 //相对于水平对齐的偏移量，可以是负数，单位是px &#125;, xAxis: &#123; // x轴 categories: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'] &#125;, yAxis: &#123; //y轴 title: &#123; text: '温度 (°C)' &#125;, plotLines: [&#123; value: 0, width: 1, color: '#808080' &#125;] &#125;, tooltip: &#123; valueSuffix: '°C' &#125;, legend: &#123; // 图例配置项 layout: 'vertical', // horizontal" 或 "vertical align: 'right', // left，center 和 right verticalAlign: 'middle', // top，middle 和 bottom borderWidth: 0 &#125;, series: [&#123; name: '东京', data: [7.0, 6.9, 9.5, 14.5, 18.2, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6] &#125;, &#123; name: '纽约', data: [-0.2, 0.8, 5.7, 11.3, 17.0, 22.0, 24.8, 24.1, 20.1, 14.1, 8.6, 2.5] &#125;, &#123; name: '柏林', data: [-0.9, 0.6, 3.5, 8.4, 13.5, 17.0, 18.6, 17.9, 14.3, 9.0, 3.9, 1.0] &#125;, &#123; name: '伦敦', data: [3.9, 4.2, 5.7, 8.5, 11.9, 15.2, 17.0, 16.6, 14.2, 10.3, 6.6, 4.8] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 曲线图 - (spline)：示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;曲线图&lt;/title&gt;&lt;/head&gt;&lt;style&gt;#container&#123; width: 1200px; height: 600px; margin:0 auto;&#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart:&#123; // 图表类型 type:'spline' &#125;, title:&#123; // 标题 text:'城市平均气温-曲线图' &#125;, subtitle:&#123; //副标题 text:'东京，纽约，伦敦' &#125;, xAlias:&#123; // x轴 categories: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'] &#125;, yAlias:&#123; // y轴 title: &#123; enable:true, text: 'Temperature (\xB0C)' &#125;, plotLines: [&#123; value: 0, width: 1, color: '#808080' &#125;] &#125;, legend:&#123; layout: 'vertical', align: 'right', verticalAlign: 'middle', borderWidth: 0 &#125;, tooltip:&#123; valueSuffix: '\xB0C', crosshairs: true,//竖线 shared: true &#125;, plotOptions:&#123; spline: &#123; marker: &#123; radius: 4, lineColor: '#666666', lineWidth: 1 &#125; &#125; &#125;, series:[ &#123; name: 'Tokyo', data: [7.0, 6.9, 9.5, 14.5, 18.2, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6] &#125;, &#123; name: 'New York', data: [-0.2, 0.8, 5.7, 11.3, 17.0, 22.0, 24.8, 24.1, 20.1, 14.1, 8.6, 2.5] &#125;, &#123; name: 'London', data: [3.9, 4.2, 5.7, 8.5, 11.9, 15.2, 17.0, 16.6, 14.2, 10.3, 6.6, 4.8] &#125; ] &#125;);&lt;/script&gt;&lt;/html&gt; 面积图 - (area)：示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;面积图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container &#123; width: 1000px; height: 500px; margin: 0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var chat = new Highcharts.Chart('container', &#123; chart: &#123; type: 'area' &#125;, title: &#123; text: '面积图' &#125;, subtitle: &#123; text: '一个简单的面积图' &#125;, xAlias: &#123; //allowDecimals: true, title:&#123; text:'Y轴', categories: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月'] &#125; &#125;, tooltip: &#123; valueSuffix: '单位' &#125;, legend: &#123; layout: 'vertical', align: 'right', verticalAlign: 'middle', borderWidth: 0 &#125;, yAlias: &#123; title: &#123; text: 'Y轴' &#125;,plotLines: [&#123; value: 0, width: 1, color: '#808080' &#125;] &#125;, series: [ &#123; name: '列一', data: [13, 83, 56, 32, 89, 97, 143, 45, 67, 87, 98] &#125;, &#123; name: '列二', data: [13, 23, 61, 62, 15, 27, 83, 75, 47, 17, 28] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 曲线面积图 - (areaspline)：示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;曲线面积图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'areaspline' &#125;, title: &#123; text: '不同家庭一周水果消费情况' &#125;, legend: &#123; layout: 'vertical', align: 'left', verticalAlign: 'top', x: 150, y: 100, floating: true, borderWidth: 1, backgroundColor: (Highcharts.theme &amp;&amp; Highcharts.theme.legendBackgroundColor) || '#FFFFFF' &#125;, xAxis: &#123; categories: [ '周一', '周二', '周三', '周四', '周五', '周六', '周日' ], plotBands: [&#123; // visualize the weekend from: 4.5, to: 6.5, color: 'rgba(68, 170, 213, .2)' &#125;] &#125;, yAxis: &#123; title: &#123; text: '水果 单位' &#125; &#125;, tooltip: &#123; shared: true, valueSuffix: ' 单位' &#125;, credits: &#123; enabled: false &#125;, plotOptions: &#123; areaspline: &#123; fillOpacity: 0.5 &#125; &#125;, series: [&#123; name: '甲', data: [3, 4, 3, 5, 4, 10, 12] &#125;, &#123; name: '乙', data: [1, 3, 4, 3, 3, 5, 4] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 柱状图 - (column)：示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;柱状图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'column' &#125;, title: &#123; text: '堆叠柱形图' &#125;, xAxis: &#123; categories: ['苹果', '橘子', '梨', '葡萄', '香蕉'] &#125;, yAxis: &#123; min: 0, title: &#123; text: '水果消费总量' &#125;, stackLabels: &#123; enabled: true, style: &#123; fontWeight: 'bold', color: 'gray' &#125; &#125; &#125;, legend: &#123; align: 'right', x: -30, verticalAlign: 'top', y: 25, floating: true, backgroundColor: 'white', borderColor: '#CCC', borderWidth: 1, shadow: false &#125;, tooltip: &#123; formatter: function () &#123; return '&lt;b&gt;' + this.x + '&lt;/b&gt;&lt;br/&gt;' + this.series.name + ': ' + this.y + '&lt;br/&gt;' + '总量: ' + this.point.stackTotal; &#125; &#125;, plotOptions: &#123; column: &#123; stacking: 'normal', dataLabels: &#123; enabled: true, color: '#FFF', style: &#123; textShadow: '0 0 3px black' &#125; &#125; &#125; &#125;, series: [&#123; name: '甲', data: [5, 3, 4, 7, 2] &#125;, &#123; name: '乙', data: [2, 2, 3, 2, 1] &#125;, &#123; name: '丙', data: [3, 4, 4, 2, 5] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 条形图 - (bar)：示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;条形图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'bar' &#125;, title: &#123; text: '各洲不同时间的人口条形图' &#125;, subtitle: &#123; text: '数据来源: Wikipedia.org' &#125;, xAxis: &#123; categories: ['非洲', '美洲', '亚洲', '欧洲', '大洋洲'], title: &#123; text: null &#125; &#125;, yAxis: &#123; min: 0, title: &#123; text: '人口总量 (百万)', align: 'high' &#125;, labels: &#123; overflow: 'justify' &#125; &#125;, tooltip: &#123; valueSuffix: ' 百万' &#125;, plotOptions: &#123; bar: &#123; dataLabels: &#123; enabled: true, allowOverlap: true &#125; &#125; &#125;, legend: &#123; layout: 'vertical', align: 'right', verticalAlign: 'top', x: -40, y: 100, floating: true, borderWidth: 1, backgroundColor: '#FFFFFF', shadow: true &#125;, credits: &#123; enabled: false &#125;, series: [&#123; name: '1800 年', data: [107, 31, 635, 203, 2] &#125;, &#123; name: '1900 年', data: [133, 156, 947, 408, 6] &#125;, &#123; name: '2008 年', data: [973, 914, 4054, 732, 34] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 饼图 - (pie)：示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;饼图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; plotBackgroundColor: null, plotBorderWidth: null, plotShadow: false &#125;, title: &#123; text: '2014 某网站各浏览器浏览量占比' &#125;, tooltip: &#123; headerFormat: '&#123;series.name&#125;&lt;br&gt;', pointFormat: '&#123;point.name&#125;: &lt;b&gt;&#123;point.percentage:.1f&#125;%&lt;/b&gt;' &#125;, plotOptions: &#123; pie: &#123; allowPointSelect: true, cursor: 'pointer', dataLabels: &#123; enabled: true, format: '&lt;b&gt;&#123;point.name&#125;&lt;/b&gt;: &#123;point.percentage:.1f&#125; %', style: &#123; color:'black' &#125; &#125; &#125; &#125;, series: [&#123; type: 'pie', name: '浏览器访问量占比', data: [ ['Firefox', 45.0], ['IE', 26.8], &#123; name: 'Chrome', y: 12.8, sliced: true, selected: true &#125;, ['Safari', 8.5], ['Opera', 6.2], ['其他', 0.7] ] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 散点图 - (scatter)：示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;散点图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'scatter', zoomType: 'xy' &#125;, title: &#123; text: '507 人按性别划分的身高和体重分布图' &#125;, subtitle: &#123; text: '数据来源: Heinz 2003' &#125;, xAxis: &#123; title: &#123; enabled: true, text: '身高 (cm)' &#125;, startOnTick: true, endOnTick: true, showLastLabel: true &#125;, yAxis: &#123; title: &#123; text: '体重 (kg)' &#125; &#125;, legend: &#123; layout: 'vertical', align: 'left', verticalAlign: 'top', x: 100, y: 70, floating: true, backgroundColor: '#FFFFFF', borderWidth: 1 &#125;, plotOptions: &#123; scatter: &#123; marker: &#123; radius: 5, states: &#123; hover: &#123; enabled: true, lineColor: 'rgb(100,100,100)' &#125; &#125; &#125;, states: &#123; hover: &#123; marker: &#123; enabled: false &#125; &#125; &#125;, tooltip: &#123; headerFormat: '&lt;b&gt;&#123;series.name&#125;&lt;/b&gt;&lt;br&gt;', pointFormat: '&#123;point.x&#125; cm, &#123;point.y&#125; kg' &#125; &#125; &#125;, series: [&#123; name: '女', color: 'rgba(223, 83, 83, .5)', data: [[161.2, 51.6], [167.5, 59.0], [159.5, 49.2], [157.0, 63.0], [155.8, 53.6], [170.0, 59.0], [159.1, 47.6], [166.0, 69.8], [176.2, 66.8], [160.2, 75.2], [172.5, 55.2], [170.9, 54.2], [172.9, 62.5], [153.4, 42.0], [160.0, 50.0], [147.2, 49.8], [168.2, 49.2], [175.0, 73.2], [157.0, 47.8], [167.6, 68.8], [159.5, 50.6], [175.0, 82.5], [166.8, 57.2], [176.5, 87.8], [170.2, 72.8], [174.0, 54.5], [173.0, 59.8], [179.9, 67.3], [170.5, 67.8], [160.0, 47.0], [154.4, 46.2], [162.0, 55.0], [176.5, 83.0], [160.0, 54.4], [152.0, 45.8], [162.1, 53.6], [170.0, 73.2], [160.2, 52.1], [161.3, 67.9], [166.4, 56.6], [168.9, 62.3], [163.8, 58.5], [167.6, 54.5], [160.0, 50.2], [161.3, 60.3], [167.6, 58.3], [165.1, 56.2], [160.0, 50.2], [170.0, 72.9], [157.5, 59.8], [167.6, 61.0], [160.7, 69.1], [163.2, 55.9], [152.4, 46.5], [157.5, 54.3], [168.3, 54.8], [180.3, 60.7], [165.5, 60.0], [165.0, 62.0], [164.5, 60.3], [156.0, 52.7], [160.0, 74.3], [163.0, 62.0], [165.7, 73.1], [161.0, 80.0], [162.0, 54.7], [166.0, 53.2], [174.0, 75.7], [172.7, 61.1], [167.6, 55.7], [151.1, 48.7], [164.5, 52.3], [163.5, 50.0], [152.0, 59.3], [169.0, 62.5], [164.0, 55.7], [161.2, 54.8], [155.0, 45.9], [170.0, 70.6], [176.2, 67.2], [170.0, 69.4], [162.5, 58.2], [170.3, 64.8], [164.1, 71.6], [169.5, 52.8], [163.2, 59.8], [154.5, 49.0], [159.8, 50.0], [173.2, 69.2], [170.0, 55.9], [161.4, 63.4], [169.0, 58.2], [166.2, 58.6], [159.4, 45.7], [162.5, 52.2], [159.0, 48.6], [162.8, 57.8], [159.0, 55.6], [179.8, 66.8], [162.9, 59.4], [161.0, 53.6], [151.1, 73.2], [168.2, 53.4], [168.9, 69.0], [173.2, 58.4], [171.8, 56.2], [178.0, 70.6], [164.3, 59.8], [163.0, 72.0], [168.5, 65.2], [166.8, 56.6], [172.7, 105.2], [163.5, 51.8], [169.4, 63.4], [167.8, 59.0], [159.5, 47.6], [167.6, 63.0], [161.2, 55.2], [160.0, 45.0], [163.2, 54.0], [162.2, 50.2], [161.3, 60.2], [149.5, 44.8], [157.5, 58.8], [163.2, 56.4], [172.7, 62.0], [155.0, 49.2], [156.5, 67.2], [164.0, 53.8], [160.9, 54.4], [162.8, 58.0], [167.0, 59.8], [160.0, 54.8], [160.0, 43.2], [168.9, 60.5], [158.2, 46.4], [156.0, 64.4], [160.0, 48.8], [167.1, 62.2], [158.0, 55.5], [167.6, 57.8], [156.0, 54.6], [162.1, 59.2], [173.4, 52.7], [159.8, 53.2], [170.5, 64.5], [159.2, 51.8], [157.5, 56.0], [161.3, 63.6], [162.6, 63.2], [160.0, 59.5], [168.9, 56.8], [165.1, 64.1], [162.6, 50.0], [165.1, 72.3], [166.4, 55.0], [160.0, 55.9], [152.4, 60.4], [170.2, 69.1], [162.6, 84.5], [170.2, 55.9], [158.8, 55.5], [172.7, 69.5], [167.6, 76.4], [162.6, 61.4], [167.6, 65.9], [156.2, 58.6], [175.2, 66.8], [172.1, 56.6], [162.6, 58.6], [160.0, 55.9], [165.1, 59.1], [182.9, 81.8], [166.4, 70.7], [165.1, 56.8], [177.8, 60.0], [165.1, 58.2], [175.3, 72.7], [154.9, 54.1], [158.8, 49.1], [172.7, 75.9], [168.9, 55.0], [161.3, 57.3], [167.6, 55.0], [165.1, 65.5], [175.3, 65.5], [157.5, 48.6], [163.8, 58.6], [167.6, 63.6], [165.1, 55.2], [165.1, 62.7], [168.9, 56.6], [162.6, 53.9], [164.5, 63.2], [176.5, 73.6], [168.9, 62.0], [175.3, 63.6], [159.4, 53.2], [160.0, 53.4], [170.2, 55.0], [162.6, 70.5], [167.6, 54.5], [162.6, 54.5], [160.7, 55.9], [160.0, 59.0], [157.5, 63.6], [162.6, 54.5], [152.4, 47.3], [170.2, 67.7], [165.1, 80.9], [172.7, 70.5], [165.1, 60.9], [170.2, 63.6], [170.2, 54.5], [170.2, 59.1], [161.3, 70.5], [167.6, 52.7], [167.6, 62.7], [165.1, 86.3], [162.6, 66.4], [152.4, 67.3], [168.9, 63.0], [170.2, 73.6], [175.2, 62.3], [175.2, 57.7], [160.0, 55.4], [165.1, 104.1], [174.0, 55.5], [170.2, 77.3], [160.0, 80.5], [167.6, 64.5], [167.6, 72.3], [167.6, 61.4], [154.9, 58.2], [162.6, 81.8], [175.3, 63.6], [171.4, 53.4], [157.5, 54.5], [165.1, 53.6], [160.0, 60.0], [174.0, 73.6], [162.6, 61.4], [174.0, 55.5], [162.6, 63.6], [161.3, 60.9], [156.2, 60.0], [149.9, 46.8], [169.5, 57.3], [160.0, 64.1], [175.3, 63.6], [169.5, 67.3], [160.0, 75.5], [172.7, 68.2], [162.6, 61.4], [157.5, 76.8], [176.5, 71.8], [164.4, 55.5], [160.7, 48.6], [174.0, 66.4], [163.8, 67.3]] &#125;, &#123; name: '男', color: 'rgba(119, 152, 191, .5)', data: [[174.0, 65.6], [175.3, 71.8], [193.5, 80.7], [186.5, 72.6], [187.2, 78.8], [181.5, 74.8], [184.0, 86.4], [184.5, 78.4], [175.0, 62.0], [184.0, 81.6], [180.0, 76.6], [177.8, 83.6], [192.0, 90.0], [176.0, 74.6], [174.0, 71.0], [184.0, 79.6], [192.7, 93.8], [171.5, 70.0], [173.0, 72.4], [176.0, 85.9], [176.0, 78.8], [180.5, 77.8], [172.7, 66.2], [176.0, 86.4], [173.5, 81.8], [178.0, 89.6], [180.3, 82.8], [180.3, 76.4], [164.5, 63.2], [173.0, 60.9], [183.5, 74.8], [175.5, 70.0], [188.0, 72.4], [189.2, 84.1], [172.8, 69.1], [170.0, 59.5], [182.0, 67.2], [170.0, 61.3], [177.8, 68.6], [184.2, 80.1], [186.7, 87.8], [171.4, 84.7], [172.7, 73.4], [175.3, 72.1], [180.3, 82.6], [182.9, 88.7], [188.0, 84.1], [177.2, 94.1], [172.1, 74.9], [167.0, 59.1], [169.5, 75.6], [174.0, 86.2], [172.7, 75.3], [182.2, 87.1], [164.1, 55.2], [163.0, 57.0], [171.5, 61.4], [184.2, 76.8], [174.0, 86.8], [174.0, 72.2], [177.0, 71.6], [186.0, 84.8], [167.0, 68.2], [171.8, 66.1], [182.0, 72.0], [167.0, 64.6], [177.8, 74.8], [164.5, 70.0], [192.0, 101.6], [175.5, 63.2], [171.2, 79.1], [181.6, 78.9], [167.4, 67.7], [181.1, 66.0], [177.0, 68.2], [174.5, 63.9], [177.5, 72.0], [170.5, 56.8], [182.4, 74.5], [197.1, 90.9], [180.1, 93.0], [175.5, 80.9], [180.6, 72.7], [184.4, 68.0], [175.5, 70.9], [180.6, 72.5], [177.0, 72.5], [177.1, 83.4], [181.6, 75.5], [176.5, 73.0], [175.0, 70.2], [174.0, 73.4], [165.1, 70.5], [177.0, 68.9], [192.0, 102.3], [176.5, 68.4], [169.4, 65.9], [182.1, 75.7], [179.8, 84.5], [175.3, 87.7], [184.9, 86.4], [177.3, 73.2], [167.4, 53.9], [178.1, 72.0], [168.9, 55.5], [157.2, 58.4], [180.3, 83.2], [170.2, 72.7], [177.8, 64.1], [172.7, 72.3], [165.1, 65.0], [186.7, 86.4], [165.1, 65.0], [174.0, 88.6], [175.3, 84.1], [185.4, 66.8], [177.8, 75.5], [180.3, 93.2], [180.3, 82.7], [177.8, 58.0], [177.8, 79.5], [177.8, 78.6], [177.8, 71.8], [177.8, 116.4], [163.8, 72.2], [188.0, 83.6], [198.1, 85.5], [175.3, 90.9], [166.4, 85.9], [190.5, 89.1], [166.4, 75.0], [177.8, 77.7], [179.7, 86.4], [172.7, 90.9], [190.5, 73.6], [185.4, 76.4], [168.9, 69.1], [167.6, 84.5], [175.3, 64.5], [170.2, 69.1], [190.5, 108.6], [177.8, 86.4], [190.5, 80.9], [177.8, 87.7], [184.2, 94.5], [176.5, 80.2], [177.8, 72.0], [180.3, 71.4], [171.4, 72.7], [172.7, 84.1], [172.7, 76.8], [177.8, 63.6], [177.8, 80.9], [182.9, 80.9], [170.2, 85.5], [167.6, 68.6], [175.3, 67.7], [165.1, 66.4], [185.4, 102.3], [181.6, 70.5], [172.7, 95.9], [190.5, 84.1], [179.1, 87.3], [175.3, 71.8], [170.2, 65.9], [193.0, 95.9], [171.4, 91.4], [177.8, 81.8], [177.8, 96.8], [167.6, 69.1], [167.6, 82.7], [180.3, 75.5], [182.9, 79.5], [176.5, 73.6], [186.7, 91.8], [188.0, 84.1], [188.0, 85.9], [177.8, 81.8], [174.0, 82.5], [177.8, 80.5], [171.4, 70.0], [185.4, 81.8], [185.4, 84.1], [188.0, 90.5], [188.0, 91.4], [182.9, 89.1], [176.5, 85.0], [175.3, 69.1], [175.3, 73.6], [188.0, 80.5], [188.0, 82.7], [175.3, 86.4], [170.5, 67.7], [179.1, 92.7], [177.8, 93.6], [175.3, 70.9], [182.9, 75.0], [170.8, 93.2], [188.0, 93.2], [180.3, 77.7], [177.8, 61.4], [185.4, 94.1], [168.9, 75.0], [185.4, 83.6], [180.3, 85.5], [174.0, 73.9], [167.6, 66.8], [182.9, 87.3], [160.0, 72.3], [180.3, 88.6], [167.6, 75.5], [186.7, 101.4], [175.3, 91.1], [175.3, 67.3], [175.9, 77.7], [175.3, 81.8], [179.1, 75.5], [181.6, 84.5], [177.8, 76.6], [182.9, 85.0], [177.8, 102.5], [184.2, 77.3], [179.1, 71.8], [176.5, 87.9], [188.0, 94.3], [174.0, 70.9], [167.6, 64.5], [170.2, 77.3], [167.6, 72.3], [188.0, 87.3], [174.0, 80.0], [176.5, 82.3], [180.3, 73.6], [167.6, 74.1], [188.0, 85.9], [180.3, 73.2], [167.6, 76.3], [183.0, 65.9], [183.0, 90.9], [179.1, 89.1], [170.2, 62.3], [177.8, 82.7], [179.1, 79.1], [190.5, 98.2], [177.8, 84.1], [180.3, 83.2], [180.3, 83.2]] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 箱线图 - (boxplot)：示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;箱线图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://img.hcharts.cn/highcharts/highcharts-more.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'boxplot' &#125;, title: &#123; text: 'Highcharts 箱线图' &#125;, legend: &#123; enabled: false &#125;, xAxis: &#123; categories: ['1', '2', '3', '4', '5'], title: &#123; text: '' &#125; &#125;, yAxis: &#123; title: &#123; text: '观测值' &#125;, plotLines: [&#123; value: 932, color: 'red', width: 1, label: &#123; text: '理论模型: 932', align: 'center', style: &#123; color: 'gray' &#125; &#125; &#125;] &#125;, tooltip: &#123; pointFormat: '&lt;span style="color:&#123;point.color&#125;"&gt;\u25CF&lt;/span&gt; &lt;b&gt; &#123;series.name&#125;&lt;/b&gt;&lt;br/&gt;' + // eslint-disable-line no-dupe-keys '最大值: &#123;point.high&#125;&lt;br/&gt;' + 'Q2\t: &#123;point.q3&#125;&lt;br/&gt;' + '中位数: &#123;point.median&#125;&lt;br/&gt;' + 'Q1\t: &#123;point.q1&#125;&lt;br/&gt;' + '最小值: &#123;point.low&#125;&lt;br/&gt;' &#125;, series: [&#123; name: '观测值', data: [ [760, 801, 848, 895, 965], [733, 853, 939, 980, 1080], [714, 762, 817, 870, 918], [724, 802, 806, 871, 950], [834, 836, 864, 882, 910] ], tooltip: &#123; headerFormat: '&lt;em&gt;实验号码： &#123;point.key&#125;&lt;/em&gt;&lt;br/&gt;' &#125; &#125;, &#123; name: '异常值', color: Highcharts.getOptions().colors[0], type: 'scatter', data: [ // x, y positions where 0 is the first category [0, 644], [4, 718], [4, 951], [4, 969] ], marker: &#123; fillColor: 'white', lineWidth: 1, lineColor: Highcharts.getOptions().colors[0] &#125;, tooltip: &#123; pointFormat: 'Observation: &#123;point.y&#125;' &#125; &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 气泡图 - (bubble)：示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;气泡图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://img.hcharts.cn/highcharts/highcharts-more.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'bubble', zoomType: 'xy' &#125;, title: &#123; text: 'Highcharts 气泡图' &#125;, series: [&#123; name:'数据列 1', // 每个气泡包含三个值，x，y，z；其中 x，y用于定位，z 用于计算气泡大小 data: [[97, 36, 79], [94, 74, 60], [68, 76, 58], [64, 87, 56], [68, 27, 73], [74, 99, 42], [7, 93, 87], [51, 69, 40], [38, 23, 33], [57, 86, 31]] &#125;, &#123; name:'数据列 2', data: [[25, 10, 87], [2, 75, 59], [11, 54, 8], [86, 55, 93], [5, 3, 58], [90, 63, 44], [91, 33, 17], [97, 3, 56], [15, 67, 48], [54, 25, 81]] &#125;, &#123; name:'数据列 3', data: [[47, 47, 21], [20, 12, 4], [6, 76, 91], [38, 30, 60], [57, 98, 64], [61, 17, 80], [83, 60, 13], [67, 78, 75], [64, 12, 10], [30, 77, 82]] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 误差线图 - (errorbar)：示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;误差图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://img.hcharts.cn/highcharts/highcharts-more.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; zoomType: 'xy' &#125;, title: &#123; text: '误差图' &#125;, xAxis: [&#123; categories: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'] &#125;], yAxis: [&#123; // Primary yAxis labels: &#123; format: '&#123;value&#125; °C', style: &#123; color: Highcharts.getOptions().colors[1] &#125; &#125;, title: &#123; text: '温度', style: &#123; color: Highcharts.getOptions().colors[1] &#125; &#125; &#125;, &#123; // Secondary yAxis title: &#123; text: '降水', style: &#123; color: Highcharts.getOptions().colors[0] &#125; &#125;, labels: &#123; format: '&#123;value&#125; mm', style: &#123; color: Highcharts.getOptions().colors[0] &#125; &#125;, opposite: true &#125;], tooltip: &#123; shared: true &#125;, series: [&#123; name: '降水', type: 'column', yAxis: 1, data: [49.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4], tooltip: &#123; pointFormat: '&lt;span style="font-weight: bold; color: &#123;series.color&#125;"&gt;&#123;series.name&#125;&lt;/span&gt;: &lt;b&gt;&#123;point.y:.1f&#125; mm&lt;/b&gt; ' &#125; &#125;, &#123; name: '降雨误差', type: 'errorbar', yAxis: 1, data: [[48, 51], [68, 73], [92, 110], [128, 136], [140, 150], [171, 179], [135, 143], [142, 149], [204, 220], [189, 199], [95, 110], [52, 56]], tooltip: &#123; pointFormat: '(误差范围: &#123;point.low&#125;-&#123;point.high&#125; mm)&lt;br/&gt;' &#125; &#125;, &#123; name: '温度', type: 'spline', data: [7.0, 6.9, 9.5, 14.5, 18.2, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6], tooltip: &#123; pointFormat: '&lt;span style="font-weight: bold; color: &#123;series.color&#125;"&gt;&#123;series.name&#125;&lt;/span&gt;: &lt;b&gt;&#123;point.y:.1f&#125;°C&lt;/b&gt; ' &#125; &#125;, &#123; name: '温度误差', type: 'errorbar', data: [[6, 8], [5.9, 7.6], [9.4, 10.4], [14.1, 15.9], [18.0, 20.1], [21.0, 24.0], [23.2, 25.3], [26.1, 27.8], [23.2, 23.9], [18.0, 21.1], [12.9, 14.0], [7.6, 10.0]], tooltip: &#123; pointFormat: '(误差范围: &#123;point.low&#125;-&#123;point.high&#125;°C)&lt;br/&gt;' &#125; &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 漏斗图 - (funnel)：示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;漏斗图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1000px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://img.hcharts.cn/highcharts/modules/funnel.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'funnel', marginRight: 100 &#125;, title: &#123; text: '销售漏斗', x: -50 &#125;, plotOptions: &#123; series: &#123; dataLabels: &#123; enabled: true, format: '&lt;b&gt;&#123;point.name&#125;&lt;/b&gt; (&#123;point.y:,.0f&#125;)', color: 'black', softConnector: true &#125;, neckWidth: '30%', neckHeight: '25%' //-- Other available options // height: pixels or percent // width: pixels or percent &#125; &#125;, legend: &#123; enabled: false &#125;, series: [&#123; name: '用户', data: [ ['访问网站', 15654], ['下载产品', 4064], ['询价', 1987], ['发送合同', 976], ['成交', 846] ] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 蜘蛛图：示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;蜘蛛图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; min-width: 400px; max-width: 600px; height: 400px; margin: 0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://img.hcharts.cn/highcharts/highcharts-more.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; polar: true, type: 'line' &#125;, title: &#123; text: '预算与支出', x: -80 &#125;, pane: &#123; size: '80%' &#125;, xAxis: &#123; categories: ['销售', '市场营销', '发展', '客户支持', '信息技术', '行政管理'], tickmarkPlacement: 'on', lineWidth: 0 &#125;, yAxis: &#123; gridLineInterpolation: 'polygon', lineWidth: 0, min: 0 &#125;, tooltip: &#123; shared: true, pointFormat: '&lt;span style="color:&#123;series.color&#125;"&gt;&#123;series.name&#125;: &lt;b&gt;$&#123;point.y:,.0f&#125;&lt;/b&gt;&lt;br/&gt;' &#125;, legend: &#123; align: 'right', verticalAlign: 'top', y: 70, layout: 'vertical' &#125;, series: [&#123; name: '预算拨款', data: [43000, 19000, 60000, 35000, 17000, 10000], pointPlacement: 'on' &#125;, &#123; name: '实际支出', data: [50000, 39000, 42000, 31000, 26000, 14000], pointPlacement: 'on' &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 极地图：示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;极地图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; min-width: 400px; max-width: 600px; height: 400px; margin: 0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://img.hcharts.cn/highcharts/highcharts-more.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; polar: true &#125;, title: &#123; text: '极地图' &#125;, pane: &#123; startAngle: 0, endAngle: 360 &#125;, xAxis: &#123; tickInterval: 45, min: 0, max: 360, labels: &#123; formatter: function () &#123; return this.value + '°'; &#125; &#125; &#125;, yAxis: &#123; min: 0 &#125;, plotOptions: &#123; series: &#123; pointStart: 0, pointInterval: 45 &#125;, column: &#123; pointPadding: 0, groupPadding: 0 &#125; &#125;, series: [&#123; type: 'column', name: '柱形', data: [8, 7, 6, 5, 4, 3, 2, 1], pointPlacement: 'between' &#125;, &#123; type: 'line', name: '线', data: [1, 2, 3, 4, 5, 6, 7, 8] &#125;, &#123; type: 'area', name: '面积', data: [1, 8, 2, 7, 3, 6, 4, 5] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 参考资料： HighCharts官网 HighCharts中文网 HighCharts中文社区 HighCharts官网API]]></content>
      <categories>
        <category>Charts</category>
      </categories>
      <tags>
        <tag>HighCharts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『构建工具-Webpack』相关内容整理]]></title>
    <url>%2F2017%2F07%2F23%2Fwebpack-note%2F</url>
    <content type="text"><![CDATA[Webpack是什么？ webpack is a module bundler.Webpack是一个模块打包器。 webpack 是一个现代 JavaScript 应用程序的模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成少量的 bundle - 通常只有一个，由浏览器加载。 Webpack的特点： 代码拆分： Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。 Loader： Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成Javascript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。 智能解析： Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 js 文件。甚至在加载依赖的时候，允许使用动态表达式 require(“./templates/“ + name + “.jade”)。 插件系统： Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。 快速运行： Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。 Webpack与Gulp的区别？ gulp: gulp强调的是前端开发的工作流程，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程。 PS：Automate and enhance your workflow webpack: webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。 PS：webpack is a module bundle Webpack的核心概念：Web是高度可配置的，在开始前需要先理解四个核心概念：入口(entry)、输出(output)、loader、插件(plugins)。 entry: 在 webpack 中，我们使用 webpack 配置对象(webpack configuration object)中的 entry 属性来定义入口。看一个最简单的例子： 123module.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;&#125;; Output:将所有的资源(assets)归拢在一起后，还需要告诉 webpack 在哪里打包应用程序。webpack 的 output 属性描述了如何处理归拢在一起的代码(bundled code)。例子： 123456789const path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; &#125;&#125;; Loader: webpack loader 在文件被添加到依赖图中时，其转换为模块。例子： 12345678910111213141516const path = require(&apos;path&apos;);const config = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125; ] &#125;&#125;;module.exports = config; Plugins：想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 来创建它的一个实例。例子： 12345678910111213141516171819202122const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //installed via npmconst webpack = require(&apos;webpack&apos;); //to access built-in pluginsconst path = require(&apos;path&apos;);const config = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;) ]&#125;;module.exports = config; 参考资料:核心概念简介 Webpack的安装配置：前提条件:请安装和使用 Node.js 最新的长期支持版本(LTS - Long Term Support)，使用旧版本，你可能遇到各种问题，因为它们可能缺少 webpack 功能以及/或者缺少相关 package 包。 本地安装：最新版本的webpack是: Github-Webpack-Releases1npm install -g webpack --save-dev 安装完成之后，会在package.json中会添加如下信息： 123&quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^3.4.1&quot;&#125; 对于大多数项目，建议本地安装。这可以使我们在引入破坏式变更(breaking change)的依赖时，更容易分别升级项目。一般不推荐全局安装 webpack。这会将您项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中，可能会导致构建失败。 Webpack的简单使用:构建项目：新建一个index.js文件，在跟该文件中编写一个函数： 1234// index.js 文件function func(str) &#123; alert(str);&#125; 编写完成之后可以使用webpack命令了来打包index.js文件，如下所示： 12345678910语法: webpack [待打包文件] [打包完成文件名]例子: webpack index.js index.bundle.js➜ js webpack index.js index.bundle.jsHash: 72aeecc257bb3571dac7Version: webpack 3.4.1Time: 61ms Asset Size Chunks Chunk Namesindex.bundle.js 2.51 kB 0 [emitted] main [0] ./index.js 37 bytes &#123;0&#125; [built] 打包输出信息说明： Name Description Hash 文件的HASH值 Version webpack的版本 Time 打包所花费的时间 Asset 打包生成的文件 Size 生成文件的大小 Chunks 打包的分块 Chunk Names 打包的块名称 这样就完成了一次简单的打包操作，打包完成之后可以打开index.bundle.js查看一下，Webpack会自动给该文件中添加一些注释还会给一些模块进行编号。 参考资料：Webpack官网简单Demo Webpack的基本配置:按照如下目录结构进行构建一个项目： 1234567891011121314151617➜ ~ tree WebpackWebpack├── dist│ ├── css│ └── js├── node_modules├── package-lock.json├── package.json├── src│ ├── css│ │ └── style.css│ ├── index.html│ └── js│ └── index.js└── webpack.config.js7 directories, 6 files webpack.config.js编写webpack.config.js文件： 123456789101112131415161718const webpack = require(&apos;webpack&apos;);module.exports = &#123; entry:&apos;./src/js/index.js&apos;, output:&#123; path:&apos;/Users/Yang/Documents/Webstorm-Work/Webpack/dist/js&apos;, // 设置输出目录 filename:&apos;[name].bundle.js&apos; // 输出文件名 &#125;,module:&#123; loaders:[ test:/\.css$/,//支持正则 loader:&apos;style-loader!css-loader&apos; ] &#125;,resolve:&#123; //添加在此的后缀所对应的文件可以省略后缀 extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;, &apos;.css&apos;, &apos;.scss&apos;] &#125;,plugins:[ new webpack.BannerPlugin(&apos;This file is created by ly&apos;); // 插件设置 ]&#125; Webpack的Loader使用：loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 简单示例：可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loader： 12npm install --save-dev css-loader # CSS loadernpm install --save-dev ts-loader # TypeScript loader 然后指示 webpack 对每个 .css 使用 css-loader，以及对所有 .ts 文件使用 ts-loader： webpack.config.js 12345678module.exports = &#123; module: &#123; rules: [ &#123; test: /\.css$/, use: &apos;css-loader&apos; &#125;, &#123; test: /\.ts$/, use: &apos;ts-loader&apos; &#125; ] &#125;&#125;; 使用 Loader：在应用程序中，有三种使用 loader 的方式： 配置（推荐）：在 webpack.config.js 文件中指定 loader。 内联：在每个 import 语句中显式指定 loader。 CLI：在 shell 命令中指定它们。 配置[Configuration]:module.rules 允许你在 webpack 配置中指定多个 loader。 这是展示 loader 的一种简明方式，并且有助于使代码变得简洁。同时让你对各个 loader 有个全局概览： 12345678910111213141516module: &#123; rules: [ &#123; test: /\.css$/, use: [ &#123; loader: &apos;style-loader&apos; &#125;, &#123; loader: &apos;css-loader&apos;, options: &#123; modules: true &#125; &#125; ] &#125; ]&#125; 内联:可以在 import 语句或任何等效于 “import” 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。 1import Styles from &apos;style-loader!css-loader?modules!./styles.css&apos;; 通过前置所有规则及使用 !，可以对应覆盖到配置中的任意 loader。 选项可以传递查询参数，例如 ?key=value&amp;foo=bar，或者一个 JSON 对象，例如 ?{&quot;key&quot;:&quot;value&quot;,&quot;foo&quot;:&quot;bar&quot;}。 尽可能使用 module.rules，因为这样可以减少源码中的代码量，并且可以在出错时，更快地调试和定位 loader 中的问题。 CLI:你也可以通过 CLI 使用 loader： 1webpack --module-bind jade-loader --module-bind &apos;css=style-loader!css-loader&apos; 这会对 .jade 文件使用 jade-loader，对 .css 文件使用 style-loader 和 css-loader。 Loader 特性: loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照先后顺序进行编译。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。 loader 可以是同步的，也可以是异步的。 loader 运行在 Node.js 中，并且能够执行任何可能的操作。 loader 接收查询参数。用于对 loader 传递配置。 loader 也能够使用 options 对象进行配置。 除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。 插件(plugin)可以为 loader 带来更多特性。 loader 能够产生额外的任意文件。 loader 通过（loader）预处理函数，为 JavaScript 生态系统提供了更多能力。用户现在可以更加灵活地引入细粒度逻辑，例如压缩、打包、语言翻译和其他更多。 解析 Loader:loader 遵循标准的模块解析。多数情况下，loader 将从模块路径（通常将模块路径认为是 npm install, node_modules）解析。 loader 模块需要导出为一个函数，并且使用 Node.js 兼容的 JavaScript 编写。通常使用 npm 进行管理，但是也可以将自定义 loader 作为应用程序中的文件。按照约定，loader 通常被命名为 xxx-loader（例如 json-loader）。有关详细信息，请查看如何编写 loader？。 参考资料：Webpack-Loader详解 Webpack的CLI使用:Output：通过以下这些配置，你可以调整构建流程的某些输出参数。 常用参数说明： 参数 说明 输入类型 默认值 –output-chunk-filename 输出的附带 chunk 的文件名 string 含有[id] 的文件名，而不是 [name] 或者 [id] 作为前缀 –output-filename 打包文件的文件名 string [name].js –output-jsonp-function 加载 Chunk 时使用的 JSONP 函数名 string webpackJsonp –output-library 以库的形式导出入口文件 string –output-library-target 以库的形式导出入口文件时，输出的类型 string var –output-path 输出的路径（在公共路径的基础上） string 当前目录 –output-pathinfo 加入一些依赖信息的注解 boolean false –output-public-path 输出文件时使用的公共路径 string / –output-source-map-filename 生成的 SourceMap 的文件名 string [name].map or [outputFilename].map Debug：以下这些配置可以帮助你在 Webpack 编译过程中更好地 debug。 常用参数说明： 参数 说明 输入类型 默认值 –debug 把 loader 设置为 debug 模式 boolean false –devtool 为打包好的资源定义source map 的类 string - –progress 打印出编译进度的百分比值 boolean false Model：这些配置可以用于绑定 Webpack 允许的模块。 常用参数说明： 参数 说明 使用方法 –module-bind 为 loader 绑定一个扩展 –module-bind js=babel-loader –module-bind-post 为 post loader 绑定一个扩展 –module-bind-pre 为 pre loader 绑定一个扩展 Watch:这些配置可以用于观察依赖文件的变化，一旦有变化，则可以重新执行构建流程。 常用参数说明： 参数 说明 –watch, -w 观察文件系统的变化 –save, -s 在保存的时候重新编译，无论文件是否变化 –watch-aggregate-timeout 指定一个毫秒数，在这个时间内，文件若发送了多次变化，会被合并 –watch-poll 轮询观察文件变化的时间间隔（同时会打开轮询机制 –watch-stdin, –stdin 当 stdin 关闭时，退出进程 Optimize：在生产环境的构建时，这些配置可以用于调整的一些性能相关的配置。 常用参数说明： 参数 解释说明 使用的插件 –optimize-max-chunks 限制 chunk 的数量 LimitChunkCountPlugin –optimize-min-chunk-size 限制 chunk 的最小体积 MinChunkSizePlugin –optimize-minimize 压缩混淆 javascript，并且把 loader 设置为 minimizing UglifyJsPlugin &amp; LoaderOptionsPlugin Resolve：这些配置可以用于设置 webpack resolver 时使用的别名(alias)和扩展名(extension)。 常用参数说明： 参数 说明 示例 –resolve-alias 指定模块的别名 –resolve-alias jquery-plugin=jquery.plugin –resolve-extensions 指定需要被处理的文件的扩展名 –resolve-extensions .es6 .js .ts –resolve-loader-alias Minimize javascript and switches loaders to minimizing Display：以下选项用于配置 Webpack 在控制台输出的统计数据，以及这些数据的样式。 常用参数说明： 参数 说明 类型 –color, –colors 开启/关闭控制台的颜色 [默认值: (supports-color)] boolean –display-cached 在输出中显示缓存的模块 boolean –display-cached-assets 在输出中显示缓存的 assets boolean –display-chunks 在输出中显示 chunks boolean –display-depth 显示从入口起点到每个模块的距离 boolean –display-entrypoints 在输出中显示入口文件 boolean –display-error-details 显示详细的错误信息 boolean –display-exclude 在输出中显示被排除的文件 boolean –display-max-modules 设置输出中可见模块的最大数量 number –display-modules 在输出中显示所有模块，包括被排除的模块 boolean –display-optimization-bailout 作用域提升回退触发器(Scope hoisting fallback trigger)（从 webpack 3.0.0 开始） boolean –display-origins 在输出中显示最初的 chunk boolean –display-provided-exports 显示有关从模块导出的信息 boolean –display-reasons 显示模块包含在输出中的原因 boolean –display-used-exports 显示模块中被使用的接口（Tree Shaking） boolean –hide-modules 隐藏关于模块的信息 boolean –sort-assets-by 对 assets 列表以某种属性排序 string –sort-chunks-by 对 chunks 列表以某种属性排序 string –sort-modules-by 对模块列表以某种属性排序 string –verbose 显示更多信息 boolean –display 选择显示预设(verbose - 繁琐, detailed - 细节, normal - 正常, minimal - 最小, errors-only - 仅错误, none - 无; 从 webpack 3.0.0 开始) string Other： 参数 说明 用法 –bail 一旦发生错误，立即终止 –cache 开启缓存 [watch 时会默认打开] –cache=false –define 定义 bundle 中的任意自由变量，查看 shimming –define process.env.NODE_ENV=’development’ –hot 开启模块热替换 [使用 HotModuleReplacementPlugin] -hot=true –labeled-modules Enables 开启模块标签 [使用 LabeledModulesPlugin] -plugin 加载某个插件 –prefetch 预加载某个文件 –prefetch=./files.js –provide 在所有模块中将这些模块提供为自由变量，查看 shimming –provide jQuery=jquery –records-input-path 记录文件的路径（读取） –records-output-path 记录文件的路径（写入） –records-path 记录文件的路径 –target 目标的执行环境 –target=’node’ 参考资料：Webpack-CLI使用 参考资料: Webpack 1.x 官方文档 Webpack 2.x 官方文档 Webpack 中文网 Webpack 视频教程 Webpack-API]]></content>
      <categories>
        <category>Build Tools</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『构建工具-Maven』相关内容整理]]></title>
    <url>%2F2017%2F07%2F04%2Fmaven-note%2F</url>
    <content type="text"><![CDATA[Maven-工具简介: Apache Maven是跨平台的项目管理工具，主要服务于基于Java平台的项目构建、依赖管理和项目信息管理。Maven可以自动化构建过程，从清理、编译、测试到生成报告，再到打包和部署。Maven最大化地消除了构建的重复，抽象了构建生命周期，并且为绝大部分的构建任务提供了已实现的插件，我们不再需要定义过程，甚至不需要再去实现这些过程中的一些任务。 最简单的例子就是测试，我们没必要告诉Maven去测试，更不需要告诉Maven如何运行测试，只需要遵循Maven的约定编写好测试用例当我们运行构建的时候，这些测试便会自动运行。 Maven-环境配置: Maven是一个基于Java的构建工具，所以在安装Maven之前必须配置好Java的相关环境。 检查JAVA环境是否正常: 1java -version 下载并解压Maven: 下载 123 Mac用户可以使用[Homebrew](https://brew.sh/)来安装Mavenbrew search maven # 搜索brew install maven # 安装 设置Maven环境变量: 12export M2_HOME=/Users/Hostname/Software/apache-maven-3.3.9export PATH=$PATH:$M2_HOME/bin 验证Maven是否安装成功: 1234567输入： mvn -v 或者 mvn -versionApache Maven 3.3.9 (bb52d8502b132ec38323dc5; 2015-11-11T00:41:47+08:00)Maven home: /Users/Hostname/Software/apache-maven-3.3.9Java version: 1.8.0_121, vendor: Oracle CorporationJava home: /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jreDefault locale: zh_CN, platform encoding: UTF-8OS name: &quot;mac os x&quot;, version: &quot;10.12.3&quot;, arch: &quot;x86_64&quot;, family: &quot;mac&quot; Maven-POM:什么是POM?POM 代表工程对象模型。它是使用 Maven 工作时的基本组建，是一个 xml 文件。它被放在工程根目录下，文件命名为 pom.xml。POM 包含了关于工程和各种配置细节的信息，Maven 使用这些信息构建工程。 * project dependencies * plugins * goals * build profiles * project version * developers * mailing list 在仓库中工程组（groupId），及其名称（artifactId）和版本这些属性是工程的唯一标识。 POM文件示例：&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;ws.object&lt;/groupId&gt; &lt;artifactId&gt;mvnPro&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;mvnPro&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 需要说明的是每个工程应该只有一个 POM 文件。 所有的 POM 文件需要 project 元素和三个必须的字段：groupId, artifactId,version。 在仓库中的工程标识为 groupId:artifactId:version POM.xml 的根元素是 project，它有三个主要的子节点： POM文件节点详解： 节点 描述 groupId 这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，一个银行组织 ws.object.mvn 拥有所有的和银行相关的项目。 artifactId 这是工程的标识。它通常是工程的名称。例如，消费者银行。groupId和artifactId 一起定义了 artifact 在仓库中的位置。 version 这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。例如:ws.object.mvn:consumer-banking:1.0 ws.object.mvn:consumer-banking:1.1. Maven-构建生命周期什么是构建?除了编写源代码，我们每天有相当一部分时间花在了编译、运行单元测试、生成文档、打包和部署等繁琐而不起眼的工作上，这就是构建（build）。 Maven的三套生命周期Maven有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，一般容易将Maven的生命周期看成一个整体，其实不然。这三套生命周期分别是： Clean Lifecycle 在进行真正的构建之前进行一些清理工作。 Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。 Site Lifecycle 生成项目报告，站点，发布站点。 我再次强调一下它们是相互独立的，你可以仅仅调用clean来清理工作目录，仅仅调用site来生成站点。当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。 每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行mvn clean ，这个的clean是Clean生命周期的一个阶段。Clean生命周期，也有clean阶段。Clean生命周期一共包含了三个阶段： pre-clean 执行一些需要在clean之前完成的工作 clean 移除所有上一次构建生成的文件 post-clean 执行一些需要在clean之后立刻完成的工作 Site生命周期的各个阶段： pre-site 执行一些需要在生成站点文档之前完成的工作 site 生成项目的站点文档 post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 site-deploy 将生成的站点文档部署到特定的服务器上 Default生命周期：Maven中最重要的Default生命周期,绝大部分工作都发生在这个生命周期中，下面列出一些常用的阶段： 生命周期阶段 描述 validate 检查工程配置是否正确，完成构建过程的所有必要信息是否能够获取到。 initialize 初始化构建状态，例如设置属性。 generate-sources 生成编译阶段需要包含的任何源码文件。 process-sources 处理源代码，例如，过滤任何值（filter any value）。 generate-resources 生成工程包中需要包含的资源文件。 process-resources 拷贝和处理资源文件到目的目录中，为打包阶段做准备。 compile 编译工程源码。 process-classes 处理编译生成的文件，例如 Java Class 字节码的加强和优化。 generate-test-sources 生成编译阶段需要包含的任何测试源代码。 process-test-sources 处理测试源代码，例如，过滤任何值（filter any values)。 test-compile 编译测试源代码到测试目的目录。 process-test-classes 处理测试代码文件编译后生成的文件。 test 使用适当的单元测试框架（例如JUnit）运行测试。 prepare-package 在真正打包之前，为准备打包执行任何必要的操作。 package 获取编译后的代码，并按照可发布的格式进行打包，例如 JAR、WAR或者EAR文件。 pre-integration-test 在集成测试执行之前，执行所需的操作。例如，设置所需的环境变量。 integration-test 处理和部署必须的工程包到集成测试能够运行的环境中。 post-integration-test 在集成测试被执行后执行必要的操作。例如，清理环境。 verify 运行检查操作来验证工程包是有效的，并满足质量要求。 install 安装工程包到本地仓库中，该仓库可以作为本地其他工程的依赖。 deploy 拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程。 Maven-仓库什么是 Maven 仓库？在 Maven 的术语中，仓库是一个位置（place），例如目录，可以存储所有的工程 jar 文件、library jar 文件、插件或任何其他的工程指定的文件。 Maven 仓库有三种类型： 本地（local） 中央（central） 远程（remote） 本地仓库:Maven 本地仓库是机器上的一个文件夹。它在你第一次运行任何 maven 命令的时候创建。 Maven 本地仓库保存你的工程的所有依赖（library jar、plugin jar 等）。当你运行一次 Maven 构建，Maven会自动下载所有依赖的 jar 文件到本地仓库中。它避免了每次构建时都引用存放在远程机器上的依赖文件。Maven 本地仓库默认被创建在 %USER_HOME% 目录下。要修改默认位置，在 %M2_HOME%\conf 目录中的 Maven 的 settings.xml 文件中定义另一个路径。 ​1234567&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; &lt;localRepository&gt;/Users/HostName/Public/MavenRepository&lt;/localRepository&gt;&lt;/settings&gt;​ 中央仓库:Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。中央仓库的关键概念： * 这个仓库由 Maven 社区管理。 * 不需要配置。 * 需要通过网络才能访问。 要浏览中央仓库的内容，maven 社区提供了一个 URL：http://search.maven.org/#browse。使用这个仓库，开发人员可以搜索所有可以获取的代码库。 远程仓库:如果 Maven 在中央仓库中也找不到依赖的库文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的jar 文件。举例说明，使用下面的 POM.xml，Maven 将从远程仓库中下载该 pom.xml 中声明的所依赖的（在中央仓库中获取不到的）文件。 ​123456789101112131415161718192021222324252627&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;ws.object&lt;/groupId&gt; &lt;artifactId&gt;mvnPro&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.companyname.common-lib&lt;/groupId&gt; &lt;artifactId&gt;common-lib&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependencies&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;companyname.lib1&lt;/id&gt; &lt;url&gt;http://download.companyname.org/maven2/lib1&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;companyname.lib2&lt;/id&gt; &lt;url&gt;http://download.companyname.org/maven2/lib2&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt;​ Maven 依赖搜索顺序: 当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库： 1. 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。 2. 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中已被将来引用。 3. 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。 4. 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库已被将来引用，否则 Maven将停止处理并抛出错误（无法找到依赖的文件）。 Maven-插件什么是 Maven 插件？Maven实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。Maven插件通常被用来： 创建 jar 文件 创建 war 文件 编译代码文件 代码单元测试 创建工程文档 创建工程报告 插件通常提供了一个目标的集合，并且可以使用下面的语法执行： 1mvn [plugin-name]:[goal-name] 例如，一个 Java 工程可以使用 maven-compiler-plugin 的 compile-goal 编译，使用以下命令： 1mvn compiler:compile 插件类型Maven 提供了下面两种类型的插件： 类型 描述 Build plugins 在构建时执行，并在 pom.xml 的元素中配置。 Reporting plugins 在网站生成过程中执行，并在 pom.xml 的元素中配置。 ###常用插件列表： 插件 描述 clean 构建之后清理目标文件。删除目标目录。 compiler 编译 Java 源文件。 surefile 运行 JUnit 单元测试。创建测试报告。 jar 从当前工程中构建 JAR 文件。 war 从当前工程中构建 WAR 文件。 javadoc 为工程生成 Javadoc。 antrun 从构建过程的任意一个阶段中运行一个 ant 任务的集合。 Maven-创建工程Maven 使用原型（archetype）插件创建工程。要创建一个简单的Java应用，我们将使用 maven-archetype-quickstart 插件。在下面的例子中，我们将创建一个基于 maven 的 java 应用工程。 12345mvn archetype:generate \-DgroupId=ws.object \-DartifactId=Example \-DarchetypeArtifactId=maven-archetype-quickstart \-DinteractiveMode=false 12345678910111213[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building Maven Stub Project (No POM) 1[INFO] ------------------------------------------------------------------------……------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 4.277 s[INFO] Finished at: 2017-07-13T14:10:19+08:00[INFO] Final Memory: 14M/214M[INFO] ------------------------------------------------------------------------ 出现 BUILD SUCCESS 即项目创建成功！ 模板 含义 mvn archetype:generate 固定格式 -DgroupId 组织标识（包名) -DartifactId 项目名称 -DinteractiveMode 是否使用交互模式 -DarchetypeArtifactId 指定ArchetypeId，maven-archetype-quickstart,创建一个Java Project；maven-archetype-webapp，创建一个Web Project Maven-工程模板(archetype)Maven 使用原型（Archetype）概念为用户提供了大量不同类型的工程模版（614 个）。Maven 使用下面的命令帮助用户快速创建 java 项目。 1mvn archetype:generate 什么是原型？ 原型是一个 Maven 插件，它的任务是根据模板创建一个项目结构。我们将使用 quickstart 原型插件创建一个简单的 java 应用程序。 Maven-web应用 创建 Web 应用建立一个简单的 Java web 应用，我们可以使用 maven-archetype-webapp 插件。首先我们打开terminal，输入以下的 mvn 命令。mvn archetype:generate \-DgroupId=ws.object.example \-DartifactId=example \-DarchetypeArtifactId=maven-archetype-webapp \-DinteractiveMode=falseMaven 将开始处理并且将创建完整的基于 Web 的 java 应用工程结构。 Maven-参考资料 Maven官网:http://maven.apache.org/ 官网介绍:http://maven.apache.org/what-is-maven.html Wikipedia:https://zh.wikipedia.org/wiki/Apache_Maven Maven教程:http://www.yiibai.com/maven/ Maven详解:http://www.cnblogs.com/hongwz/p/5456578.html 国外Maven教程:http://www.tutorialspoint.com/maven/index.htm 常用骨架简介:http://www.cnblogs.com/iusmile/archive/2012/11/14/2770118.html]()]]></content>
      <categories>
        <category>Build Tools</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lombok - 使用注解让你的JavaBean变得更加简洁]]></title>
    <url>%2F2017%2F06%2F23%2Flombok-note-md%2F</url>
    <content type="text"><![CDATA[Lombok - 工具简介：Lombok是一个编译时注释预处理器，有助于在编译时注入一些代码。Lombok提供了一组在开发时处理的注释，以将代码注入到Java应用程序中，注入的代码在开发环境中立即可用。在详细介绍之前，可以去其官网看一下作者提供的视频，视频中阐述了Lombok 的简单用法。https://projectlombok.org/ Lombok - 安装过程：基于 Maven：示例代码： 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加好 Maven 依赖之后，就可以在代码中使用 Lombok 的注解来简化代码了。 基于IntelliJ IDEA：安装 Lombok IntelliJ plugin:Jetbrains IntelliJ IDEA Editor完全兼容 Lombok，要在 IDEA 中使用 Lombok，那就需要在IntelliJ IDEA 中安装 Lombok IntelliJ plugin 插件，以下为安装步骤： Go to File &gt; Settings &gt; Plugins Click on Browse repositories... Search for Lombok Plugin Click on Install plugin Restart IntelliJ IDEA 具体安装过程可参考官网或者插件 Github 主页。 在IntelliJ IDEA使用Lombok: Go to Refactor &gt; Lombok 在打开的 JavaBean 文件中按照需求添加相应的注解即可。 Lombok - 常用注解：你如果是使用IDEA的话，在当前文件上按command+F12，或者长按command在左侧找到Structure，就能够看到 lombok 为当前类生成的方法。 @Data ：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法 示例代码： 12345678import lombok.Data;@Datapublic class Person &#123; private String firstName; private String lastName; private String job;&#125; @Setter/@Getter：注解在属性或类上；为属性提供 Setter/Getter 方法 示例代码： 1234567891011import lombok.Getter;import lombok.Setter;// 只为 firstName 生成Getter、Setter 方法public class Person &#123; @Getter @Setter private String firstName; private String lastName; private String job;&#125; 123456789101112import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class Person &#123;// 为所有字段生成Getter、Setter 方法 private String firstName; private String lastName; private String job;&#125; @Log4j ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象 @Value：此注解集@equals()、@hashCode()、@toString()、@Getter()于一身。 示例代码： 123456789101112131415import lombok.Value;import lombok.experimental.NonFinal;@Valuepublic class Person &#123; /** 类本身以及类中所有的字段都是private final类型的，不会生成Setter方法。 * 可以通过显式指定某个注解覆盖掉默认的属性。 * 通过@NonFinal注解修饰的字段，不是final类型的。 */ String firstName; String lastName; @NonFinal String job;&#125; ​ @NoArgsConstructor/@AllArgsConstructor: 自动生成无参数构造函数/全参构造函数。 示例代码： 123456789101112import lombok.AllArgsConstructor;import lombok.NoArgsConstructor;@NoArgsConstructor@AllArgsConstructorpublic class Person &#123; private String firstName; private String lastName; private String job;&#125; ​ @NonNull :修饰方法、构造函数的参数或者类字段，Lombok自动生成一个非空检测语句。 示例代码： 12345678import lombok.NonNull;public class Person&#123; public String Example(@NonNull String sum)&#123; return null; &#125;&#125; ​ @Synchronized 将方法变成同步方法 @SneakyThrows：将受检异常转换为非受检异常，避免抛出或尝试语句。 ​ lombok 项目官网上还有一些其他注解的用法，此处就不列举了，附链接：https://projectlombok.org/features/all 参考资料： Lombok Official Website Lombok Github Lombok IntelliJ plugin]]></content>
      <categories>
        <category>Java Tools</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Lombok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『Enterprise Java - Servlet』 在 Java8中使Servlet 3.1]]></title>
    <url>%2F2017%2F06%2F05%2Fentjava-servlet%2F</url>
    <content type="text"><![CDATA[前言：本文讲解了在 JAVA8的环境中使用 Servlet3.1的标准容器中使用 Http 上下文的方式来深入了解 Servlet，通过一个简单的Maven Web项目，可以通过您喜爱的浏览器或Postman来访问。 环境准备： Java Version : 1.8.0_121 Maven Version：Apache Maven 3.3.9 IDE：IntelliJ IDEA (2017.2.3) System：macOS Sierra Servlet - 简介:Servlet是基于Java技术的web组件，容器托管的，用于生成动态内容。它是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。像其他基于Java的组件技术一样，Servlet也是基于平台无关的Java类格式，被编译为平台无关的字节码，可以被基于Java技术的web server动态加载并运行。容器，有时候也叫做servlet引擎，是web server为支持servlet功能扩展的部分。客户端通过Servlet容器实现的请求/应答模型与Servlet交互。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势： 性能明显更好。 Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。 Servlet 是独立于平台的，因为它们是用 Java 编写的。 服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。 Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。 Servlet - 容器:Servlet容器是web server或application server的一部分，提供基于请求/响应发送模型的网络服务，解码基于MIME的请求，并且格式化基于MIME的响应。Servlet 容器也包含了管理Servlet生命周期。 Servlet容器可以嵌入到宿主的web server中，或者通过Web Server的本地扩展API单独作为附加组件安装。Servelt容器也可能内嵌或安装到包含web功能的application server中。 所有Servlet容器必须支持基于HTTP协议的请求/响应模型，比如像基于HTTPS（HTTP over SSL）协议的请求/应答模型可以选择性的支持。容器必须实现的HTTP协议版本包含HTTP/1.0 和 HTTP/1.1。因为容器或许支持RFC2616 (HTTP/1.1)描述的缓存机制，缓存机制可能在将客户端请求交给Servlet处理之前修改它们，也可能在将Servlet生成的响应发送给客户端之前修改它们，或者可能根据RFC2616规范直接对请求作出响应而不交给Servlet进行处理。 Servlet容器应该使Servlet执行在一个安全限制的环境中。在Java平台标准版（J2SE, v.1.3 或更高） 或者 Java平台企业版(Java EE, v.1.3 或更高) 的环境下，这些限制应该被放置在Java平台定义的安全许可架构中。比如，高端的application server为了保证容器的其他组件不受到负面影响可能会限制Thread对象的创建。 Java SE 6是构建Servlet容器最低的Java平台版本。 事件序列:以下是一个典型的事件序列： 1、客户端（如 web浏览器）发送一个HTTP请求到web服务器； 2、Web服务器接收到请求并且交给servlet容器处理，servlet容器可以运行在与宿主web服务器同一个进程中，也可以是同一主机的不同进程，或者位于不同的主机的web服务器中，对请求进行处理。 3、servlet容器根据servlet配置选择相应的servlet，并使用代表请求和响应对象的参数进行调用。 4、servlet通过请求对象得到远程用户，HTTP POST参数和其他有关数据可能作为请求的一部分随请求一起发送过来。Servlet执行我们编写的任意的逻辑，然后动态产生响应内容发送回客户端。发送数据到客户端是通过响应对象完成的。 5、一旦servlet完成请求的处理，servlet容器必须确保响应正确的刷出，并且将控制权还给宿主Web服务器。 Servlet - 规范:许多供应商已经实施了servlet规范（例如：Tomcat，Jetty），尽管规范的确发展，供应商最终还是为我们部署我们的Web应用程序提供了实现。 通过JSR 340的提案，servlet 3.1规范在大版本3.0（JSR 315）上进行了迭代，允许我们的Web应用程序利用非阻塞IO和HTTP协议升级机制等功能。 在Servlet 3.0规范发布后的一大特点是不再需要一个web.xml 作为描述为我们所有的Servlet、过滤器、Listeners、init-PARAMS在 xml 文件中进行配置，大多数元数据、配置现在可以通过注释来完成。 此次使用web.xml 仅仅是为了在尝试访问安全路由时配置容器的登录过程。 web.xml: 1234567891011&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;!-- 将以任何安全路由的基本身份验证来挑战用户 --&gt; &lt;login-config&gt; &lt;auth-method&gt;BASIC&lt;/auth-method&gt; &lt;realm-name&gt;servletbasics&lt;/realm-name&gt; &lt;/login-config&gt;&lt;/web-app&gt; Servlet - 生命周期：Servlet是按照一个严格定义的生命周期被管理，该生命周期规定了Servlet如何被加载、实例化、初始化、处理客户端请求，以及何时结束服务。该声明周期可以通过javax.servlet.Servlet接口中的init、service和destroy这些API来表示，所有Servlet必须直接或间接的实现GenericServlet或HttpServlet抽象类。 以下是典型servlet的生命周期。 init 实例化: 用户访问这个Servlet，由容器实例化，它的init()方法被调用一次。通常，Servlet被实例化一次，并且在使用中产生大量并发，尽管容器可以汇集实现SingleThreadModel的多个servlet来处理重负载。 调用Service服务:Servi为每个请求调用Servlets的service()方法，如果您的servlet实现了HttpServlet接口，那么该请求将被委派给与您给定的请求动词匹配的任何便利方法。 销毁 Servlet:destroy()方法被调用，允许我们钩入生命周期，并终止servlet使用的任何资源。 垃圾收集:垃圾收集器收集servlet。 Servlet - 过滤器:Servlet的过滤器旨在拦截对servlet，jsp或甚至静态HTML文件的请求。他们还将响应拦截回客户端，因此可用于修改请求/响应，有时甚至根据特定条件阻止或重定向它们。 其中包括： 身份验证：拦截请求以防止未经身份验证的用户 压缩：将响应压缩回客户端 更改请求/响应体的交换格式 跟踪请求/响应 Servlet - 监听器:servlet规范允许我们定义WebListener，它可以对Web应用程序中发生的某些事件做出反应。事件可以在会话，请求，应用程序级别，不同类型的WebListener被设计为对不同的事件做出反应。 对于不同的场景，存在以下WebListeners： Scope WebListener 接口 Event Web context ServletContextListenerServletContextAttributeListener ServletContextEventServletContextAttributeEvent Session HttpSessionListenerHttpSessionActivationListenerHttpSessionAttributeListener HttpSessionEventHttpSessionEventHttpSessionBindingEvent Request ServletRequestListenerServletRequestAttributeListener ServletRequestEventServletRequestAttributeEvent Servlet - Context：Servlet - 注解：在web应用中，使用注解的类仅当它们位于WEB-INF/classes目录中，或它们被打包到位于应用的WEB-INF/lib中的jar文件中时它们的注解才将被处理。 Web应用部署描述符的web-app元素包含一个新的“metadata-complete”属性。“metadata-complete”属性定义了web描述符是否是完整的，或是否应该在部署时检查jar包中的类文件和web fragments。如果“metadata-complete”设置为“true”，部署工具必须必须忽略存在于应用的类文件中的所有指定部署信息的servlet注解和web fragments。如果metadata-complete属性没有指定或设置为“false”，部署工具必须检查应用的类文件的注解，并扫描web fragments。 以下注解必须被Servlet 3.0兼容的容器支持。 @WebServlet:该注解用于在Web应用中定义Servlet组件。该注解在一个类上指定并包含声明Servlet的元数据。必须指定注解的urlPatterns或value属性。所有其他属性是可选的默认设置。@WebServlet注解的类必须继承javax.servlet.http.HttpServlet类。 使用示例: 1234@WebServlet(”/foo”)public class CalculatorServlet extends HttpServlet&#123;//...&#125; @WebFilter:该注解用于在Web应用中定义Filter。该注解在一个类上指定且包含声明过滤器的元数据。如果没有指定Filter名字则默认是全限定类名。注解的urlPatterns属性, servletNames 属性 或 value 属性必须被指定。所有其他属性是可选的默认设置。@WebFilter注解的类必须实现javax.servlet.Filter。 使用示例： 123456@WebFilter(“/foo”)public class MyFilter implements Filter &#123;public void doFilter(HttpServletRequest req, HttpServletResponse res) &#123;...&#125;&#125; @WebInitPara:该注解用于指定必须传递到Servlet或Filter的任何初始化参数。它是WebServlet和WebFilter注解的一个属性。 @WebListener:WebListener注解用于注解用来获得特定web应用上下文中的各种操作事件的监听器。@WebListener注解的类必须实现以下接口： javax.servlet.ServletContextListener javax.servlet.ServletContextAttributeListener javax.servlet.ServletRequestListener javax.servlet.ServletRequestAttributeListener javax.servlet.http.HttpSessionListener javax.servlet.http.HttpSessionAttributeListener javax.servlet.http.HttpSessionIdListener 使用示例： 12345678@WebListenerpublic class MyListener implements ServletContextListener&#123; public void contextInitialized(ServletContextEvent sce) &#123; ServletContext sc = sce.getServletContext(); sc.addServlet("myServlet", "Sample servlet", "foo.bar.MyServlet", null, -1); sc.addServletMapping("myServlet", new String[] &#123; "/urlpattern/*" &#125;); &#125;&#125; @MultipartConfig:该注解，当指定在Servlet上时，表示请求期望是mime/multipart类型。相应servlet的HttpServletRequest对象必须使用getParts和getPart方法遍历各个mime附件以获取mime附件。javax.servlet.annotation.MultipartConfig的location属性和的元素被解析为一个绝对路径且默认为javax.servlet.context.tempdir。如果指定了相对地址，它将是相对于tempdir位置。绝对路径与相对地址的测试必须使用java.io.File.isAbsolute。 Servlet - 异步操作:异步处理在重负载或在客户端和服务器之间以不同速度读取和写入大量数据的情况下特别有用，意味着两个实体之一可能会等待来自另一个的输入。 在servlet 3.0规范中，引入了servlet内部的异步处理，允许长时间运行的任务在一个单独的线程中完成，以允许请求线程返回到从它处理其他请求的池中。 通过servlet 3.1规范，我们得到了能够以异步方式在客户端和服务器之间读写数据的功能，从而允许以非阻塞方式异步处理客户端和服务器之间的长时间读写操作，特别适用于大型读取和写入时可能阻止的数据流以不同的速度完成。这些功能通过ReadListener和WriteListener接口来实现。 作为servlet 3.1规范的一部分，我们为servlet和过滤器提供异步处理支持。 参考资料：JCP(Java Servlet 3.1规范):https://jcp.org/en/jsr/detail?id=340]]></content>
      <categories>
        <category>Ent Java</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『管理工具-NPM』相关内容整理]]></title>
    <url>%2F2017%2F05%2F09%2Fnpm-note%2F</url>
    <content type="text"><![CDATA[NPM是什么？ npm（全称 Node Package Manager，即node包管理器）是Node.js默认的、以JavaScript编写的软件包管理系统。 NPM的使用场景: 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用 NPM-工作原理： npm依赖解析的主要思想：尽可能地减少间接依赖安装目录的深度，最理想的情况是与直接依赖安装在同一目录下，通过这种方式来减少依赖目录的嵌套，缓解整个依赖目录层次过深的问题。（因为 Windows 中文件路径的长度不能大于 260 个字符。） 参考资料：NPM基本用法和使用技巧 NPM-基础操作：NPM是随同Node.js一起安装的包管理工具，所以我们只需要安装nodejs就可以同时安装成功NPM。 安装Node.js并更新npmWin系统：进入Node.js 官方网站，找到 Downloads 栏目，选择适合自己系统的安装包进行安装。 MacOS系统：在MacOS系统上建议先安装Homebrew，然后使用homebrew来安装NPM。 12brew search nodejs #搜索brew install nodejs #安装 CentOS系统：在CentOS系统上，我们可以使用yum命令来安装Node.js,前提是需要配置好yum源。 1yum -y install nodejs Ubuntu系统：在 Ubuntu系统上，我们可以使用apt-get方式来安装Node.js。 1apt-get install nodejs 安装完成并且配置好相关环境之后，我们可以再Terminal中输入node -v 和npm -v分别来测试nodejs和npm是否安装成功。 npm常用参数： -g, –global：安装全局依赖，如果没有指定依赖包名，则将当前目录中的包安装至全局 -S, –save：安装依赖的同时将该依赖写入 dependencies -D, –save-dev：安装依赖的同时将该依赖写入 devDependencies -O, –save-optional：安装依赖的同时将该依赖写入 optionalDependencies -E, –save-exact：写入 package.json 时带有确切版本号 –no-optional：不安装 optional dependencies，可继承 –only={dev[elopment]|prod[uction]}：无视 NODE_ENV，只安装 devDependencies 或仅安装除了 devDependencies 之外的依赖项 –dry-run：走一遍安装的过程并报告结果，但实际上没有安装任何依赖 在本地安装npm软件包有两种方法来安装NPM包：本地或全局，你选择哪一种安装使用基于你想如何使用包。 如果你想使用类似的Node.js依赖于包从自己的模块 require，然后要在本地安装，这是npm install的默认行为。在另一方面，如果你想使用它作为一个命令行工具，像繁重的CLI的东西，那么你要在全局安装它。 npm install命令的使用可在下文npm-cli部分查看。 init初始化项目：12npm init #在项目根目录下使用它会创建一个package.json文件,需要填写一些内容，详见下文npm init -y # 在package.json文件中全部使用默认选项 使用 package.json管理本地安装的npm软件包的最佳方法是创建一个package.json文件。 一个package.json文件为你提供了很多方便： - 它作为您的项目所依赖的包的文档。 - 它允许您使用语义版本控制规则来指定项目可以使用的包的版本。 - 使您的构建可重复，这意味着它的方式更容易与其他开发人员共享。 package.json语法： “name” 全部小写 一个字，没有空格 破折号和下划线允许 “version” 的形式 x.x.x 遵循semver spec命名规范 demo: 1234&#123; &quot;name&quot;: &quot;my-awesome-package&quot;, &quot;version&quot;: &quot;1.0.0&quot;&#125; 其他字段释义： 字段名称 说明 name 当前项目名称 version 项目版本信息，默认为1.0.0 description 来自readme的信息，否则为空字符串 “” main 默认为index.js scripts 默认情况下会创建一个空test脚本 keywords 关键词信息，默认空 author 作者信息，默认空 license 软件许可证 ISC bugs 来自当前项目的信息（如果存在） homepage 来自当前项目的信息（如果存在） dependencies 您的应用程序在生产中需要这些软件包 devDependencies 这些软件包仅用于开发和测试 安装npm软件包安装本地(local)软件包:1npm install &lt;packageName&gt; # 需要在当前项目项目根目录下，与package.json 文件在同一目录下 安装全局(global)软件包:1npm install -g &lt;packageName&gt; 在全局安装时出现Permission denied错误时，请在npm指令前加上 sudo(类UNIX系统下) 查看npm软件包查看本地(local)软件包:1npm list # 与package.json 在同一目录下运行 查看全局(global)软件包:1npm list -g # Terminal中运行 更新npm软件包1npm list -g # 查看系统中全局安装过的软件包 应该经常更新您依赖的软件包，以便您可以获得对上游代码进行的任何更改。 更新本地(local)软件包:1npm update &lt;packageName&gt; #对单个包升级 更新全局(global)软件包：npm -g是管理本地全局包的命令。 1234567891011121314➜ ~ npm -g outdated # 使用此命令可以查看那些包有更新：Package Current Wanted Latest Locationcordova 6.5.0 7.0.1 7.0.1create-react-app 1.3.0 1.3.3 1.3.3elf-cli 1.4.0 1.7.0 1.7.0express 4.15.2 4.15.3 4.15.3ionic 2.2.2 3.5.0 3.5.0node-gyp 3.6.0 3.6.2 3.6.2node-inspector 1.0.0 1.1.1 1.1.1npm 4.4.1 5.3.0 5.3.0wechat-api 1.32.0 1.33.0 1.33.0npm update -g &lt;packageName&gt; # 更新全局的软件包 参考:npm升级所有可更新包 卸载npm软件包卸载本地(local)软件包1npm uninstall &lt;packageName&gt; 删除本地模块时你应该思考的问题：是否将在package.json上的相应依赖信息也消除？ npm uninstall 模块: 删除模块，但不删除模块留在package.json中的对应信息 npm uninstall --save 模块: 删除模块，同时删除模块留在package.json中dependencies下的对应信息 npm uninstall --save-dev 模块: 删除模块，同时删除模块留在package.json中devDependencies下的对应信息 卸载全局(global)软件包1npm uninstall -g &lt;packageName&gt; 发布npm包你可以推送任何包含 package.json 文件的文件夹，比如一个 node module ####注册账号 要发布软件包，你必要有一个 npm 账号，如果没有可以使用 npm adduser 创建一个。然后使用 npm login 登录。 参考: 手把手教你用npm发布一个包 如何发布Node模块到NPM社区 Publishing npm packages npm的语义版本控制语义版本控制是许多项目用于传达此版本中的哪些更改的标准。沟通发布中的哪些更改很重要，因为有时这些更改将会破坏依赖于该包的代码。 semver:语义化版本标准Link 作为发布者：如果一个项目将与其他人共享，那么应该从1.0.0项目开始，尽管有些项目在npm不符合这个规则。之后，变更应处理如下： 错误修正和其他微小变化：修补程序释放，增加最后一个数字，例如1.0.1 不破坏现有功能的新功能：轻微释放，增加中间数字，例如1.1.0 破坏向后兼容性的更改：主要版本，增加第一个数字，例如2.0.0 作为使用者：作为开发者，可以指定应用程序在package.json文件中可以接受哪些类型的更新。 如果您从1.0.4开始，那么您将如何指定范围： 补丁版本：1.0或1.0.x或~1.0.4 次要版本：1或1.x或^1.0.4 主要版本：*或x NPM-私有模块：你可以使用 NPM 命令行工具来管理你在 NPM 仓库的私有模块代码，这使得在项目中使用公共模块变的更加方便。 准备工作你需要一个 2.7.0 以上版本的 npm ，并且需要有一个可以登陆 npm 仓库的账号。 12npm install -g npmnpm login 软件包配置所有的私有模块都是 scoped package 的。 scope 是 npm 的新特性。如果一个模块的名字以 “@” 开始，那么他就是一个scoped package。scope 就是”@”与”/“之间的部分。 1@scope/project-name 当你注册私有模块到一个用户下时，你的 scope 就是当前用户的用户名。 1@username/project-name 如果要使用npm init 初始化一个软件包，你可以通过自定义 --scope 选项设置你的 scope 1npm init --scope=&lt;your_scope&gt; 如果你在大多数时候使用的 scope 都是相同的，可以设置一个默认的 scope ，这样在我们初始化的时候会自动使用该 scope。 1npm config set scope &lt;your_scope&gt; 发布模块1npm publish 默认情况下，scoped package 会发布为私有模块，发布为私有模块是需要付费的，费用是每个月 $7。 一旦完成发布，你将会在npm库站点上看到你的 scoped package，有 private 标志，说明是非公共的模块，他人无法使用。 私有仓库授权访问如果你要授权给其他人使用你的模块，你可以在 package 的权限设置页面设置哪些用户可以拥有 只读或读写、权限。也可以通过命令行进行相关设置 1npm owner add &lt;user&gt; &lt;package name&gt; 安装私有模块如果要安装私有模块，你必须要有权限访问到要安装的私有模块。安装的时候可以使用 scope package name 1npm install @scope/project-name 当你在项目中使用这些代码模块时可以如下使用 1var project = require(&apos;@scope/project-name&apos;) 参考资料： NPM私有模块 创建一个私有的npm库 NPM-CLI命令： 命令 释义 npm install 安装模块 npm uninstall 卸载模块 npm update 更新模块 npm outdated 检查模块是否已经过时 npm ls 查看安装的模块 npm init 在项目中引导创建一个package.json文件 npm help 查看某条命令的详细帮助 npm root 查看包的安装路径 npm config 管理npm的配置路径 npm cache 管理模块的缓存 npm start 启动模块 npm stop 停止模块 npm restart 重新启动模块 npm test 测试模块 npm version 查看模块版本 npm view 查看模块的注册信息 npm adduser 用户登录 npm publish 发布模块 npm access 在发布的包上设置访问级别 npm package.json 的语法 参考资料： NPM官网 CLI Commands NPM-常用配置：常用配置项: cache：npm 本地缓存目录，默认 ~/.npm cache-max：保持缓存项目且不向 registry 检查的最长时间，单位秒，默认 Infinity，缓存中的数据不会自动删除除非执行 npm cache clean 命令 cache-min：保持缓存项目且不向 registry 检查的最短时间，单位秒，默认 10，可以置为 999999 等以尽量延长缓存生效时间 depth：npm ls 等命令中的默认深度，默认 Infinity editor：npm 默认使用的编辑器 engine-strict：如果置为 true，npm 将会拒绝安装不符合当前 Node.js 版本的模块 force：强力执行一些命令 生命周期脚本执行失败不再阻塞安装过程 发布会覆盖已经发布的版本 访问 registry 时会跳过缓存 global：全局模式 globalconfig：全局配置文件的路径 global-style：以安装全局依赖的方式安装局部依赖，只有直接依赖会被放在顶层依赖目录中 https-proxy：代理 if-present：如果置为 true，npm run-script 就不会在脚本找不到时报错 ignore-scripts：如果置为 true，npm 就不会运行 package.json 定义的脚本 init-module：指定 npm init 命令运行的模块 init-author-name：npm init 使用的默认作者名 init-author-email：npm init 使用的默认作者邮箱 init-author-url：npm init 使用的默认作者 URL init-license：npm init 使用的默认许可证 init-version：npm init 使用的默认版本号 json：npm ls 等命令输出 JSON 格式的数据 link：如果置为 true，如果全局依赖中有合适的包，安装局部依赖时将会直接链接到这个全局依赖的包；如果全局依赖中没有该包的任何版本，则全局安装这个包，并链接到局部依赖中；其他情况则在局部依赖中安装该包 long：npm ls 和 npm search 显示额外信息 message：npm version 写在 git 提交中的信息，%s 将被替换为版本号 npat：安装时运行测试 onload-script：指定一个在 npm 加载时 require() 的包，编程使用 npm 时可能会有用 only：与命令中的 --only 效果类似 optional：如果置为 false，则不安装 optionalDependencies 中的依赖 prefix：指定安装全局依赖的路径 production：如果置为 true，则开启生产模式，npm install 将不安装开发依赖，声明周期脚本运行时自动设置 NODE_ENV=&quot;production&quot; registry：指定 npm registry 的 URL rollback：移除安装失败的模块 save：与命令中的 --save 效果类似 scope：与命令中的 --scope 效果类似 shrinkwrap：如果置为 false，安装时忽略 npm-shrinkwrap.json progress：如果置为 false，不显示进度条 loglevel：设置输出日志的 level，置为 silly 可以显示全部日志 npmrc:配置文件有： 项目配置文件（/path/to/my/project/.npmrc） 用户配置文件（~/.npmrc） 全局配置文件（/path/to/node/etc/npmrc） 内置配置文件（/path/to/npm/npmrc） scripts:npm 支持的生命周期脚本有： prepublish: 发布模块之前执行，也在不带任何参数的局部 npm install 之前执行 publish、postpublish: 发布模块之后执行 preinstall: 安装该模块之前执行 install、postinstall: 安装该模块之后执行 preuninstall、uninstall: 移除该模块之前执行 postuninstall: 移除该模块之后执行 preversion、version: 修改模块版本号之前执行 postversion: 修改模块版本号之后执行 pretest、test、posttest: 在 test 命令的前后执行 prestop、stop、poststop: 在 stop 命令的前后执行 prestart、start、poststart: 在 start 命令的前后执行. prerestart、restart、postrestart: 在 restart 命令的前后执行，如果 restart 脚本没有提供，restart 命令将会执行 stop 脚本再执行 start 脚本 对于自定义名称的脚本，可以通过 npm run-script &lt;pkg&gt; &lt;stage&gt; 来执行，匹配名称的 pre 和 post 命令同样也会执行。 NPM-参考资料： 维基百科 NPM官网 淘宝镜像 NPM手册 NPM命令详解 NPM升级更新包 NPM基本用法和使用技巧 NPM脚本命令学习笔记]]></content>
      <categories>
        <category>Build Tools</category>
      </categories>
      <tags>
        <tag>NPM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『构建工具-Gulp』相关内容整理]]></title>
    <url>%2F2017%2F04%2F26%2Fgulp-note%2F</url>
    <content type="text"><![CDATA[Gulp- 简介 Automate and enhance your workflow | 用自动化构建工具增强你的工作流程 Gulp 是什么？gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用它，不仅可以很愉快的编写代码，而且大大提高我们的工作效率。 gulp是基于Nodejs的自动任务运行器，它能自动化地完成 javascript、coffee、sass、less、html/image、css 等文件的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。通过本文，我们将学习如何使用Gulp来改变开发流程，从而使开发更加快速高效。 gulp 和 grunt 非常类似，但相比于 grunt 的频繁 IO 操作，gulp 的流操作，能更快地更便捷地完成构建工作。 Gulp的核心概念？流，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向。流不但可以处理文件，还可以处理动态内存、网络数据等多种数据形式。 而gulp正是通过流和代码优于配置的策略来尽量简化任务编写的工作。这看起来有点“像jQuery”的方法，把动作串起来创建构建任务。早在Unix的初期，流就已经存在了。流在Node.js生态系统中也扮演了重要的角色，类似于*nix将几乎所有设备抽象为文件一样，Node将几乎所有IO操作都抽象成了stream的操作。因此用gulp编写任务也可看作是用Node.js编写任务。当使用流时，gulp去除了中间文件，只将最后的输出写入磁盘，整个过程因此变得更快。 Gulp的特点? 易于使用: 通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理。 构建快速:利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。 易于学习:通过最少的 API，掌握 gulp 毫不费力，构建工作尽在掌握：如同一系列流管道。 插件高质:gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。 Gulp- 环境搭建gulp 是基于 node 实现的，那么我们就需要先安装 node。 Node是一个基于Google V8 JavaScript引擎建立的一个平台，可以利用它实现Web服务，做类似PHP的事。 12345npm install -g gulp # 全局安装gulp gulp -v # 查看gulp是否安装成功➜ ~ gulp -v [20:17:32] CLI version 3.9.1 Gulp- 构建项目使用Gulp来构建项目:1234567891011121314151617mkdir Gulp &amp;&amp; cd Gulp &amp;&amp; npm init -y &amp;&amp; npm install gulp --save-dev#使用npm初始化项目并且安装Gulp模块,能够看到如下的package.json文件中已经包含了Gulp的相关信息。&#123; &quot;name&quot;: &quot;Gulp&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;gulp&quot;: &quot;^3.9.1&quot; &#125;&#125; gulpfile.js文件的使用： gulp也需要一个文件作为它的主文件，在gulp中这个文件叫做gulpfile.js。 创建gulpfile.js文件，与package.json文件一样放在项目根目录中，之后需要做的就是在gulpfile.js文件中定义任务了。 在gulpfile.js文件中写入以下内容： 1234var gulp = require(&apos;gulp&apos;);gulp.task(&apos;default&apos;, function() &#123; console.log(&quot;Gulp OK!&quot;);&#125;); 完成之后在Terminal中运行gulp命令，然后会看到刚才在task任务中要输出的内容.12345➜ gulp[00:35:29] Using gulpfile ~/WebStrom-Work/Gulp/gulpfile.js[00:35:29] Starting &apos;default&apos;...Gulp OK![00:35:29] Finished &apos;default&apos; after 141 μs Gulp- APIgulp.src()语法：1gulp.src(globs[, options]) 输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中。 名称 类型 含义 globs String 或 Array 所要读取的 glob 或者包含 globs 的数组。 options Object 通过 glob-stream 所传递给 node-glob 的参数。 gulp.dest()语法：1gulp.dest(path[, options]) 能被 pipe 进来，并且将会写文件。并且重新输出（emits）所有数据，因此你可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。 path 类型： String or Function ,文件将被写入的路径（输出目录）。也可以传入一个函数，在函数中返回相应路径，这个函数也可以由 vinyl 文件实例 来提供。 options类型： Object , 为一个可选的参数对象，通常我们不需要用到 gulp.task()语法：1gulp.task(name[, deps], fn) name 类型： String，任务的名字，如果你需要在命令行中运行你的某些任务，那么，请不要在名字中使用空格。 deps 类型： Array，一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。 demo 123gulp.task(&apos;mytask&apos;, [&apos;array&apos;, &apos;of&apos;, &apos;task&apos;, &apos;names&apos;], function() &#123; // 做一些事&#125;); 注意： 你的任务是否在这些前置依赖的任务完成之前运行了？请一定要确保你所依赖的任务列表中的任务都使用了正确的异步执行方式：使用一个 callback，或者返回一个 promise 或 stream。 fn该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：gulp.src().pipe(someplugin())。 gulp.watch()语法：1gulp.watch(glob[, opts], tasks) gulp.watch()用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务。 glob类型： String or Array ,一个 glob 字符串，或者一个包含多个 glob 字符串的数组，用来指定具体监控哪些文件的变动。 opts 类型： Object 传给 gaze 的参数。 cb(event) 类型： Function ,每次变动需要执行的 callback。 参考：Gulp-API Gulp- 常用插件压缩JS -&gt; gulp-uglify:安装 gulp-uglify:1npm install gulp-uglify --save-dev 示例代码：12345678var gulp = require(&apos;gulp&apos;);var uglify = require(&apos;gulp-uglify&apos;);gulp.task(&apos;javascript&apos;,function () &#123; // javascript: 任务名称 gulp.src(&apos;./src/js/*.js&apos;) // src: 定位到需要压缩的js文件目录下 .pipe(uglify()) // 执行压缩文件 .pipe(gulp.dest(&apos;./dist/js&apos;)); // 输出到指定目录&#125;); API参考：gulp-uglify 压缩CSS -&gt; gulp-minify-css:安装 gulp-minify-css：1npm install gulp-minify-css --save-dev 示例代码：12345678var gulp = require(&apos;gulp&apos;);var minify = require(&apos;gulp-minify-css&apos;)gulp.task(&apos;css&apos;,function () &#123; gulp.src(&apos;./src/css/*.css&apos;) .pipe(minify()) .pipe(gulp.dest(&apos;./dist/css&apos;));&#125;); API参考：gulp-minify-css 压缩图片 -&gt; gulp-imagemin：安装 gulp-imagemin：1npm install gulp-imagemin --save-dev 示例代码：12345678var gulp = require(&apos;gulp&apos;);var image = require(&apos;gulp-imagemin&apos;);gulp.task(&apos;image&apos;,function () &#123; gulp.src(&apos;./src/images/*.*&apos;) .pipe(imagemin()) .pipe(gulp.dest(&apos;./dist/images&apos;));&#125;); API参考：gulp-imagemin 编译Less-&gt; gulp-less:安装 gulp-less：1npm install gulp-less --save-dev 示例代码：12345678var gulp = require(&apos;gulp&apos;);var less = require(&apos;gulp-less&apos;);gulp.task(&apos;less&apos;,function () &#123; gulp.src(&apos;./src/less/*.*&apos;) .pipe(less()) .pipe(gulp.dest(&apos;./dist/less&apos;));&#125;); API参考：gulp-less 自动刷新-&gt; gulp-livereload：安装gulp-livereload：1npm install gulp-livereload --save-dev 示例代码：1在每个gulp.task()方法中的gulp.src()方法后追加 .pipe(livereload()); 即可。 需要配合谷歌浏览器插件 LiveReload插件来使用，实现自动刷新。 API参考：gulp-livereload Google Chrome Plugin：LiveReload 完整gulpfile.js文件：123456789101112131415161718192021222324252627282930313233343536var gulp = require(&apos;gulp&apos;); // Gulpvar uglify = require(&apos;gulp-uglify&apos;); // JavaScriptvar minify = require(&apos;gulp-minify-css&apos;); // CSSvar imagemin = require(&apos;gulp-imagemin&apos;); // Imagesvar less = require(&apos;gulp-less&apos;); // Lessvar livereload = require(&apos;gulp-livereload&apos;) // LiveReload// 执行所有任务gulp.task(&apos;default&apos;, [&apos;javascript&apos;,&apos;css&apos;,&apos;less&apos;,&apos;image&apos;]);gulp.task(&apos;javascript&apos;,function () &#123; // jsscript: 任务名称 gulp.src(&apos;./src/js/*.js&apos;) // src: 定位到需要压缩的js文件目录下 .pipe(uglify()) // 执行压缩文件 .pipe(gulp.dest(&apos;./dist/js&apos;)); // 输出到指定目录&#125;);gulp.task(&apos;css&apos;,function () &#123; gulp.src(&apos;./src/css/*.css&apos;) .pipe(minify()) .pipe(gulp.dest(&apos;./dist/css&apos;));&#125;);gulp.task(&apos;less&apos;,function () &#123; gulp.src(&apos;./src/less/*.*&apos;) .pipe(less()) .pipe(gulp.dest(&apos;./dist/css&apos;));&#125;);gulp.task(&apos;image&apos;,function () &#123; gulp.src(&apos;./src/images/*.*&apos;) .pipe(imagemin()) .pipe(gulp.dest(&apos;./dist/images&apos;));&#125;); Gulp- 参考资料 Gulp官网 Gulp中文网 一点CSS-Gulp npmjs Gulp-插件 Gulp常用插件介绍 Gulp使用介绍和技巧 Thenewboston-视频教程 常见web项目目录：在当前项目的根目录下执行tree命令，即可看到项目的整个目录结构，如果没有tree命令，在Mac系统下可以使用brew进行安装： 123456789101112131415161718192021222324➜ Glup tree ../Glup../Glup├── build # 项目构建脚本├── src # 源码目录│ ├── css # CSS文件│ ├── fonts # 字体文件│ ├── images # 图片文件│ ├── js # js脚本文件│ ├── less # less文件│ └── sass # sass文件├── dist # 编译出来的发布版本目录│ ├── css │ ├── fonts│ ├── images│ └── js ├── docs # 文档├── test # 测试脚本├── gulpfile.js # Gulp工具构建项目的主文件├── node_modules # npm包存放目录├── package-lock.json #npm5.0以上项目依赖文件├── package.json # npm包管理配置文件├── LICENSE # 授权协议└── README.md # 项目说明文件]]></content>
      <categories>
        <category>Build Tools</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
</search>
