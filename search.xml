<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[『NoSQL - MongoDB』CRUD]]></title>
    <url>%2F2017%2F10%2F23%2Fmongodb-crud%2F</url>
    <content type="text"><![CDATA[前言本文从讲解了 MongoDB 的数据导入导出，以及 CRUD 操作。 数据下载: JSON示例数据:(美国马萨诸塞州邮政代码-&gt;点击下载)。 12345678910&#123; "_id" : "01001", #序号 "city" : "AGAWAM", #城市 "loc" : [ #坐标 -72.622739, 42.070206 ], "pop" : 15338, #标记 "state" : "MA" #州缩写&#125; 其他 JSON 数据下载:http://jsonstudio.com/resources/ MongoDB - 导入数据:简介:mongoimport工具从由其他第三方导出工具创建或可能的[扩展JSON]，CSV或TSV导出导入内容`mongoexport。 mongoimport从系统命令行运行，而不是MongoShell。 操作：json 导入：示例代码： 1mongoimport --db jsonar --collection zips --file /Users/Desktop/zips.json –db：数据库名称 –collection：集合名称 –file：文件路径 csv导入：示例代码： 1mongoimport --db users --collection contacts --type csv --headerline --file /opt/backups/contacts.csv —type: 文件类型 ###注意事项: mongoimport支持UTF-8编码的数据文件。使用其他编码会产生错误。 Reference：https://docs.mongodb.com/manual/reference/program/mongoimport/index.html MongoDB - 插入文档:在向 MongoDB 数据库中执行插入操作的时候，如果集合(collection)不存在，插入操作会自动创建一个集合(当然，MongoDB 也提供了db.createCollection(&quot;emp&quot;);方法来创建集合)，存储于集合中的每一个文档都需要一个唯一的_id字段作为 primary_key。如果一个插入文档操作遗漏了_id 字段，MongoDB驱动会自动为_id字段生成一个 [ObjectId]，这种情况同样适用于带有参数的 [upsert: true]的 update 操作。 MongoDB主要提供了以下三个方法向集合插入文档: db.collection.insertOne() db.collection.insertMany() db.collection.insert() insertOne:db.collection.insertOne()将单个文档插入到集合中。 示例代码： 123db.inventory.insertOne(... &#123; item: "canvas", qty: 100, tags: ["cotton"], size: &#123; h: 28, w: 35.5, uom: "cm" &#125; &#125;... ) 运行结果: 1234&#123; "acknowledged" : true, "insertedId" : ObjectId("59eee499cbb5fc46080e6d87")&#125; insertOne() 返回一个结果文档，该结果文档中列举了插入文档的_id 字段值为ObjectId(&quot;59eee499cbb5fc46080e6d87&quot;)。 insertMany:db.collection.insertMany()可以将多个文档插入到集合中。 示例代码： 12345db.inventory.insertMany([... &#123; item: "journal", qty: 25, tags: ["blank", "red"], size: &#123; h: 14, w: 21, uom: "cm" &#125; &#125;,... &#123; item: "mat", qty: 85, tags: ["gray"], size: &#123; h: 27.9, w: 35.5, uom: "cm" &#125; &#125;,... &#123; item: "mousepad", qty: 25, tags: ["gel", "blue"], size: &#123; h: 19, w: 22.85, uom: "cm" &#125; &#125;... ]) 运行结果: 12345678&#123; "acknowledged" : true, "insertedIds" : [ ObjectId("59eeeb7dcbb5fc46080e6d89"), ObjectId("59eeeb7dcbb5fc46080e6d8a"), ObjectId("59eeeb7dcbb5fc46080e6d8b") ]&#125; insertMany() 返回包含新插入的文档_id字段值的文档。 insert:db.collection.insert() 将单个文档或多个文档插入到集合中。 插入单个文档:示例代码: 1db.products.insert( &#123; item: "card", qty: 15 &#125; ) 运行结果: 1WriteResult(&#123; "nInserted" : 1 &#125;) 插入多个文档：示例代码： 1234567db.products.insert( [ &#123; _id: 11, item: "pencil", qty: 50, type: "no.2" &#125;, &#123; item: "pen", qty: 20 &#125;, &#123; item: "eraser", qty: 25 &#125; ]) 运行结果： 12345678910BulkWriteResult(&#123; "writeErrors" : [ ], "writeConcernErrors" : [ ], "nInserted" : 3, "nUpserted" : 0, "nMatched" : 0, "nModified" : 0, "nRemoved" : 0, "upserted" : [ ]&#125;) MongoDB - 读取文档:MongoDB 提供了 db.collection.find() 方法从集合中读取文档。此方法返回一个游标，要访问文档，需要迭代游标。但是，在MongoShell中，如果返回的游标未使用var关键字分配给变量，那么光标自动迭代最多20次，打印到结果中的前20个文档。(可以使用 DBQuery.shellBatchSize 来改变迭代次数的默认值 20。) 要查询集合中的所有文档，需要将空文档作为查询过滤器参数传递给find方法。 基础查询:查询 zips 集合中的全部数据，示例代码: 1db.zips.find(&#123;&#125;); 运行结果： 12345&#123; "_id" : "01001", "city" : "AGAWAM", "loc" : [ -72.622739, 42.070206 ], "pop" : 15338, "state" : "MA" &#125;&#123; "_id" : "01002", "city" : "CUSHMAN", "loc" : [ -72.51565, 42.377017 ], "pop" : 36963, "state" : "MA" &#125;&#123; "_id" : "01005", "city" : "BARRE", "loc" : [ -72.108354, 42.409698 ], "pop" : 4546, "state" : "MA" &#125;&#123; "_id" : "01007", "city" : "BELCHERTOWN", "loc" : [ -72.410953, 42.275103 ], "pop" : 10579, "state" : "MA" &#125;&#123; "_id" : "01008", "city" : "BLANDFORD", "loc" : [ -72.936114, 42.182949 ], "pop" : 1240, "state" : "MA" &#125; 如果觉得返回结果太乱，可以使用.pretty()来格式化显示。 查询时也可以指定不需要显示的字段，示例代码： 1db.zips.find(&#123;&#125;,&#123;"loc":0&#125;) 运行结果: 1234567891011121314151617181920212223/* 1 */&#123; "_id" : "01001", "city" : "AGAWAM", "pop" : 15338, "state" : "MA"&#125;/* 2 */&#123; "_id" : "01002", "city" : "CUSHMAN", "pop" : 36963, "state" : "MA"&#125;/* 3 */&#123; "_id" : "01005", "city" : "BARRE", "pop" : 4546, "state" : "MA"&#125; 对于设置的显示字段严格来讲就称为数据的投影操作，如果不需要显示的字段设置“0”，而需要显示的字段设置“1”。 查询时也可以指定相等条件，语法db.集合名称.find({查询条件} [,{设置显示的字段}]。 示例代码： 1db.inventory.find( &#123; city: "SPRINGFIELD" &#125; ) 运行结果: 1234567891011121314151617181920212223242526272829303132333435/* 1 */&#123; "_id" : "01103", "city" : "SPRINGFIELD", "loc" : [ -72.588735, 42.1029 ], "pop" : 2323, "state" : "MA"&#125;/* 2 */&#123; "_id" : "01104", "city" : "SPRINGFIELD", "loc" : [ -72.577769, 42.128848 ], "pop" : 22115, "state" : "MA"&#125;/* 3 */&#123; "_id" : "01105", "city" : "SPRINGFIELD", "loc" : [ -72.578312, 42.099931 ], "pop" : 14970, "state" : "MA"&#125; 关系运算:在MongoDB里面支持的关系查询操作：大于（$gt）、小于（$lt）、大于等于（$gte）、小于等于（$lte）、不等于（$ne）、等于（key:value、$eq）。 查询pop大于20000的数据: $gt:1db.zips.find(&#123;pop:&#123;$gt:20000&#125;&#125;) $lt:查询pop小于1000的数据 : 1db.zips.find(&#123;pop:&#123;$lt:1000&#125;&#125;) $gte:查询pop 大于等于90000的数据： 1db.zips.find(&#123;pop:&#123;$gte:90000&#125;&#125;) $lte:查询 pop 小于等于10的数据： 1db.zips.find(&#123;pop:&#123;$lte:10&#125;&#125;) $ne:查询 pop 不等于100的数据: 1db.zips.find(&#123;pop:&#123;$ne:100&#125;&#125;) $eq:查询 pop 等于100的数据: 1db.zips.find(&#123;pop:&#123;$eq:100&#125;&#125;) 逻辑运算:逻辑运算主要就是三种类型：与（$and）、或（$or）、非（$not、$nor）。 $and:查询 pop为等于10000和city 存在的数据(显式$and查询): 1db.zips.find(&#123;$and:[&#123;pop:&#123;$ne:10000&#125;&#125;,&#123;city:&#123;$exists:true&#125;&#125;]&#125;) 查询pop值再10000 - 20000之间的数据(隐式$and查询)： 1db.zips.find(&#123;pop:&#123;$gte:10000,$lte:20000&#125;&#125;) $or:查询city 为SPRINGFIELD或者pop 大于10000的数据： 1db.zips.find(&#123;$or:[&#123;city:"SPRINGFIELD"&#125;,&#123;pop:&#123;$gte:10000&#125;&#125;]&#125;) $nor:查询city 不为SPRINGFIELD或者 pop 小于10000的数据(进行或的取反操作): 1db.zips.find(&#123;$nor:[&#123;city:"SPRINGFIELD"&#125;,&#123;pop:&#123;$gte:10000&#125;&#125;]&#125;) 求模运算:$mod:求模运算使用“$mod”来完成，语法“{$mod : [数字,余数]}”。 1db.zips.find(&#123;pop:&#123;$mod:[100,10]&#125;&#125;) 范围查询:“$in”（在范围之中）、“$nin”（不在范围之中） $in:查询 city 为AGAWAM、CUSHMAN、SPRINGFIELD三个值的数据: 1db.zips.find(&#123;city:&#123;$in:["AGAWAM","CUSHMAN","SPRINGFIELD"]&#125;&#125;) $nin:查询 city 中不含AGAWAM、CUSHMAN、SPRINGFIELD三个值的数据: 1db.zips.find(&#123;city:&#123;$nin:["AGAWAM","CUSHMAN","SPRINGFIELD"]&#125;&#125;) 数组查询:MongoDB中，需要针对于数组数据查询操作，可以使用几个运算符：$all、$size、$slice、$elemMatch。 ####$all: 查询loc 有42.070206的数据: 1db.zips.find(&#123;loc:&#123;$all:[42.070206]&#125;&#125;) 虽然“$all”计算可以用于数组上，但是也可以用于一个数据的匹配上。 查询loc 有-72.108354和42.409698的数据： 1db.zips.find(&#123;loc:&#123;$all:[-72.108354,42.409698]&#125;&#125;) ####$size: 查询 loc中字段数量为2的数据： 1db.zips.find(&#123;loc:&#123;$size:2&#125;&#125;) ####$slice: 查询 loc中city为SPRINGFIELD并且字段数量为2的数据： 1db.zips.find(&#123;city:"SPRINGFIELD"&#125;,&#123;loc:&#123;$slice:1&#125;&#125;) 查询 loc中city为SPRINGFIELD的数据数据跳过第一条数据返回两条数据： 1db.zips.find(&#123;city:"SPRINGFIELD"&#125;,&#123;loc:&#123;$slice:[1,2]&#125;&#125;) 下标查询:查询 loc中数组的第二个字段，值为42.070206的数据: 1db.zips.find(&#123;"loc.1":42.070206&#125;) 既然在集合里面现在保存的是数组信息，那么数组就可以利用索引操作，使用“key.index”的方式来定义索引。 条件过滤：$where:查询 pop 值小于10的数据: 1db.zips.find(&#123;$where:"this.pop &lt; 10"&#125;); 查询 pop 值小于10的数据和id大于10000的值: 1db.zips.find(&#123;"$and":[&#123;"$where":"this.pop &lt; 10"&#125;,&#123;"$where":"this._id &gt; 10000"&#125;]&#125;) 正则匹配:在 MongoDB 中，如果想模糊查询，那就要使用正则表达式来匹配，而且正则表达式使用的是语言Perl兼容的正则表达式的形式。如果要想实现正则使用，则按照如下的定义格式： ·基础语法：{key : 正则标记}； ·完整语法：{key : {“$regex” : 正则标记 , “$options” : 选项}}。 指令 释义 语法 i 忽略字母大小写 m 在每行的开始或结尾匹配具有多行值的字符串(多行查找) x 空白字符串除了被转义的或在字符类中意外的完全被忽略 需要$ regex与$ options语法 s 匹配所有的字符（圆点、“.”），包括换行内容。 需要$ regex与$ options语法 查询 state中以 K 开头的数据(^)： 1db.zips.find(&#123;state:/^K/&#125;) 查询 state中包含 k 的数据(不区分大小写)： 12db.zips.find(&#123;state:/k/i&#125;)db.zips.find(&#123;state:&#123;$regex:/K/i&#125;&#125;) 两种写法均可实现。 数据排序:MongoDB中数据的排序操作使用“sort()”函数，在进行排序的时候可以有两个顺序：升序（1）、降序（-1）。 查询 pop 数据进行升序排序： 1db.zips.find(&#123;&#125;).sort(&#123;pop:1&#125;) 查询 id 数据进行降序排序: 1db.zips.find(&#123;&#125;).sort(&#123;_id:-1&#125;) 数据分页: skip(n)：表示跨过多少数据行； limit(n)：取出的数据行的个数限制。 查询从0开始每页显示10条数据根据 id升序排序： 123db.zips.find(&#123;&#125;).skip(0).limit(10).sort(&#123;&quot;_id&quot;:1&#125;)db.zips.find(&#123;&#125;).skip(10).limit(10).sort(&#123;&quot;_id&quot;:1&#125;) 其他查询：$exists:查询 pop 的值存在且不含1000-5000之间的数据: 1db.zips.find( &#123; pop: &#123; $exists: true, $nin: [ 1000, 5000 ] &#125; &#125; ) 参考资料：查询运算符：https://docs.mongodb.com/manual/reference/operator/query/ MongoDB-CRUD：https://docs.mongodb.com/manual/crud/]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『NoSQL - MongoDB』Mongo Shell]]></title>
    <url>%2F2017%2F10%2F18%2Fmongodb-shell%2F</url>
    <content type="text"><![CDATA[前言本文从介绍了MongoShell 的配置、脚本、数据类型和其他指令。 MongoShell - 简介MongoShell是一个互动的JavaScript接口的MongoDB，可以使用MongoShell来查询和更新数据以及执行管理操作。 MongoShell是MongoDB发行版的一个组件， 安装并启动MongoDB后，将MongoShell连接到正在运行的MongoDB实例，MongoDB手册中的大多数示例使用 MongoShell，然而，许多驱动程序也提供了与MongoDB类似的接口。 启动MongoShell：在启动MongoShell之前请确保MongoDB 实例在运行，在Terminal 中键入Mongo则可以直接启动。 示例代码： 1234567891011➜ ~ mongoMongoDB shell version v3.4.3connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.3Server has startup warnings:2017-10-19T10:41:29.922+0800 I CONTROL [initandlisten]2017-10-19T10:41:29.923+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2017-10-19T10:41:29.923+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted.2017-10-19T10:41:29.923+0800 I CONTROL [initandlisten]&gt; db.version()3.4.3 选项/参数:当没有任何参数运行mongo时，mongo shell将尝试连接到端口27017上的localhost接口上运行的MongoDB实例。 链接选项:如果需要链接非27017端口或者远程实例，则可以使用以下语法来链接: 1mongo --username &lt;user&gt; --password &lt;pass&gt; --host &lt;host&gt; --port 28015 或者简写为: 1mongo -u &lt;user&gt; -p &lt;pass&gt; --host &lt;host&gt; --port 28015 .mongorc.js文件:当启动的时候，mongo检查用户HOME目录下的一个JavaScript文件.mongorc.js，如果找到mongo在首次显示提示信息前解析.mongorc.js的内容。如果你使用shell执行一个JavaScript文件或计算表达式，要么通过在命令行使用–eval选项或者指定一个.js文件给mongo，mongo会在完成JavaScript的处理后读取.mongorc.js文件。你可以使用–norc选项来阻止加载.mongorc.js。 使用MongoShell:测试数据:(这个 employee 对象是包含 3 个员工记录的数组) 1234567891011121314151617 &#123; "employees":[ &#123; "firstName":"Bill", "lastName":"Gates" &#125;, &#123; "firstName":"George", "lastName":"Bush" &#125;, &#123; "firstName":"Thomas", "lastName":"Carter" &#125; ]&#125; 显示当前正在使用的数据库： 12&gt; dbtest 查看所有数据库: 123456&gt; show dbsadmin 0.000GBlocal 0.000GB&gt; show databasesadmin 0.000GBlocal 0.000GB 使用show dbs或者show databases可以达到同样的效果。 切换到另一个数据库: 12&gt; use mydbswitched to db mydb 可以切换到一个不存在数据库，当创建集合时，这个数据库会被自动创建。 插入一条数据:12345&gt; db.emp.insertOne(&#123;x : 1&#125;);&#123; "acknowledged" : true, "insertedId" : ObjectId("59e87617052057c4236c259a")&#125; 其中 db指的是当前的数据库，emp 指的是要插入的集合的名称。 查看当前数据库中所有集合： 12&gt; show collectionsemp 查看集合中的数据: 12&gt; db.emp.find()&#123; "_id" : ObjectId("59e87617052057c4236c259a"), "x" : 1 &#125; 格式化输出结果:要格式化打印结果，可以将.pretty()添加到操作中，如下所示： 12345&gt; db.emp.find().pretty()&#123; "_id": ObjectId("59e87617052057c4236c259a"), "x": 1&#125; 此外，可以在 mongo shell中使用下面的显式打印方法： print() 无格式打印 print(tojson()) 用 JSON 格式打印，等效于 printjson() printjson() 用 JSON 格式打印，等效于 print(tojson()) shell 中的多行操作：如果你的代码行以左括号 (&#39;(&#39;)，左大括号 (&#39;{&#39;)或左中括号 (&#39;[&#39;) 结束，那么随后的一行将以省略号 (&quot;...&quot;) 开始，直到你输入对应的右括号 (&#39;)&#39;)，右大括号 (&#39;}&#39;)或右中括号 (&#39;]&#39;) 。 mongoshell在执行代码以前将一直等待右括号，右大括号或右中括号，如下例所示： 1234&gt; if ( x &gt; 0 ) &#123;... count++;... print (x);... &#125; 也可以通过按下两次回车键来结束这次输入: 1234&gt; if (x &gt; 0......&gt; 退出 shell 操作:在MongoShell中输入quit()或者按下 Ctrl+C的组合键方式来结束 shell。 MongoShell - 配置自定义提示符：可以通过在 MongoShell中设置变量 prompt 的值来修改提示符的内容。prompt 变量可以存储字符串以及JavaScript代码。 如果 prompt 为返回字符串的函数， mongo 则会在每个提示符中展示动态信息。 显示当前Shell的操作数：显示当前MongoShell 的操作数量，示例代码： 1234cmdCount = 1;prompt = function() &#123; return (cmdCount++) + "&gt; ";&#125; 配置好之后，提示符会变成这样: 1231&gt;2&gt;3&gt; 显示数据库和主机名:示例代码: 12345host = db.serverStatus().host;prompt = function() &#123; return db+"@"+host+"$ ";&#125; 提示符将会变成如下样式： 1test@HostName$ 显示Mongo服务的启动时间以及文档数:示例代码： 123prompt = function() &#123; return "Uptime:"+db.serverStatus().uptime+" Documents:"+db.stats().objects+" &gt; ";&#125; 提示符将会变成如下样式： 1Uptime:90104 Documents:0 &gt; 以上关于 prompt的相关配置均可以在 MongoShell中直接输入配置，也可以将其写入再.mongorc.js文件中。 使用外部编辑器：可以通过在启动 MongoShell之前设置 EDITOR环境变量来在MongoShell中使用自己的编辑器。 12➜ ~ export EDITOR=vim➜ ~ mongo 进入MongoShell 之后，可以输入edit 使用之前定义的 vim 编辑器来编辑代码。 示例代码： 定义函数: 1function myFunc () &#123; &#125; 使用指定的编辑器来编辑函数： 1edit myFunc 此命令可以打开 Vim 编辑会话。当编辑完成之后，保存并退出编辑会话。 调用函数: 直接在 shell 中输入函数名可以查看函数体，输入函数名() 可以调用函数。 修改批处理大小：db.collection.find()方法是从集合中检索文档的JavaScript方法。db.collection.find()方法返回一个游标到结果;然而，在mongo shell中，如果返回的游标未使用var关键字分配给变量，则光标自动迭代最多20次，以打印到与查询匹配的前20个文档。 mongo shell将提示键入它再次迭代20次。 可以设置 DBQuery.shellBatchSize 属性来修改默认的 20 篇文档数。 示例代码: 1DBQuery.shellBatchSize = 10; 改为10。 MongoShell - 脚本我们可以在操作MongoDB中的数据或执行管理操作的JavaScript中为mongo shell编写脚本。 打开新链接：在MongoShell或者 JavaScript文件中，可以使用 Mongo() 构造函数来实例化数据库连接： 123new Mongo()new Mongo(&lt;host&gt;)new Mongo(&lt;host:port&gt;) 考虑下面的示例，实例化一个到本机默认端口上运行的MongoDB实例的新连接，并且使用 getDB()方法将全局的 db 变量设置为 myDatabase: 12conn = new Mongo();db = conn.getDB(&quot;mydb&quot;); 如果连接到一个需要读取控制的MongoDB实例，你可以使用 db.auth()方法进行授权。 此外，你可以使用 connect() 方法连接到MongoDB实例。下面的示例 连接到运行在 localhost 非默认端口 27020 上的MongoDB实例，并且设置了全局的 db 变量： 1db = connect(&quot;localhost:27020/mydb&quot;); 交互式 shell 和mongo 脚本的区别: 要使用db全局变量，请使用getDB()方法或connect()方法。可以将数据库引用分配给非db以外的变量。 默认情况下，在mongo shell中的写入操作使用写入的{w：1}。如果执行批量操作，请使用Bulk()方法。 不能在JavaScript文件中使用任何shell 指令，因为它们不是有效的JavaScript,下文附对照表。 交互模式下，mongo打印包含所有游标内容的操作结果。在脚本中，可以使用JavaScript的 print()函数或返回格式化的JSON的mongo specific printjson()函数。 下表将最常见的mongo shell助手映射到JavaScript等效项: Shell 指令 JavaScript 操作方式 show dbs , show databases db.adminCommand(‘listDatabases’) use db = db.getSiblingDB(‘‘) show collections db.getCollectionNames() show users db.getUsers() show roles db.getRoles({showBuiltinRoles: true}) show log db.adminCommand({ ‘getLog’ : ‘‘ }) show logs db.adminCommand({ ‘getLog’ : ‘*’ }) it cursor = db.collection.find()if ( cursor.hasNext() ){ cursor.next();} –evel选项：使用–eval选项来将mongo传递给一个JavaScript代码片段。 123456➜ ~ mongo mydb --eval "printjson(db.getCollectionNames())" MongoDB shell version v3.4.3connecting to: mongodb://127.0.0.1:27017/mydbMongoDB server version: 3.4.3[ "emp", "stores" ] 执行 JavaScript 文件：MongoShell 可以 指定一个 .js 文件， mongo 将会直接运行JavaScript。 1mongo localhost:27017/test myjsfile.js 该操作在连接到localhost 接口 27017 端口 mongod 实例上 test database 的:program:mongo shell 中执行 myjsfile.js 脚本。 可以在MongoShell中使用 load() 函数运行 .js文件，如下所示： 1load(&quot;demo.js&quot;) 该函数导入并运行了 demo.js 文件。 load() 方法可接受相对路径和绝对路径。如果 mongo shell 当前的工作目录位于 /data/db， 而文件demo.js 位于 /data/db/scripts 目录，那么下面两种在 mongo 中的调用将会是同样的效果。 12load(&quot;scripts/myjstest.js&quot;)load(&quot;/data/db/scripts/demo.js&quot;) MongoShell - 数据类型MongoDB BSON提供了除 JSON之外其它数据类型的支持。 Drivers提供了对这些数据类型在主机语言的本地化支持，MongoShell 也提供了一些帮助类来支持这些数据类型在 mongo JavaScript shell 中的使用。 检查类型：如果想要确定字段类型，MongoShell提供了 instanceof 和 typeof 操作符。 instanceof:instanceof 返回一个布尔值来验证一个值是否为某些类型的实例。 typeof:typeof 返回一个字段的类型。 数据类型:日期类型:MongoShell 提供了多种方法返回日期，要么通过字符串要么通过 Date 对象。 Date() 方法返回当前日期为一个字符串。 new Date() 构造函数返回一个使用 ISODate() 包装返回的 Date 对象。 ISODate() 构造函数返回一个使用 ISODate() 包装返回的 Date 对象。 内部来看， ref:document-bson-type-date 对象被存储为一个表示距离 Unix 纪元（1970年1月1日）毫秒数的64位整数，这就意味着一个可表示的日期范围：从距离过去到将来的29亿年。 返回string:如果想要返回日期为一个字符串，使用 Date() 方法。 示例代码: 123451&gt; var mydate = Date(); # 创建日期类型的变量2&gt; mydate # 查看变量的值Mon Oct 23 2017 14:30:47 GMT+0800 (CST)3&gt; typeof(mydate) # 获取查看变量的类型string 返回Date:MongoShell使用ISODate帮助程序包装Date类型的对象。但是，对象仍然是Date类型。 123456789101&gt; var myDate = new Date();2&gt; var myISODate = new ISODate();3&gt; myDateISODate("2017-10-23T06:59:56.039Z")4&gt; myISODateISODate("2017-10-23T07:00:09.831Z")5&gt; myDate instanceof Date # 验证类型true6&gt; myISODate instanceof Date # 验证类型true ObjectId:MongoShell围绕ObjectId数据类型提供ObjectId()包装器类。 示例代码: 121&gt; new ObjectId(); # 生成一个 ObjectIdObjectId("59ed998b6d3acf0e7aac525c") NumberLong:默认情况下，MongoShell将所有数字视为浮点值(floating-point values)。MongoShell提供NumberLong()包装器来处理64位整数。 示例代码： 12311&gt; NumberLong("2090845886852") # NumberLong()包装器接受long作为字符串：NumberLong("2090845886852") NumberInt:NumberInt() 构造函数来显式指定 32位整数。 NumberDecimal:NumberDecimal()构造函数限制指定 128位 基于十进制的浮点值，能够以精确的精度仿效十进制近似值。 这个功能专为处理 monetary data 的应用而设计，例如金融、税务以及科学计算等。 MongoShell - 其他命令历史命令:可以使用向上和向下箭头键检索MongoShell中发出的以前的命令。命令历史存储在~/.dbshell文件中。 示例代码: 1cat ~/.dbshell 常用命令: 命令 说明 help 查看帮助 db.help() 查看数据库的操作帮助 db..help() 显示集合的操作文档(集合可以是不存在的) show dbs 显示当前服务器上所有数据库的列表 use 切换数据库到 &lt;db&gt;(数据库可以是不存在的) show collections 显示当前数据库的所有集合的列表 show users 显示当前数据库的用户列表 show roles 显示用于当前数据库的用户定义和内置的所有角色的列表。 show profile 显示最近的五个操作命令 show databases 显示所有可用数据库列表。 load() 加载执行JavaScript脚本文件 命令行启动选项:MongoShell 启动时可以使用一些选项。 选项 说明 –help 显示命令行选项 –nodb 启动MongoShell而不连接到数据库 –shell 与 js 文件一起使用 参考资料:MongoDB 中文社区: http://www.mongoing.com/docs/mongo.html MongoDB 官网文档: https://docs.mongodb.com/manual/mongo/ MongoShell引用方法: https://docs.mongodb.com/manual/reference/method/]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『NoSQL - MongoDB』Introduction & QuickStart]]></title>
    <url>%2F2017%2F10%2F17%2Fmongodb-quickstart%2F</url>
    <content type="text"><![CDATA[前言本文从MongoDB 的简介、特点、优点、趋势、等几个方面来介绍了MongoDB。 MongoDB - 简介MongoDB（来自于英文单词“Humongous”）是可以应用于各种规模的企业、各个行业以及各类应用程序的开源数据库。MongoDB是专为可扩展性，高性能和高可用性而设计的数据库。它可以从单服务器部署扩展到大型、复杂的多数据中心架构。利用内存计算的优势，MongoDB能够提供高性能的数据读写操作。 MongoDB的本地复制和自动故障转移功能使您的应用程序具有很高可靠性和操作灵活性。 MongoDB - 概念在mongodb中基本的概念是文档、集合、数据库。 SQL术语/概念 MongoDB术语/概念 解释/说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table joins 表连接,MongoDB不支持 primary key primary key 主键,MongoDB自动将_id字段设置为主键 MongoDB - 特点临时(Ad hoc)查询:MongoDB支持字段，范围查询，正则表达式搜索。查询可以返回特定的文档字段，并且还包括用户定义的JavaScript函数。查询也可以配置为返回给定大小的结果的随机抽样。 索引:MongoDB文档中的字段可以使用主索引和辅助索引进行索引。 复制:MongoDB提供高可用性与副本集。副本集由两个或多个数据副本组成。每个副本集成员可以在任何时候以主副本的角色起作用。默认情况下，所有写入和读取都在主副本上完成。辅助副本使用内置复制维护主数据的副本。当主副本失败时，副本集会自动进行选举过程，以确定哪个辅助应该成为主要副本。辅助功能可以选择性地提供读取操作，但是数据默认情况下才最终保持一致。 负载均衡:MongoDB使用分片水平缩放。用户选择一个分片键，它确定集合中的数据将如何分发。数据被分割为范围（基于分片键）并分布在多个分片上。（碎片是一个或多个奴隶的主人）。或者，碎片密钥可以被散列以映射到分片 - 实现均匀的数据分发。 MongoDB可以在多台服务器上运行，平衡负载或复制数据，以防止硬件故障时系统启动并运行。 文件存储:MongoDB可以用作具有负载平衡和数据复制功能的文件系统，通过多台机器存储文件。 此功能被称为网格文件系统，包含在MongoDB的驱动程序。MongoDB向开发人员公开了文件操作和内容的功能。GridFS用于Nginx 和lighttpd的插件。GridFS将文件划分为部分或块，并将这些块中的每一个作为单独的文档存储。 聚合:MapReduce可用于批量处理数据和聚合操作。 聚合框架使用户能够获得使用SQL。聚合框架包括可以从多个文档加入文档的$ lookup运算符，以及诸如标准偏差的统计运算符。 服务器端JavaScript执行:JavaScript可用于查询，聚合功能（如MapReduce），并直接发送到要执行的数据库。 覆盖的集合:MongoDB支持固定大小的集合，称为封顶集合。这种类型的集合维护插入顺序，一旦达到指定的大小，就像一个循环队列。 MongoDB - 优点MongoDB优于RDBMS: 模式少 MongoDB是一个文档数据库，其中一个集合持有不同的文档。文档的数量，内容和大小可能因文档而异。 单个对象的结构是清楚的。 没有复杂的连接。 深度查询能力。MongoDB支持使用几乎与SQL一样强大的基于文档的查询语言对文档进行动态查询。 MongoDB易于扩展。 将应用程序对象转换/映射到不需要的数据库对象。 使用内部存储器存储（加窗）工作集，实现数据更快的访问。 为什么要使用MongoDB？ 面向文档的存储 数据以JSON样式文档的形式存储。 任何属性的索引 复制和高可用性 自动分片 丰富的查询 快速就地更新 MongoDB的专业支持 MongoDB的应用场景？ 大数据 内容管理和交付 移动和社会基础设施 用户数据管理 数据中心 MongoDB - 趋势搜索指数：百度指数：http://index.baidu.com/?tpl=trend&amp;word=mongodb 谷歌趋势：https://trends.google.com/trends/explore?date=today%205-y&amp;q=MongoDB 分别对比了五年内的搜索结果，整体呈上升趋势，近一年内趋于平缓。 流行程度：数据来源于 DB-Engines，DB-Engines是一个收集和呈现数据库管理系统（DBMS）的网站。 DB-Engines目前市场上数据库的人气排名列表，列表每月更新一次。 MongoDB 综合排名第四位，文档类数据库排名第一位。 DB-Engines：https://db-engines.com/en/ranking DB-Engines的排名主要根据5个因素来进行：Google以及Bing搜索引擎的关键字搜索数量、Google Trends的搜索数量、Indeed网站中的职位搜索量、LinkedIn中提到关键字的个人资料数以及Stackoverflow上相关的问题和关注者数量。 MongoDB - 安装安装:MongoDB 官网提分别供了基于 Linux、OS X、Windows 系统上的安装教程。 在 OS X系统中，官方建议使用 Homebrew 来安装，步骤如下： 更新 HomeBrew： 1brew update 安装 MongoDB： 1brew install mongodb 其他安装操作： 安装具有TLS / SSL支持的MongoDB二进制文件: 1brew install mongodb --with-openssl 安装用于测试和开发的最新版本： 1brew install mongodb --devel 参考资料：http://www.mongoing.com/docs/installation.html 配置：安装完成 MoongoDB 之后，需要在当前用户的根目录下为 MongoDB 数据库添加环境变量，由于采用了 HomeBrew来安装的 MongoDB，对 Homebrew 不熟悉的人可能不清楚安装在哪里了，这时可以使用 brew info 来查看。 示例代码: (省略部分内容) 123456789101112131415# 查看 MongoDB 的安装信息➜ ~ brew info mongodbmongodb: stable 3.4.9 (bottled), devel 3.5.11==&gt; Dependencies ……==&gt; Requirements ……==&gt; Options ……--with-boost ……--with-sasl ……--without-openssl ……--devel ……==&gt; CaveatsTo have launchd start mongodb now and restart at login: brew services start mongodbOr, if you don't want/need a background service you can just run: mongod --config /usr/local/etc/mongod.conf 123456# 配置MongoDB环境变量➜ ~ vim .bash_profileexport PATH=/usr/local/Cellar/mongodb/3.4.3/bin:$&#123;PATH&#125;➜ ~ source .bash_profile MongoDB的默认数据目录为/data/db，如需要修改，可以在 MongoDB 的配置文件中修改dbPath选项。 路径如下： 1➜ ~ cat /usr/local/etc/mongod.conf MongoDB - 启动安装配置完成之后，打开 terminal，输入mongod,直至出现I NETWORK [thread1] waiting for connections on port 27017字样则算启动成功，然后再打开另一终端窗口，输入 mongo，则可以直接进入 MongoShell 界面。 学习资料 MongoDB University： MongoDB 官方课程:https://university.mongodb.com/courses/catalog Github: MongoDB 代码托管:https://github.com/mongodb/mongo TutorialsPoint: MongoDB 教程文档:http://www.tutorialspoint.com/mongodb/ 云栖社区(AliYun): 阿里云云栖社区MonbgoDB 资料汇总:http://t.cn/RO3HQgI MongoDB YouTube:MongoDB在Youtube 订阅频道:https://www.youtube.com/user/MongoDB MongoDB Tutorial for Beginners： MongoDB 初学者教程: MongoDB Tutorial for Beginners(UP主:The Net Ninja) 参考资料DB-Engines: https://db-engines.com MongoDB Manual: https://docs.mongodb.com/manual/]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『JVM语言 - Groovy』基础(六)]]></title>
    <url>%2F2017%2F10%2F11%2Fgroovy-basic-6%2F</url>
    <content type="text"><![CDATA[前言本文讲解了 Groovy 语言中的XML，JSON，DATABASE，测试套件，模板引擎。 Groovy - XMLGroovy语言还提供了对XML语言的丰富支持。使用的两个最基本的XML类是 BuilderSupport和XmlParser，前者用来构建，后者解析。 XML创建:MarkupBuilder的用于构造整个XML文档。首先通过创建XML文档的对象来创建XML文档。一旦创建了对象，可以调用伪方法来创建XML文档的各种元素。 示例代码： 1234567891011import groovy.xml.MarkupBuilderstatic void main(String[] args) &#123; def ele = new MarkupBuilder() ele.collection(root : 'root') &#123; ID(1) Name('ShenZhen') CountryCode('CHN') District('NanShan') Info( desc :'Special zone' ) &#125;&#125; 说明： ele.collection() 这是一个标记生成器，用于创建 &lt;/ collection&gt;的头XML标签。 Info（desc :’Special zone’）为 Info 节点创建一个属性。 运行结果： 1234567&lt;collection root='root'&gt; &lt;ID&gt;1&lt;/ID&gt; &lt;Name&gt;ShenZhen&lt;/Name&gt; &lt;CountryCode&gt;CHN&lt;/CountryCode&gt; &lt;District&gt;NanShan&lt;/District&gt; &lt;Info desc='Special zone' /&gt;&lt;/collection&gt; XML解析:Groovy XmlParser类使用一个简单的模型来将XML文档解析为Node实例的树。每个节点都有XML元素的名称，元素的属性和对任何子节点的引用。这个模型足够用于大多数简单的XML处理。 示例代码： 将刚才生成的xml 代码保存为一个 xml 文件City.xml，内容如下： 12345678&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;collection root='root'&gt; &lt;ID&gt;1&lt;/ID&gt; &lt;Name&gt;ShenZhen&lt;/Name&gt; &lt;CountryCode&gt;CHN&lt;/CountryCode&gt; &lt;District&gt;NanShan&lt;/District&gt; &lt;Info desc='Special zone' /&gt;&lt;/collection&gt; 示例代码: 1234567def parser = new XmlParser().parse('city.xml')def cityData = parser.findAll();println('ID':cityData.getAt(0))println('Name':cityData.getAt(1))println('CountryCode':cityData.getAt(2))println('District':cityData.getAt(3))println('Info':cityData.getAt(4)) 运行结果： 12345[ID:ID[attributes=&#123;&#125;; value=[1]]][Name:Name[attributes=&#123;&#125;; value=[ShenZhen]]][CountryCode:CountryCode[attributes=&#123;&#125;; value=[CHN]]][District:District[attributes=&#123;&#125;; value=[NanShan]]][Info:Info[attributes=&#123;desc=Special zone&#125;; value=[]]] Groovy - JSONGroovy提供了在对JSON支持。专门用于JSON序列化和解析的类在groovy.json包中找到。 解析 JSON：JsonSlurper是一个将JSON文本或阅读器内容解析为Groovy数据的类结构，例如地图，列表和原始类型，如整数，双精度，布尔和字符串。 示例代码： 123456789101112import groovy.json.JsonSlurperclass Example &#123; static void main(String[] args) &#123; def jsonSlurper = new JsonSlurper() def obj = jsonSlurper.parseText('&#123;"ID":1,"level":2,"Name":"ShenZhen","CountryCode":"CHN","District":"NanShan","Info":"Special zone"&#125;'); println(obj.ID) println(obj.Name println(obj.CountryCode) println(obj.District) println(obj.Info) &#125;&#125; 运行结果： 123451ShenZhenCHNNanShanSpecial zone JsonSlurper的实现类： JsonSlurper配有几个解析器实现。每个解析器都适合不同的要求，对于某些情况来说，JsonSlurper默认解析器可能不是所有情况下最好的选择。以下是运行的解析器实现的概述： 该JsonParserCharArray分析器基本上采用JSON字符串和底层字符阵列上操作。在值转换期间，它会复制字符子数组（称为“斩”的机制）并对其进行操作。 这JsonFastParser是一个特殊的变体，JsonParserCharArray是最快的解析器。但是，它不是默认解析器的原因。JsonFastParser是一个所谓的索引叠加解析器。在分析给定的JSON期间String，尽可能地努力避免创建新的字符数组或String实例。它只保留指向底层原始字符数组的指针。此外，它尽可能延迟对象创建。如果解析的地图被放入长期缓存中，则可能不会创建注释，并且仍然只包含指向原始char缓冲区的指针。但是，JsonFastParser它带有一个特殊的剁模式，它将char buffer缓冲区保留在原始缓冲区的一小部分副本中。建议是使用JsonFastParser 对于2MB以下的JSON缓冲区，并保持长期缓存限制。 这JsonParserLax是JsonParserCharArray解析器的一个特殊变体。它JsonFastParser 在ECMA-404 JSON语法上具有类似的性能。例如它允许评论，没有报价字符串等 这JsonParserUsingCharacterSource是一个非常大的文件的特殊解析器。它使用一种称为“字符窗口”的技术来解析大型JSON文件（在这种情况下，常量是指超过2MB大小的文件），具有恒定的性能特征。 生成JSON：JsonOutput负责将Groovy对象序列化为JSON字符串。它可以被看作是JsonSlurper的伴侣对象 ，它是一个JSON解析器。 示例代码： 123456789import groovy.json.JsonOutputclass Example &#123; static void main(String[] args) &#123; // 将数组转换为JSON输出 def json = JsonOutput.toJson([ID: 1, Name:'ShenZhe',CountryCode:'CHN',District:'NanShan',Info:'Special zone']); println(json) &#125;&#125; 运行结果： 1&#123;"ID":1,"Name":"ShenZhe","CountryCode":"CHN","District":"NanShan","Info":"Special zone"&#125; Groovy - DatabaseGroovy的groovy-sql模块提供了比当前Java的JDBC技术更高级的抽象。Groovy sql API支持各种各样的数据库，其中一些如下所示。(HSQLDB、Oracle、SQL Server、MySQL、MongoDB） 链接数据库：示例代码： 12345678910111213import groovy.sql.Sqlclass Example &#123; static void main (String [] args)&#123; def sql = Sql.newInstance('jdbc:mysql://localhost:3306/world_x','root','root','com.mysql.jdbc.Driver') sql.eachRow('SELECT VERSION()')&#123; row -&gt; println row[0] &#125; sql.close() &#125;&#125; 运行结果： 15.7.17 这个是当前设备的 MySQL 数据库版本号。 创建数据表：Sql类的execute方法用于对数据库执行语句。 示例代码： 123456789101112131415161718192021import groovy.sql.Sqlclass Example &#123; static void main (String [] args)&#123; def sql = Sql.newInstance('jdbc:mysql://localhost:3306/world_x','root','root','com.mysql.jdbc.Driver') def sqlStr = """ CREATE TABLE `city_copy` ( `ID` int(11) NOT NULL AUTO_INCREMENT, `Name` char(35) NOT NULL DEFAULT '', `CountryCode` char(3) NOT NULL DEFAULT '', `District` char(20) NOT NULL DEFAULT '', `Info` json DEFAULT NULL, PRIMARY KEY (`ID`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; """ sql.execute(sqlStr); sql.close() &#125;&#125; CRUD操作：插入数据：示例代码： 12345678910111213141516171819202122import groovy.sql.Sqlclass Example &#123; static void main (String [] args)&#123; def sql = Sql.newInstance('jdbc:mysql://localhost:3306/world_x','root','root','com.mysql.jdbc.Driver') sql.connection.autoCommit = false def sqlStr = """insert into `world_x`.`city` ( `Name`, `CountryCode`, `District`, `Info`) values ( 'ShenZhen', 'CHN', 'XiLi', '&#123;\\"Population\\": 7800&#125;'); """ try &#123; sql.execute(sqlStr); sql.commit() println("提交成功") &#125;catch(Exception ex) &#123; sql.rollback() println("事务回滚") &#125; sql.close() &#125;&#125; 读取数据：读取数据是通过使用SQL类的eachRow方法进行。 示例代码： 12345678910111213import groovy.sql.Sqlclass Example &#123; static void main (String [] args)&#123; def sql = Sql.newInstance('jdbc:mysql://localhost:3306/world_x','root','root','com.mysql.jdbc.Driver') sql.eachRow('select * from city') &#123; city-&gt; println([city.ID,city.Name,city.CountryCode,city.District,city.Info]) &#125; sql.close() &#125;&#125; 运行结果： 123[4, Mazar-e-Sharif, AFG, Balkh, &#123;&quot;Population&quot;: 127800&#125;][5, Amsterdam, NLD, Noord-Holland, &#123;&quot;Population&quot;: 731200&#125;][6, Rotterdam, NLD, Zuid-Holland, &#123;&quot;Population&quot;: 593321&#125;] 更新数据：示例代码： 123456789101112131415161718192021import groovy.sql.Sqlclass Example &#123; static void main (String [] args)&#123; def sql = Sql.newInstance('jdbc:mysql://localhost:3306/world_x','root','root','com.mysql.jdbc.Driver') sql.connection.autoCommit = false def sqlStr = "UPDATE CITY SET NAME = 'GUANGDONG' WHERE ID = '4'" try &#123; sql.execute(sqlStr); sql.commit() println("提交成功") &#125;catch(Exception ex) &#123; sql.rollback() println("事务回滚") &#125; sql.close() &#125;&#125; 删除数据：示例代码： 123456789101112131415161718192021import groovy.sql.Sqlclass Example &#123; static void main (String [] args)&#123; def sql = Sql.newInstance('jdbc:mysql://localhost:3306/world_x','root','root','com.mysql.jdbc.Driver') sql.connection.autoCommit = false def sqlStr = "DELETE FROM city WHERE ID = 4" try &#123; sql.execute(sqlStr); sql.commit() println("提交成功") &#125;catch(Exception ex) &#123; sql.rollback() println("事务回滚") &#125; sql.close() &#125;&#125; 事务相关操作：数据库事务正确执行的四个基本要素包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。一个支持事务（Transaction）的数据库，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易方的要求。 示例代码：(省略部分代码) 123456789try &#123; …… sql.commit() println("Successfully committed") &#125;catch(Exception ex) &#123; sql.rollback() println("Transaction rollback") &#125; sql.close() 说明： sql.commit() ：提交操作是告诉数据库继续操作并完成对数据库的所有更改 sql.rollback() ：提交过程中出现异常，并希望还原这些更改，可以使用回滚方法。 sql.close()： 要断开数据库连接。 Groovy - Unit Test：JUnit是一个开源测试框架，是Java代码自动化单元测试的公认行业标准。幸运的是，JUnit框架可以很容易地用于测试Groovy类。所需要的只是扩展作为标准Groovy环境一部分的GroovyTestCase类。 Groovy测试用例类基于Junit测试用例。 示例代码： 123456789101112131415161718192021222324252627282930313233// class Cityclass City &#123; int ID String Name String CountryCode String District String Info @Override public String toString() &#123; return "City&#123;" + "ID=" + ID + ", Name='" + Name + '\'' + ", CountryCode='" + CountryCode + '\'' + ", District='" + District + '\'' + ", Info='" + Info + '\'' + '&#125;'; &#125;&#125;// class Exampleclass Example &#123; static void main (String [] args)&#123; City city = new City(); city.ID=1 city.Name="ShenZhen" city.CountryCode="CHN" city.District="NanShan" city.Info="&#123;\\\"Population\\\": 127800&#125;" println(city.toString()) &#125;&#125; 运行结果： 1City&#123;ID=1, Name='ShenZhen', CountryCode='CHN', District='NanShan', Info='&#123;\"Population\": 127800&#125;'&#125; 示例代码： City 类的测试用例 12345678class CityTest extends GroovyTestCase &#123; void testToString()&#123; def city = new City(ID:1,Name: "ShenZhen",CountryCode: "CHN",District: "NanShan",Info:"&#123;'Population': 127800&#125;") println(city) def result = "City&#123;ID=1, Name='ShenZhen', CountryCode='CHN', District='NanShan', Info='&#123;'Population': 127800&#125;'&#125;" assertToString(city.toString(),result) &#125;&#125; Groovy测试套件:Groovy提供了一个创建测试套件的工具，GroovyTestSuite,可以将所有测试用例封装到一个逻辑单元中。 示例代码： 1234567891011121314import junit.framework.Testimport junit.textui.TestRunnerclass AlllllTests &#123; static Test suite()&#123; def allTests = new GroovyTestSuite() allTests.addTestSuite(City.class) allTests.addTestSuite(Example.class) return allTests &#125;&#125;TestRunner.run(AllTests111.suite()) 参考资料：Groovy Processing XML : http://www.groovy-lang.org/processing-xml.html#_printing_xml Parsing and producing JSON ：http://www.groovy-lang.org/json.html]]></content>
      <categories>
        <category>Groovy</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Groovy</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『JVM语言 - Groovy』基础(五)]]></title>
    <url>%2F2017%2F10%2F09%2Fgroovy-basic-5%2F</url>
    <content type="text"><![CDATA[前言：本文讲解了 Groovy 语言中的面向对象，特征，闭包，注解等内容。 Groovy - 面向对象(Object Oriented)在Groovy中，如在任何其他面向对象语言中一样，存在类和对象的概念以表示编程语言的对象定向性质。Groovy中的类声明了该类定义的对象的状态（数据）和行为。 getter和setter方法:在任何编程语言中，总是使用private关键字隐藏实例成员，而是提供getter和setter方法来相应地设置和获取实例变量的值。以下示例显示如何完成此操作。 1234567891011121314151617181920212223242526272829class Student &#123; private int StudentID; private String StudentName; void setStudentID(int pID) &#123; StudentID = pID; &#125; void setStudentName(String pName) &#123; StudentName = pName; &#125; int getStudentID() &#123; return this.StudentID; &#125; String getStudentName() &#123; return this.StudentName; &#125; static void main(String[] args) &#123; Student st = new Student(); st.setStudentID(1); st.setStudentName("Joe"); println(st.getStudentID()); println(st.getStudentName()); &#125; &#125; 运行结果： 121 Joe 说明： 在类中，studentID和studentName都标记为private，这意味着无法从类外部访问它们。 每个实例成员都有自己的getter和setter方法。getter方法返回实例变量的值，例如方法int getStudentID（）和setter方法设置实例ID的值，例如method - void setStudentName（String pName） 实例方法:在类中包含更多的方法通常是一个很自然的事情，它实际上为类实现了一些功能。在我们的学生示例中，让我们添加Marks1，Marks2和Marks3的实例成员，以表示学生在3个科目中的标记。然后我们将添加一个新的实例方法，计算学生的总分。以下是代码的外观。 在下面的示例中，Total方法是一个额外的Instance方法，它内置了一些逻辑。 123456789101112131415161718192021222324class Student &#123; int StudentID; String StudentName; int Marks1; int Marks2; int Marks3; int Total() &#123; return Marks1+Marks2+Marks3; &#125; static void main(String[] args) &#123; Student st = new Student(); st.StudentID = 1; st.StudentName="Joe"; st.Marks1 = 10; st.Marks2 = 20; st.Marks3 = 30; println(st.Total()); &#125;&#125; 运行结果： 160 创建多个对象:你也可以创建一个类的多个对象。下面是如何实现这一点的例子。在这里，我们创建3个对象（st，st1和st2）并相应地调用它们的实例成员和实例方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Student &#123; int StudentID; String StudentName; int Marks1; int Marks2; nt Marks3; int Total() &#123; return Marks1+Marks2+Marks3; &#125; static void main(String[] args) &#123; Student st = new Student(); st.StudentID = 1; st.StudentName = "Joe"; st.Marks1 = 10; st.Marks2 = 20; st.Marks3 = 30; println(st.Total()); Student st1 = new Student(); st.StudentID = 1; st.StudentName = "Joe"; st.Marks1 = 10; st.Marks2 = 20; st.Marks3 = 40; println(st.Total()); Student st3 = new Student(); st.StudentID = 1; st.StudentName = "Joe"; st.Marks1 = 10; st.Marks2 = 20; st.Marks3 = 50; println(st.Total()); &#125; &#125; 运行结果： 12360 70 80 继承:继承可以定义为一个类获取另一个类的属性（方法和字段）的过程。通过使用继承，信息以分级顺序可管理。 继承其他属性的类称为子类（派生类，子类），属性继承的类称为超类（基类，父类）。 extends是用于继承类的属性的关键字。下面给出了extends关键字的语法。 示例代码： 12345678910111213141516171819202122232425262728// Person Classclass Person &#123; public String name; public Person() &#123;&#125; &#125; // Student extends Personclass Student extends Person &#123; int StudentID int Marks1; public Student() &#123; super(); &#125; &#125; // Example Classclass Example &#123; static void main(String[] args) &#123; Student st = new Student(); st.StudentID = 1; st.Marks1 = 10; st.name = "Joe"; println(st.name); &#125;&#125; 说明： 创建一个名为Person的类。这个类有一个名为name的实例成员。 创建一个名为Student的类，它从Person类继承。请注意，在Person类中定义的名称实例成员在Student类中继承。 在Student类构造函数中，我们调用了基类构造函数。 在我们的Student类中，我们添加了2个StudentID和Marks1的实例成员。 运行结果： 1Joe 内部类:内部类在另一个类中定义。封闭类可以像往常一样使用内部类。另一方面，内部类可以访问其封闭类的成员，即使它们是私有的。不允许除封闭类之外的类访问内部类。 下面是一个外部和内部类的例子。在下面的例子中，我们做了以下事情 - 创建一个名为Outer的类，它将是我们的外部类。 在Outer类中定义名为name的字符串。 在我们的外类中创建一个内部或嵌套类。 请注意，在内部类中，我们可以访问在Outer类中定义的名称实例成员。 12345678910111213141516171819202122class Example &#123; static void main(String[] args) &#123; Outer outobj = new Outer(); outobj.name = "Joe"; outobj.callInnerMethod() &#125; &#125; class Outer &#123; String name; def callInnerMethod() &#123; new Inner().methodA() &#125; class Inner &#123; def methodA() &#123; println(name); &#125; &#125; &#125; 运行结果： 1Joe 抽象类:抽象类表示通用概念，因此，它们不能被实例化，被创建为子类化。他们的成员包括字段/属性和抽象或具体方法。抽象方法没有实现，必须通过具体子类来实现。抽象类必须用抽象关键字声明。抽象方法也必须用抽象关键字声明。 在下面的示例中，请注意，Person类现在是一个抽象类，不能被实例化。还要注意，在抽象类中有一个名为DisplayMarks的抽象方法，没有实现细节。在学生类中，必须添加实现细节。 12345678910111213141516171819202122232425262728293031class Example &#123; static void main(String[] args) &#123; Student st = new Student(); st.StudentID = 1; st.Marks1 = 10; st.name="Joe"; println(st.name); println(st.DisplayMarks()); &#125; &#125; abstract class Person &#123; public String name; public Person() &#123; &#125; abstract void DisplayMarks();&#125; class Student extends Person &#123; int StudentID int Marks1; public Student() &#123; super(); &#125; void DisplayMarks() &#123; println(Marks1); &#125; &#125; 运行结果： 12Joe 10 接口:接口定义了类需要遵守的契约。接口仅定义需要实现的方法的列表，但是不定义方法实现。需要使用interface关键字声明接口。接口仅定义方法签名。接口的方法总是公开的。在接口中使用受保护或私有方法是一个错误。 以下是groovy中的接口示例。在下面的例子中，我们做了以下事情 - 创建一个名为Marks的接口并创建一个名为DisplayMarks的接口方法。 在类定义中，我们使用implements关键字来实现接口。 因为我们是实现 因为我们正在实现接口，我们必须为DisplayMarks方法提供实现。 123456789101112131415161718192021class Example &#123; static void main(String[] args) &#123; Student st = new Student(); st.StudentID = 1; st.Marks1 = 10; println(st.DisplayMarks()); &#125; &#125; interface Marks &#123; void DisplayMarks(); &#125; class Student implements Marks &#123; int StudentID int Marks1; void DisplayMarks() &#123; println(Marks1); &#125;&#125; 运行结果： 110 Groovy - 特征(Traits)特征是语言的结构构造，允许 - 行为的组成。 接口的运行时实现。 与静态类型检查/编译的兼容性 它们可以被看作是承载默认实现和状态的接口。使用trait关键字定义trait。 下面给出了一个特征的例子： 12345trait Marks &#123; void DisplayMarks() &#123; println("Display Marks"); &#125; &#125; 然后可以使用implement关键字以类似于接口的方式实现trait。 12345678910111213141516171819class Example &#123; static void main(String[] args) &#123; Student st = new Student(); st.StudentID = 1; st.Marks1 = 10; println(st.DisplayMarks()); &#125; &#125; trait Marks &#123; void DisplayMarks() &#123; println("Display Marks"); &#125; &#125; class Student implements Marks &#123; int StudentID int Marks1;&#125; 实现接口:Traits可以实现接口，在这种情况下，使用implements关键字声明接口。 下面给出了实现接口的特征的示例。在以下示例中，可以注意以下要点。 接口Total使用方法DisplayTotal定义。 特征Marks实现了Total接口，因此需要为DisplayTotal方法提供一个实现。 1234567891011121314151617181920212223242526272829class Example &#123; static void main(String[] args) &#123; Student st = new Student(); st.StudentID = 1; st.Marks1 = 10; println(st.DisplayMarks()); println(st.DisplayTotal()); &#125; &#125; interface Total &#123; void DisplayTotal() &#125; trait Marks implements Total &#123; void DisplayMarks() &#123; println("Display Marks"); &#125; void DisplayTotal() &#123; println("Display Total"); &#125; &#125; class Student implements Marks &#123; int StudentID int Marks1; &#125; 上述程序的输出将是 - 12Display Marks Display Total 属性:特征可以定义属性，如下代码中integer类型的Marks1是一个属性。 示例代码： 123456789101112131415161718192021222324252627282930class Example &#123; static void main(String[] args) &#123; Student st = new Student(); st.StudentID = 1; println(st.DisplayMarks()); println(st.DisplayTotal()); &#125; interface Total &#123; void DisplayTotal() &#125; trait Marks implements Total &#123; int Marks1; void DisplayMarks() &#123; this.Marks1 = 10; println(this.Marks1); &#125; void DisplayTotal() &#123; println("Display Total"); &#125; &#125; class Student implements Marks &#123; int StudentID &#125;&#125; 上述程序的输出将是 - 1210 Display Total 行为的构成:特征可以用于以受控的方式实现多重继承，避免钻石问题。在下面的代码示例中，我们定义了两个特征 - Marks和Total。我们的Student类实现了两个特征。由于学生类扩展了这两个特征，它能够访问这两种方法 - DisplayMarks和DisplayTotal。 12345678910111213141516171819202122232425class Example &#123; static void main(String[] args) &#123; Student st = new Student(); st.StudentID = 1; println(st.DisplayMarks()); println(st.DisplayTotal()); &#125; &#125; trait Marks &#123; void DisplayMarks() &#123; println("Marks1"); &#125; &#125; trait Total &#123; void DisplayTotal() &#123; println("Total"); &#125; &#125; class Student implements Marks,Total &#123; int StudentID &#125; 上述程序的输出将是 - 12Total Marks1 扩展特征:特征可能扩展另一个特征，在这种情况下，必须使用extends关键字。在下面的代码示例中，我们使用Marks trait扩展了Total trait。 示例代码： 1234567891011121314151617181920212223class Example &#123; static void main(String[] args) &#123; Student st = new Student(); st.StudentID = 1; println(st.DisplayMarks()); &#125; &#125; trait Marks &#123; void DisplayMarks() &#123; println("Marks1"); &#125; &#125; trait Total extends Marks &#123; void DisplayMarks() &#123; println("Total"); &#125; &#125; class Student implements Total &#123; int StudentID &#125; 运行结果： 1Total Groovy - 闭包(Closures)闭包是一个短的匿名代码块。它通常跨越几行代码。一个方法甚至可以将代码块作为参数。它们是匿名的。 示例代码： 123456class Example &#123; static void main(String[] args) &#123; def clos = &#123;println "Hello World"&#125;; clos.call(); &#125; &#125; 在上面的例子中，代码行 - {println“Hello World”}被称为闭包。此标识符引用的代码块可以使用call语句执行。 运行结果： 1Hello World 闭包中的形参:闭包也可以包含形式参数，以使它们更有用，就像Groovy中的方法一样。 示例代码： 123456class Example &#123; static void main(String[] args) &#123; def clos = &#123;param-&gt;println "Hello $&#123;param&#125;"&#125;; clos.call("World"); &#125; &#125; 在上面的代码示例中，注意使用$ {param}，这导致closure接受一个参数。当通过clos.call语句调用闭包时，我们现在可以选择将一个参数传递给闭包。 运行结果： 1Hello World 下一个图重复了前面的例子并产生相同的结果，但显示可以使用被称为它的隐式单个参数。这里的’it’是Groovy中的关键字。 示例代码： 123456class Example &#123; static void main(String[] args) &#123; def clos = &#123;println "Hello $&#123;it&#125;"&#125;; clos.call("World"); &#125; &#125; 运行结果： 1Hello World 闭包和变量:更正式地，闭包可以在定义闭包时引用变量。 示例代码： 12345678910class Example &#123; static void main(String[] args) &#123; def str1 = "Hello"; def clos = &#123;param -&gt; println "$&#123;str1&#125; $&#123;param&#125;"&#125; clos.call("World"); str1 = "Welcome"; clos.call("World"); &#125; &#125; 在上面的例子中，除了向闭包传递参数之外，我们还定义了一个名为str1的变量。闭包也接受变量和参数。 运行结果： 12Hello World Welcome World 在方法中使用闭包:闭包也可以用作方法的参数。在Groovy中，很多用于数据类型（例如列表和集合）的内置方法都有闭包作为参数类型。 示例代码： 12345678910111213141516171819class Example &#123; def static Display(clo) &#123; // This time the $param parameter gets replaced by the string "Inner" clo.call("Inner"); &#125; static void main(String[] args) &#123; def str1 = "Hello"; def clos = &#123; param -&gt; println "$&#123;str1&#125; $&#123;param&#125;" &#125; clos.call("World"); // We are now changing the value of the String str1 which is referenced in the closure str1 = "Welcome"; clos.call("World"); // Passing our closure to a method Example.Display(clos); &#125; &#125; 在上述示例中， 我们定义一个名为Display的静态方法，它将闭包作为参数。 然后我们在我们的main方法中定义一个闭包，并将它作为一个参数传递给我们的Display方法。 运行结果： 123Hello World Welcome World Welcome Inner 集合和字符串中的闭包:几个List，Map和String方法接受一个闭包作为参数。让我们看看在这些数据类型中如何使用闭包的例子。 使用闭包和列表:以下示例显示如何使用闭包与列表。在下面的例子中，我们首先定义一个简单的值列表。列表集合类型然后定义一个名为.each的函数。此函数将闭包作为参数，并将闭包应用于列表的每个元素。 示例代码： 123456class Example &#123; static void main(String[] args) &#123; def lst = [11, 12, 13, 14]; lst.each &#123;println it&#125; &#125; &#125; 运行结果： 123411 12 13 14 使用映射闭包:以下示例显示了如何使用闭包。在下面的例子中，我们首先定义一个简单的关键值项Map。然后，映射集合类型定义一个名为.each的函数。此函数将闭包作为参数，并将闭包应用于映射的每个键值对。 1234567class Example &#123; static void main(String[] args) &#123; def mp = ["TopicName" : "Maps", "TopicDescription" : "Methods in Maps"] mp.each &#123;println it&#125; mp.each &#123;println "$&#123;it.key&#125; maps to: $&#123;it.value&#125;"&#125; &#125; &#125; 运行结果： 1234TopicName = Maps TopicDescription = Methods in Maps TopicName maps to: Maps TopicDescription maps to: Methods in Maps 通常，我们可能希望遍历集合的成员，并且仅当元素满足一些标准时应用一些逻辑。这很容易用闭包中的条件语句来处理。 12345678class Example &#123; static void main(String[] args) &#123; def lst = [1,2,3,4]; lst.each &#123;println it&#125; println("The list will only display those numbers which are divisible by 2") lst.each&#123;num -&gt; if(num % 2 == 0) println num&#125; &#125; &#125; 上面的例子显示了在闭包中使用的条件if（num％2 == 0）表达式，用于检查列表中的每个项目是否可被2整除。 运行结果： 12345671 2 3 4 The list will only display those numbers which are divisible by 2.2 4 闭包使用的方法: 序号 方法 描述 1 find() find方法查找集合中与某个条件匹配的第一个值。 2 findAll（） 它找到接收对象中与闭合条件匹配的所有值。 3 any() &amp; every() 方法any迭代集合的每个元素，检查布尔谓词是否对至少一个元素有效。 4 collect() 该方法通过集合收集迭代，使用闭包作为变换器将每个元素转换为新值。 Groovy - 注解(Annotations)注解是元数据的形式，其中它们提供关于不是程序本身的一部分的程序的数据。注解对它们注解的代码的操作没有直接影响。 注解主要用于以下原因 - 编译器信息 -编译器可以使用注解来检测错误或抑制警告。 编译时和部署时处理 -软件工具可以处理注解信息以生成代码，XML文件等。 运行时处理 -一些注解可以在运行时检查。 在Groovy中，基本注解如下所示： @interface - at符号字符（@）向编译器指示以下是注解。 注解可以以没有主体的方法的形式和可选的默认值来定义成员。 注解可以应用于以下类型 - 字符串类型:示例代码: 123@interface Simple &#123; String str1() default "HelloWorld"; &#125; 枚举类型:示例代码: 1234enum DayOfWeek &#123; mon, tue, wed, thu, fri, sat, sun &#125; @interface Scheduled &#123; DayOfWeek dayOfWeek() &#125; 类类型:示例代码: 12345678910@interface Simple &#123;&#125; @Simple class User &#123; String username int age&#125; def user = new User(username: "Joe",age:1); println(user.age); println(user.username); 注解成员值:使用注解时，需要至少设置所有没有默认值的成员。下面给出一个例子。当定义后使用注解示例时，需要为其分配一个值。 示例代码: 12345@interface Example &#123; int status() &#125;@Example(status = 1) 关闭注解参数:Groovy中注解的一个很好的特性是，你也可以使用闭包作为注解值。因此，注解可以与各种各样的表达式一起使用。 下面给出一个例子。注解Onlyif是基于类值创建的。然后注解应用于两个方法，它们基于数字变量的值向结果变量发布不同的消息。 示例代码: 12345678910111213@interface OnlyIf &#123; Class value() &#125; @OnlyIf(&#123; number&lt;=6 &#125;) void Version6() &#123; result &lt;&lt; 'Number greater than 6' &#125; @OnlyIf(&#123; number&gt;=6 &#125;) void Version7() &#123; result &lt;&lt; 'Number greater than 6' &#125; 元注解这是groovy中注解的一个非常有用的功能。有时可能有一个方法的多个注解，如下所示。有时这可能变得麻烦有多个注解。 示例代码: 123@Procedure @Master class MyMasterProcedure &#123;&#125; 在这种情况下，您可以定义一个元注解，它将多个注解集中在一起，并将元注解应用于该方法。所以对于上面的例子，你可以使用AnnotationCollector来定义注解的集合。 示例代码: 12345import groovy.transform.AnnotationCollector @Procedure @Master @AnnotationCollector 一旦完成，您可以应用以下元注解器到该方法。 示例代码: 12345678import groovy.transform.AnnotationCollector @Procedure @Master @AnnotationCollector @MasterProcedure class MyMasterProcedure &#123;&#125; 参考资料：https://www.tutorialspoint.com/groovy/groovy_object_oriented.htm https://www.tutorialspoint.com/groovy/groovy_traits.htm https://www.tutorialspoint.com/groovy/groovy_closures.htm https://www.tutorialspoint.com/groovy/groovy_annotations.htm]]></content>
      <categories>
        <category>Groovy</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Groovy</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『JVM语言 - Groovy』基础(四)]]></title>
    <url>%2F2017%2F10%2F01%2Fgroovy-basic-4%2F</url>
    <content type="text"><![CDATA[前言：本文讲解了 Groovy语言中的 List、Map、泛型，与 Java 一致的内容则不再赘述。 Groovy - List:列表是用于存储数据项集合的结构。Groovy中，List保存了一系列对象引用。List中的对象引用占据序列中的位置，并通过整数索引来区分。要处理列表中的数据，我们必须能够访问各个元素。 Groovy列表使用索引操作符[]索引。列表索引从零开始，这指的是第一个元素。 以下是一些列表的示例: [11，12，13，14] - 整数值列表 [‘Angular’，’Groovy’，’Java’] - 字符串列表 [1，2，[3，4]，5] - 嵌套列表 [‘Groovy’，21，2.11] - 异构的对象引用列表 [] - 一个空列表 可用的列表方法: 序号 方法 描述 1 add() 将新值附加到此列表的末尾。 2 contains() 如果此列表包含指定的值，则返回true。 3 get() 返回此列表中指定位置的元素。 4 isEmpty() 如果此列表不包含元素，则返回true 5 minus() 创建一个由原始元素组成的新列表，而不是集合中指定的元素。 6 plus() 创建由原始元素和集合中指定的元素组成的新列表。 7 pop() 从此列表中删除最后一个项目 8 remove() 删除此列表中指定位置的元素。 9 reverse() 创建与原始列表的元素相反的新列表 10 size() 获取此列表中的元素数。 11 sort() 返回原始列表的排序副本。 Groovy - Map:Map（也称为关联数组，字典，表和散列）是对象引用的无序集合。Map集合中的元素由键值访问。 Map中使用的键可以是任何类。当我们插入到Map集合中时，需要两个值：键和值。 以下是一些映射的例子： [‘TopicName’：’Lists’，’TopicName’：’Maps’] - 具有TopicName作为键的键值对的集合及其相应的值。 [：] - 空映射。 Groovy中Map方法: 序号 方法 描述 1 containsKey() Map中是否包含此键 2 get() 查找此Map中的键并返回相应的值。如果此Map中没有键的条目，则返回null。 3 keySet() 获取此Map中的一组键。 4 put() 将指定的值与此Map中的指定键相关联。如果此Map先前包含此键的Map，则旧值将替换为指定的值。 5 size() 返回此Map中的键值Map的数量。 6 values() 返回此Map中包含的值的集合视图。 Groovy - 泛型：在定义类，接口和方法时，泛型使能类型（类和接口）作为参数。与在方法声明中使用的更熟悉的形式参数非常类似，类型参数提供了一种方法，可以为不同的输入重复使用相同的代码。区别在于形式参数的输入是值，而类型参数的输入是类型。 集合的通用：可以对集合类（如List类）进行实例化，以便只有该类型的集合在应用程序中被接受。 示例代码: 1234567891011121314class Example &#123; static void main(String[] args) &#123; // 创建一个字符串类型的 ArrayList 集合 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 向集合中添加三个字符串 list.add("First String"); list.add("Second String"); list.add("Third String"); // 循环遍历 for(String str : list) &#123; println(str); &#125; &#125; &#125; 上述程序的输出将是 - 123First String Second String Third String 泛型类：整个类也可以泛化。这使得类更灵活地接受任何类型，并相应地与这些类型工作。让我们来看一个例子，说明我们如何做到这一点。 示例代码： 123456789101112131415161718192021222324class Example &#123; static void main(String[] args) &#123; // String ListType&lt;String&gt; lststr = new ListType&lt;&gt;(); lststr.set("First String"); println(lststr.get()); // Integer ListType&lt;Integer&gt; lstint = new ListType&lt;&gt;(); lstint.set(1); println(lstint.get()); &#125;&#125; public class ListType&lt;T&gt; &#123; private T localt; // getter setter public T get() &#123; return this.localt; &#125; public void set(T plocal) &#123; this.localt = plocal; &#125; &#125; 上述程序的输出将是 - 12First String 1 参考资料：List:https://www.tutorialspoint.com/groovy/groovy_lists.htm Map:https://www.tutorialspoint.com/groovy/groovy_maps.htm Generics:https://www.tutorialspoint.com/groovy/groovy_generics.htm]]></content>
      <categories>
        <category>Groovy</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Groovy</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『JVM语言 - Groovy』基础(三)]]></title>
    <url>%2F2017%2F09%2F26%2Fgroovy-basic-3%2F</url>
    <content type="text"><![CDATA[前言：本文讲解了 Groovy 语言中的方法、I/O、日期时间、正则、异常，与 Java 一致的内容则不再赘述。 Groovy - 方法：Groovy中的方法是使用返回类型或使用def关键字定义的。方法可以接收任意数量的参数。定义参数时，不必显式定义类型。可以添加修饰符，如public，private和protected。默认情况下，如果未提供可见性修饰符，则该方法为public。 最简单的方法是没有参数的方法，如下所示： 123def methodName() &#123; //Method code &#125; 下面是一个简单方法的例子 12345678910class Example &#123; static def DisplayName() &#123; println("This is how methods work in groovy"); println("This is an example of a simple method"); &#125; static void main(String[] args) &#123; DisplayName(); &#125; &#125; 在上面的例子中，DisplayName是一个简单的方法，它由两个println语句组成，用于向控制台输出一些文本。在我们的静态main方法中，我们只是调用DisplayName方法。上述方法的输出将是 - 12This is how methods work in groovy This is an example of a simple method 方法参数如果一个方法的行为由一个或多个参数的值确定，则它通常是有用的。我们可以使用方法参数将值传递给被调用的方法。请注意，参数名称必须彼此不同。 使用参数的最简单的方法类型，如下所示 − 123def methodName(parameter1, parameter2, parameter3) &#123; // Method code goes here &#125; 以下是使用参数的简单方法的示例 12345678910class Example &#123; static void sum(int a,int b) &#123; int c = a+b; println(c); &#125; static void main(String[] args) &#123; sum(10,5); &#125; &#125; 在这个例子中，我们创建一个带有2个参数a和b的sum方法。两个参数都是int类型。然后我们从我们的main方法中调用sum方法，并将值传递给变量a和b。 然后我们从我们的main方法中调用sum方法，并将值传递给变量a和b。 上述方法的输出将是值15。 默认参数Groovy中还有一个规定来指定方法中的参数的默认值。 如果没有值传递给参数的方法，则使用缺省值。 如果使用非默认和默认参数，则必须注意，默认参数应在参数列表的末尾定义。 以下是使用参数的简单方法的示例 - 123def someMethod(parameter1, parameter2 = 0, parameter3 = 0) &#123; // Method code goes here &#125; 让我们看看我们之前看到的添加两个数字的相同示例，并创建一个具有一个默认和另一个非默认参数的方法 - 12345678910class Example &#123; static void sum(int a,int b = 5) &#123; int c = a+b; println(c); &#125; static void main(String[] args) &#123; sum(6); &#125; &#125; 在这个例子中，我们创建一个具有两个参数a和b的sum方法。两个参数都是int类型。此示例和上一个示例的区别在于，在这种情况下，我们将b的默认值指定为5。 因此，当我们从main方法中调用sum方法时，我们可以选择只传递一个值为6的值，并将其分配给sum方法中的参数a。 上述方法的输出将为值11。 12345678910class Example &#123; static void sum(int a,int b = 5) &#123; int c = a+b; println(c); &#125; static void main(String[] args) &#123; sum(6,6); &#125; &#125; 我们也可以通过传递2个值来调用sum方法，在上面的例子中，我们传递2个值6.第二个值6实际上将替换分配给参数b的默认值。 上述方法的输出将是值12。 方法返回值方法也可以将值返回到调用程序。 这在现在编程语言中是必需的，其中方法执行某种计算，然后将所需值返回到调用方法。 下面是一个带有返回值的简单方法的例子。 12345678910class Example &#123; static void sum(int a,int b = 5) &#123; int c = a+b; println(c); &#125; static void main(String[] args) &#123; println(sum(6)); &#125; &#125; 在我们上面的例子中，注意这次我们为我们的方法sum指定一个类型为int的返回类型。 在方法中，我们使用return语句将sum值发送到调用主程序。 由于方法的值现在可用于main方法，因此我们使用println函数在控制台中显示该值。 在前面的例子中，我们将我们的方法定义为静态方法，这意味着我们可以直接从类中访问这些方法。方法的下一个示例是实例方法，其中通过创建类的对象来访问方法。我们将在后面的章节中看到类，现在我们将演示如何使用方法。 上述方法的输出将为值11。 实例方法方法通常在Groovy中的类中实现，就像Java语言一样。类只是一个蓝图或模板，用于创建定义其属性和行为的不同对象。类对象显示由其类定义的属性和行为。因此，通过在类中创建方法来定义行为。 我们将在后面的章节中更详细地看到类，下面是类中方法实现的例子。 以下是如何实现方法的示例。 1234567891011121314151617class Example &#123; int x; public int getX() &#123; return x; &#125; public void setX(int pX) &#123; x = pX; &#125; static void main(String[] args) &#123; Example ex = new Example(); ex.setX(100); println(ex.getX()); &#125; &#125; 在我们上面的例子中，这次我们没有为类方法指定静态属性。在我们的main函数中，我们实际上创建了一个Example类的实例，然后调用’ex’对象的方法。 上述方法的输出将是值100。 本地和外部参数名称Groovy提供的设施就像java一样具有本地和全局参数。在下面的示例中，lx是一个局部参数，它只具有getX（）函数内的作用域，x是一个全局属性，可以在整个Example类中访问。如果我们尝试访问getX（）函数之外的变量lx，我们将得到一个错误。 12345678910111213class Example &#123; static int x = 100; public static int getX() &#123; int lx = 200; println(lx); return x; &#125; static void main(String[] args) &#123; println getX() &#125; &#125; 当我们运行上面的程序，我们会得到以下结果。 12200 100 方法属性就像在Java中一样，groovy可以使用this关键字访问它的实例成员。以下示例显示了当我们使用语句this.x时，它引用其实例并相应地设置x的值。 12345678910111213class Example &#123; int x = 100; public int getX() &#123; this.x = 200; return x; &#125; static void main(String[] args) &#123; Example ex = new Example(); println(ex.getX()); &#125;&#125; 当我们运行上面的程序，我们将得到200的结果打印在控制台上。 Groovy - I/O:Groovy在使用I / O时提供了许多辅助方法。 Groovy提供了更简单的类来为文件提供以下功能。 读取文件 写入文件 遍历文件树 读取和写入数据对象到文件 除此之外，您始终可以使用下面列出的用于文件I / O操作的标准Java类。 java.io.File java.io.InputStream java.io.OutputStream java.io.Reader java.io.Writer 读取文件以下示例将输出Groovy中的文本文件的所有行。方法eachLine内置在Groovy中的File类中，目的是确保文本文件的每一行都被读取。 12345678import java.io.File class Example &#123; static void main(String[] args) &#123; new File("E:/Example.txt").eachLine &#123; line -&gt; println "line : $line"; &#125; &#125; &#125; File类用于实例化以文件名作为参数的新对象。 然后它接受eachLine的函数，将它放到一个line的变量并相应地打印它。如果文件包含以下行，它们将被打印。 12line : Example1line : Example2 读取文件的内容到字符串如果要将文件的整个内容作为字符串获取，可以使用文件类的text属性。以下示例显示如何完成此操作。 123456class Example &#123; static void main(String[] args) &#123; File file = new File("E:/Example.txt") println file.text &#125; &#125; 如果该文件包含以下行，它们将被打印出来。 12line : Example1 line : Example2 写入文件如果你想写入文件，你需要使用作家类输出文本到一个文件中。下面的例子说明了如何可以做到这一点。 12345678import java.io.File class Example &#123; static void main(String[] args) &#123; new File('E:/','Example.txt').withWriter('utf-8') &#123; writer -&gt; writer.writeLine 'Hello World' &#125; &#125; &#125; 如果你打开文件example.txt文件，您将看到文本中打印了“Hello World”这个词。 获取文件的大小如果要获取文件的大小，可以使用文件类的length属性来获取文件的大小。以下示例显示如何完成此操作。 123456class Example &#123; static void main(String[] args) &#123; File file = new File("E:/Example.txt") println "The file $&#123;file.absolutePath&#125; has $&#123;file.length()&#125; bytes" &#125; &#125; 上面的代码将显示文件的大小（以字节为单位）。 测试文件是否是目录如果要查看路径是文件还是目录，可以使用File类的isFile和isDirectory选项。以下示例显示如何完成此操作。 1234567class Example &#123; static void main(String[] args) &#123; def file = new File('E:/') println "File? $&#123;file.isFile()&#125;" println "Directory? $&#123;file.isDirectory()&#125;" &#125; &#125; 上面的代码将显示以下输出 - 12File? false Directory? True 创建目录如果要创建一个新目录，可以使用File类的mkdir函数。以下示例显示如何完成此操作。 123456class Example &#123; static void main(String[] args) &#123; def file = new File('E:/Directory') file.mkdir() &#125; &#125; 如果目录E：\ Directory不存在，将创建它。 删除文件如果要删除文件，可以使用File类的delete功能。以下示例显示如何完成此操作。 123456class Example &#123; static void main(String[] args) &#123; def file = new File('E:/Example.txt') file.delete() &#125; &#125; 如果存在该文件将被删除。 复制文件Groovy还提供将内容从一个文件复制到另一个文件的功能。以下示例显示如何完成此操作。 123456789101112131415161718192021222324252627class Example &#123; static void main(String[] args) &#123; def src = new File("E:/Example.txt") def dst = new File("E:/Example1.txt") dst &lt;&lt; src.text &#125; &#125;​```Groovy将创建文件Example1.txt，并将文件Example.txt的所有内容复制到此文件。### 获取目录内容Groovy还提供了列出驱动器中的驱动器和文件的功能。以下示例显示如何使用File类的listRoots函数显示机器上的驱动器。​```Groovyclass Example &#123; static void main(String[] args) &#123; def rootFiles = new File("test").listRoots() rootFiles.each &#123; file -&gt; println file.absolutePath &#125; &#125;&#125; 根据机器上可用的驱动器，输出可能会有所不同。在标准机器上的输出将类似于下面的一个 - 12C:\D:\ 以下示例显示如何使用File类的eachFile函数列出特定目录中的文件。 12345678910111213141516171819202122class Example &#123; static void main(String[] args) &#123; new File("E:/Temp").eachFile() &#123; file-&gt;println file.getAbsolutePath() &#125; &#125; &#125;​```Groovy输出将显示目录E：\ Temp中的所有文件如果要递归显示目录及其子目录中的所有文件，则可以使用File类的eachFileRecurse函数。以下示例显示如何完成此操作。​```Groovyclass Example &#123; static void main(String[] args) &#123; new File("E:/temp").eachFileRecurse() &#123; file -&gt; println file.getAbsolutePath() &#125; &#125;&#125; 输出将显示目录E：\ Temp中的所有文件及其子目录（如果存在）。 Groovy - 日期和时间：类Date表示特定的时刻，具有毫秒精度。 Date类有两个构造函数，如下所示。 Date()句法1public Date() 参数 -无。 返回值 分配一个Date对象并初始化它，以便它表示分配的时间，以最近的毫秒为单位。 下面是一个使用这个方法的例子 - 12345678class Example &#123; static void main(String[] args) &#123; Date date = new Date(); // display time and date using toString() System.out.println(date.toString()); &#125; &#125; 当我们运行上面的程序，我们将得到以下结果。以下输出将为您提供当前日期和时间 - 1Thu Dec 10 21:31:15 GST 2015 Date (长毫秒)句法1public Date(long millisec) 参数 毫秒 - millisecconds的数量，因为标准的基准时间指定。 返回值 -分配一个Date对象并将其初始化以表示自标准基准时间（称为“该历元”，即1970年1月1日，00:00:00 GMT）起指定的毫秒数。 下面是一个使用这个方法的例子 - 12345678class Example &#123; static void main(String[] args) &#123; Date date = new Date(100); // display time and date using toString() System.out.println(date.toString()); &#125; &#125; 当我们运行上面的程序，我们将得到以下结果 - 1Thu Jan 01 04:00:00 GST 1970 以下是Date类的给定方法。在接受或返回年，月，日，小时，分钟和秒值的类Date的所有方法中，使用以下表示形式 - 年y由整数y-1900表示。 一个月份由0到11的整数表示; 0是1月，1是2月，等等;因此11是12月。 日期（月中的日）以通常方式由1至31的整数表示。 一个小时由从0到23的整数表示。因此，从午夜到上午1点的小时是小时0，而从中午到下午1点的小时是小时12。 分钟由通常方式的0至59的整数表示。 第二个由0至61的整数表示。 序号 方法 描述 1 after() 测试此日期是否在指定日期之后。 2 equals() 比较两个日期的相等性。当且仅当参数不为null时，结果为true，并且是表示与该对象时间相同的时间点（毫秒）的Date对象。 3 compareTo() 比较两个日期的顺序。 4 toString() 将此Date对象转换为字符串 5 before() 测试此日期是否在指定日期之前。 6 getTime() 返回自此Date对象表示的1970年1月1日，00:00:00 GMT以来的毫秒数。 7 setTime() 设置此Date对象以表示一个时间点，即1970年1月1日00:00:00 GMT之后的时间毫秒。 Groovy - 正则表达式：正则表达式是用于在文本中查找子字符串的模式。 Groovy使用〜“regex”表达式本地支持正则表达式。引号中包含的文本表示用于比较的表达式。 例如，我们可以创建一个正则表达式对象，如下所示 - 1def regex = ~'Groovy' 当Groovy运算符=〜在if和while语句中作为谓词（返回布尔值的表达式）出现时，左侧的String操作数与右侧的正则表达式操作数匹配。因此，以下每个都传递值true。 当定义正则表达式时，可以使用以下特殊字符 有两个特殊的位置字符用于表示一行的开始和结束：caret（∧）和美元符号（$）。 正则表达式也可以包括量词。加号（+）表示一次或多次，应用于表达式的前一个元素。星号（*）用于表示零个或多个出现。问号（？）表示零或一次。 元字符{和}用于匹配前一个字符的特定数量的实例。 在正则表达式中，句点符号（。）可以表示任何字符。这被描述为通配符。 正则表达式可以包括字符类。一组字符可以作为简单的字符序列，包含在元字符[和]中，如[aeiou]中。对于字母或数字范围，可以使用[a-z]或[a-mA-M]中的短划线分隔符。字符类的补码由方括号内的前导插入符号表示，如[∧a-z]中所示，并表示除指定的字符以外的所有字符。下面给出了正则表达式的一些示例。 1234567'Groovy' =~ 'Groovy' 'Groovy' =~ 'oo' 'Groovy' ==~ 'Groovy' 'Groovy' ==~ 'oo' 'Groovy' =~ '∧G' ‘Groovy' =~ 'G$' ‘Groovy' =~ 'Gro*vy' 'Groovy' =~ 'Gro&#123;2&#125;vy' Groovy - 异常处理：任何编程语言都需要异常处理来处理运行时错误，从而可以保持应用程序的正常流程。 异常通常会破坏应用程序的正常流程，这就是为什么我们需要在我们的应用程序中使用异常处理的原因。 异常分类：检测异常：扩展Throwable类（除了RuntimeException和Error）的类称为检查异常egIOException，SQLException等。检查的异常在编译时检查。 一个典型的情况是FileNotFoundException。假设您的应用程序中有以下代码，它从E盘中的文件读取。 123456class Example &#123; static void main(String[] args) &#123; File file = new File("E://file.txt"); FileReader fr = new FileReader(file); &#125; &#125; 如果文件（file.txt）不在E盘中，那么将引发以下异常。 抓取：java.io.FileNotFoundException：E：\ file.txt（系统找不到指定的文件）。 java.io.FileNotFoundException：E：\ file.txt（系统找不到指定的文件）。 未经检查的异常: 扩展RuntimeException的类称为未检查异常，例如，ArithmeticException，NullPointerException，ArrayIndexOutOfBoundsException等。未检查的异常在编译期不检查，而是在运行时检查。 一个典型的情况是ArrayIndexOutOfBoundsException，当您尝试访问大于数组长度的数组的索引时，会发生这种情况。以下是这种错误的典型例子。 123456class Example &#123; static void main(String[] args) &#123; def arr = new int[3]; arr[5] = 5; &#125; &#125; 当上面的代码执行时，将引发以下异常。 抓取：java.lang.ArrayIndexOutOfBoundsException：5 java.lang.ArrayIndexOutOfBoundsException：5 错误： 错误无法恢复。 OutOfMemoryError，VirtualMachineError，AssertionError等。 这些是程序永远不能恢复的错误，将导致程序崩溃。 Groovy中的异常层次结构,它基于Java中定义的层次结构: 捕获异常：方法使用try和catch关键字的组合捕获异常。 try / catch块放置在可能生成异常的代码周围。 1234567891011try &#123; //Protected code &#125; catch(ExceptionName e1) &#123; //Catch block &#125; catch(ExceptionName e2)&#123; // Catch block&#125; catch(ExceptionName e3)&#123; // Catch block&#125; finally&#123; // Finally block&#125; 所有可能引发异常的代码都放在受保护的代码块中，在catch块中，可以编写自定义代码来处理异常，以便应用程序可以从异常中恢复。 让我们看一个类似的代码示例，我们在上面看到一个索引值大于数组大小的数组。但这次让我们将我们的代码包装在try / catch块中。 程序中也可以有多个catch块来处理多种类型的异常。对于每个catch块，根据引发的异常的类型，您将编写代码来相应地处理它。 finally块跟在try块或catch块之后。代码的finally块总是执行，而不管异常的发生。 使用finally块可以运行任何你想要执行的清除类型语句，无论在受保护代码中发生什么。 异常方法： public String getMessage（） 返回有关已发生异常的详细消息。此消息在Throwable构造函数中初始化。 public Throwable getCause() 返回由Throwable对象表示的异常原因。 public String toString() 返回与getMessage（）的结果连接的类的名称。 public void printStackTrace() 将toString（）的结果与堆栈跟踪一起打印到System.err，错误输出流。 public StackTraceElement [] getStackTrace() 返回包含堆栈跟踪上的每个元素的数组。索引0处的元素表示调用堆栈的顶部，数组中的最后一个元素表示调用堆栈底部的方法。 public Throwable fillInStackTrace() 使用当前堆栈跟踪填充此Throwable对象的堆栈跟踪，添加到堆栈跟踪中的任何以前的信息。 参考资料：Methods:https://www.tutorialspoint.com/groovy/groovy_methods.htm I/O:https://www.tutorialspoint.com/groovy/groovy_file_io.htm Dates &amp; Times:https://www.tutorialspoint.com/groovy/groovy_dates_times.htm Ranges:https://www.tutorialspoint.com/groovy/groovy_ranges.htm Exception:https://www.tutorialspoint.com/groovy/groovy_exception_handling.htm]]></content>
      <categories>
        <category>Groovy</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Groovy</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『JVM语言 - Groovy』基础(二)]]></title>
    <url>%2F2017%2F09%2F21%2Fgroovy-basic-2%2F</url>
    <content type="text"><![CDATA[前言：本文讲解了 Groovy 语言中的循环语句、数字、字符串、Optionally类型(def)，与 Java 一致的内容则不再赘述。 Groovy - 循环语句：while：语法： 12345while(condition) &#123; statement #1 statement #2 ... &#125; 通过首先计算条件表达式（布尔值）来执行while语句，如果结果为true，则执行while循环中的语句。从while语句中的条件的评估开始重复该过程 此循环继续，直到条件计算为false。当条件变为假时，循环终止。 然后程序逻辑继续紧跟在while语句之后的语句。 for：for 语句用于遍历一组值。for 语句通常以以下方式使用： 12345for(variable declaration;expression;Increment) &#123; statement #1 statement #2 … &#125; 经典的语句包括以下部分 - 变量声明 - 此步骤对整个循环只执行一次，用于声明将在循环中使用的任何变量。 表达式 - 这将包含一个表达式，将为循环的每次迭代计算。 增量部分将包含在for语句中声明的变量所需的逻辑。 for-in :for-in 语句用于遍历一组值。for-in 语句通常以以下方式使用： 12345for(variable in range) &#123; statement #1 statement #2 … &#125; for-in 语句也可用于循环访问Map。 break：break 语句用于更改loop和switch语句内的控制流。我们已经看到break语句与switch语句结合使用。break语句也可以与while和for语句一起使用。使用这些循环结构中的任何一个执行 break 语句会立即终止最内层的循环。 continue：continue语句补充了break语句。它的使用局限于while和for循环。当执行continue语句时，控制立即传递到最近的封闭循环的测试条件，以确定循环是否应该继续。对于该特定循环迭代，循环体中的所有后续语句都将被忽略。 Groovy - 数字：在Groovy中，数字实际上表示为对象，它们都是类Integer的一个实例。要使对象做某事，我们需要调用在其类中声明的一个方法。 Groovy支持整数和浮点数。 整数是不包含分数的值。 浮点数是包含小数部分的十进制值。 以下是可用的方法列表。 序号 方法 描述 1 xxxValue（） 此方法接受Number作为参数，并基于调用的方法返回基本类型。 2 compareTo() compareTo方法是使用比较一个数字与另一个数字。如果要比较数字的值，这是有用的。 3 equals() 该方法确定调用方法的Number对象是否等于作为参数传递的对象。 4 valueOf() valueOf方法返回保存所传递的参数的值的相关Number对象。 5 toString() 该方法用于获取表示Number对象的值的String对象。 6 parseInt() 此方法用于获取某个String的原始数据类型。 parseXxx（）是一个静态方法，可以有一个参数或两个参数。 7 abs() 该方法给出了参数的绝对值。参数可以是int，float，long，double，short，byte。 8 ceil() 方法ceil给出大于或等于参数的最小整数。 9 floor() 方法floor给出小于或等于参数的最大整数。 10 rint() 方法rint返回值最接近参数的整数。 11 round() 方法round返回最接近的long或int，由方法返回类型给出。 12 min() 该方法给出两个参数中较小的一个。参数可以是int，float，long，double。 13 max() 该方法给出了两个参数的最大值。参数可以是int，float，long，double。 14 exp() 该方法返回自然对数e的底数为参数的幂。 15 log() 该方法返回参数的自然对数。 16 pow() 该方法返回第一个参数的值增加到第二个参数的幂。 17 sqrt() 该方法返回参数的平方根。 18 sin() 该方法返回指定double值的正弦值。 19 cos() 该方法返回指定double值的余弦值。 20 tan() 该方法返回指定double值的正切值。 21 asin() 该方法返回指定double值的反正弦值。 22 acos() 该方法返回指定double值的反余弦值。 23 atan() 该方法返回指定double值的反正切。 24 atan2() 该方法将直角坐标（x，y）转换为极坐标（r，theta），并返回theta。 25 parseInt() 该方法将参数值转换为度。 26 radian() 该方法将参数值转换为弧度。 27 random() 该方法用于生成介于0.0和1.0之间的随机数。范围是：0.0 = &lt;Math.random &lt;1.0。通过使用算术可以实现不同的范围。 Groovy - 字符串： 序号 方法 描述 1 center() 返回一个新的长度为numberOfChars的字符串，该字符串由左侧和右侧用空格字符填充的收件人组成。 2 compareToIgnoreCase() 按字母顺序比较两个字符串，忽略大小写差异。 3 concat() 将指定的String连接到此String的结尾。 4 eachMatch() 处理每个正则表达式组（参见下一节）匹配的给定String的子字符串。 5 endsWith() 测试此字符串是否以指定的后缀结尾。 6 equalsIgnoreCase() 将此字符串与另一个字符串进行比较，忽略大小写注意事项。 7 getAt() 它在索引位置返回字符串值 8 indexOf() 返回此字符串中指定子字符串第一次出现的索引。 9 matches() 它输出字符串是否匹配给定的正则表达式。 10 minus() 删除字符串的值部分。 11 next() 此方法由++运算符为String类调用。它增加给定字符串中的最后一个字符。 12 padLeft（） 填充字符串，并在左边附加空格。 13 padRight() 填充字符串，并在右边附加空格。 14 plus() 追加字符串 15 previous() 此方法由CharSequence的 - 运算符调用。 16 replaceAll() 通过对该文本的关闭结果替换捕获的组的所有出现。 17 center() 创建一个与此String相反的新字符串。 18 split() 将此String拆分为给定正则表达式的匹配项。 19 subString() 返回一个新的String，它是此String的子字符串。 20 toUpperCase() 将此字符串中的所有字符转换为大写。 21 toLowerCase() 将此字符串中的所有字符转换为小写。 Groovy - Optionally:Groovy是一个“Optionally”类型的语言，当理解语言的基本原理时，这种区别是一个重要的语言。与Java相比，Java是一种“强”类型的语言，由此编译器知道每个变量的所有类型，并且可以在编译时理解和尊重合同。这意味着方法调用能够在编译时确定。 当在Groovy中编写代码时，开发人员可以灵活地提供类型或不是类型。这可以提供一些简单的实现，并且当正确利用时，可以以强大和动态的方式为您的应用程序提供服务。 在Groovy中，可选的键入是通过’def’关键字完成的。示例代码： 12345678910111213141516171819class Example &#123; static void main(String[] args) &#123; // Example of an Integer using def def a = 100; println(a); // Example of an float using def def b = 100.10; println(b); // Example of an Double using def def c = 100.101; println(c); // Example of an String using def def d = "HelloWorld"; println(d); &#125; &#125; 从上面的程序，我们可以看到，我们没有声明单个变量为Integer，float，double或string，即使它们包含这些类型的值。 运行结果: 1234100 100.10 100.101HelloWorld 可选的打字在开发期间可以是一个强大的实用程序，但是当代码变得太大和复杂时，可能导致在后期开发阶段的可维护性问题。 要了解如何使用Groovy中的可选输入，而不让代码库陷入无法维护的混乱，最好在应用程序中采用“鸭式输入”的理念。 如果我们使用鸭式重写上面的代码，它将看起来像下面给出的。变量名称的名称比它们代表的类型更多，这使得代码更容易理解。 12345678910111213141516171819class Example &#123; static void main(String[] args) &#123; // Example of an Integer using def def aint = 100; println(aint); // Example of an float using def def bfloat = 100.10; println(bfloat); // Example of an Double using def def cDouble = 100.101; println(cDouble); // Example of an String using def def dString = "HelloWorld"; println(dString); &#125; &#125; 参考资料：https://www.tutorialspoint.com/groovy/groovy_loops.htm https://www.tutorialspoint.com/groovy/groovy_numbers.htm https://www.tutorialspoint.com/groovy/groovy_strings.htm]]></content>
      <categories>
        <category>Groovy</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Groovy</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『JVM语言 - Groovy』基础(一)]]></title>
    <url>%2F2017%2F09%2F18%2Fgroovy-basic-1%2F</url>
    <content type="text"><![CDATA[前言：本文讲解了 Groovy语言中的基本语法，数据类型，变量和运算符，与 Java 一致的内容则不再赘述。 Groovy - 基本语法：HelloWorld：示例代码： 12345class Example&#123; static void main (String [] args)&#123; println('hello world') &#125;&#125; 跟 java代码不同的是，省略了 public 关键字，还有输出语句的前缀。 import：import 的使用与 Java 中并无太大区别，默认情况下 Groovy在代码中包含了一下类库，可以直接使用，不需要显示导入。 示例代码： 12345678910import java.lang.* import java.util.* import java.io.* import java.net.* import groovy.lang.* import groovy.util.* import java.math.BigInteger import java.math.BigDecimal Keywords: 关键词： 关键词： 关键词： 关键词： 关键词： as assert break case while catch class const continue def default do else enum extends false finally for goto if implements import in instanceof interface new null package return super switch this throw throws trait true try Comments:分单行注释和多行注释，与 Java 无异。 单行：// 多行：/ / Groovy - 数据类型：内置数据类型：Groovy提供多种内置数据类型。以下是在Groovy中定义的数据类型的列表： byte -这是用来表示字节值。例如2。 short -这是用来表示一个短整型。例如10。 int -这是用来表示整数。例如1234。 long -这是用来表示一个长整型。例如10000090。 float -这是用来表示32位浮点数。例如12.34。 double -这是用来表示64位浮点数，这些数字是有时可能需要的更长的十进制数表示。例如12.3456565。 char -这定义了单个字符文字。例如“A”。 Boolean -这表示一个布尔值，可以是true或false。 String -这些是以字符串的形式表示的文本。例如，“Hello World”的。 绑定值：下表显示了数字和小数点文字中的最大允许值。 数据类型 值 byte -128到127 short -32,768到32,767 int 2,147,483,648 到,147,483,647 long -9,223,372,036,854,775,808到+9,223,372,036,854,775,807 float 1.40129846432481707e-45到3.40282346638528860e + 38 double 4.94065645841246544e-324d 到1.79769313486231570e + 308d 包装类：类型除了基本类型，还允许以下对象类型（有时称为包装器类型）： java.lang.Byte java.lang.Short java.lang.Integer java.lang.Long java.lang.Float java.lang.Double 此外，以下类可用于支持高精度计算: 名称 描述 例如 java.math.BigInteger 不可变的任意精度的有符号整数数字 30克 java.math.BigDecimal 不可变的任意精度的有符号十进制数 3.5克 以下代码示例说明如何使用不同的内置数据类型 ,示例代码： 12345678910111213141516171819202122232425262728class Example &#123; static void main(String[] args) &#123; //Example of a int datatype int x = 5; //Example of a long datatype long y = 100L; //Example of a floating point datatype float a = 10.56f; //Example of a double datatype double b = 10.5e40; //Example of a BigInteger datatype BigInteger bi = 30g; //Example of a BigDecimal datatype BigDecimal bd = 3.5g; println(x); println(y); println(a); println(b); println(bi); println(bd); &#125; &#125; 当我们运行上面的程序，我们会得到以下结果,示例代码： 1234565 100 10.56 1.05E41 30 3.5 Groovy - 变量：Groovy中的变量可以通过两种方式定义 - 使用数据类型的本地语法，或者使用def关键字。对于变量定义，必须明确提供类型名称或在替换中使用“def”。这是Groovy解析器需要的。 声明&amp;命名:变量声明告诉编译器为变量创建存储的位置和大小。变量的名称可以由字母，数字和下划线字符组成。 必须以字母或下划线开头。 大写和小写字母是不同的，因为Groovy，就像Java是一种区分大小写的编程语言，在变量声明命名上与 Java 无异。 示例代码： 12345678910111213class Example &#123; static void main(String[] args) &#123; int x = 5; double X = 6.67; def _Website = "object.ws"; println(x); println(X); println(_Website); &#125; &#125; Groovy - 运算符：按位运算符： 符号 描述 运算规则 &amp; 与 两位都为1，那么结果为1 丨 或 有一位为1，那么结果为1 ~ 非 ~0 =1，~1=0 ^ 异或 两位不相同 结果为1 &lt;&lt; 左移 各二进位全部左移若干位，高位丢弃，低位补0 &gt;&gt; 右移 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位(算术右移)，有的补0(逻辑右移) 示例代码： p q p＆q p 丨 q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 Groovy中并没有”&gt;&gt; &lt;&lt;” 右移和左移运算符，这里再查询资料时对按位运算符做以补充。 范围运算符：Groovy支持范围的概念，并在..符号的帮助下提供范围运算符的符号。下面给出了范围运算符的一个简单示例。 1def range = 0..5 这只是定义了一个简单的整数范围，存储到一个局部变量称为范围内的下限为0和上限为5。 以下代码段显示了如何使用各种运算符。 1234567class Example &#123; static void main(String[] args) &#123; def range = 5..10; println(range); println(range.get(2)); &#125; &#125; 当我们运行上面的程序，我们会得到以下结果 : 从println语句中，可以看到显示在range语句中定义的整个数字范围。 get语句用于从定义的范围中获取一个对象，它将索引值作为参数。 12[5, 6, 7, 8, 9, 10] 7 成员运算符in相当于inCase方法，当用在列表上时，相当于调用列表的contains方法： 123def list = ['Grace', 'Rob', 'Emmy']// assert ('Emmy' in list) // 相当于list.contains('Emmy')或list.isCase('Emmy')println list 身份运算符：在Groovy中==相当于调用equals方法，如果要判断两个对象是否是同一个，需要使用is： 1234def list1 = ['Groovy 1.8', 'Groovy 2.0', 'Groovy 2.3']def list2 = ['Groovy 1.8', 'Groovy 2.0', 'Groovy 2.3']assert list1 == list2 // 相当于list.equals(list2)assert !list1.is(list2) 运算符重载：Groovy中支持运算符重载，其实也就是实现约定好的方法： 12345678910111213class Bucket &#123; int size Bucket(int size) &#123; this.size = size &#125; Bucket plus(Bucket other) &#123; // 重载这个以实现+操作 return new Bucket(this.size + other.size) &#125;&#125;def b1 = new Bucket(4)def b2 = new Bucket(11)assert (b1 + b2).size == 15 // 这里相当于(b1.plus(b2)).size 参考资料：Groovy-基本语法： http://www.groovy-lang.org/syntax.html https://www.tutorialspoint.com/groovy/groovy_basic_syntax.htm Groovy-数据类型： https://www.tutorialspoint.com/groovy/groovy_data_types.htm Groovy-运算符： http://www.groovy-lang.org/operators.html#_coercion_operator https://www.tutorialspoint.com/groovy/groovy_operators.htm]]></content>
      <categories>
        <category>Groovy</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Groovy</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『JVM语言 - Groovy』简介]]></title>
    <url>%2F2017%2F09%2F15%2Fgroovy-introduction%2F</url>
    <content type="text"><![CDATA[Groovy - 概述：Apache Groovy是一种强大的，可选的类型化和动态 语言，具有静态类型和静态编译功能，适用于Java平台，旨在通过简洁，熟悉和易于学习的语法来提高开发人员的工作效率。它与任何Java程序平滑地集成，并立即向您的应用程序提供强大的功能，包括脚本功能，域专用语言创作，运行时和编译时元编程和功能编程。 Groovy - 版本:Groovy是基于Java平台的面向对象语言。Groovy 1.0于2007年1月2日发布，Groovy 2.4是当前的主要版本。Groovy通过Apache License v 2.0发布。 Groovy - 特点:Groovy具有以下功能: 支持静态和动态类型。 支持操作员重载。 列表和关联数组的本机语法。 本地支持正则表达式。 支持各种标记语言，如XML和HTML。 Groovy对于Java开发人员来说很简单，因为Java和Groovy的语法非常相似。 您可以使用现有的Java库。 Groovy扩展了java.lang.Object。 Groovy - 下载安装：系统要求：http://www.groovy-lang.org/download.html#requirements 基于 HomeBrew：示例代码： 1brew install groovy 基于 SDKMAN：这个工具使得在任何Bash平台上安装Groovy（Mac OSX，Linux，Cygwin，Solaris或FreeBSD）非常简单。只需打开一个新的终端并输入： 1$ curl -s get.sdkman.io | bash 按照屏幕上的说明完成安装。打开一个新的终端或键入命令： 1$ source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot; 然后安装最新的稳定Groovy： 1$ sdk install groovy 安装完成后，您已将其设为默认版本，请使用以下命令进行测试： 1$ groovy -version 基于 MacPorts：示例代码： 1sudo port install groovy Groovy - 与 Java 的区别:默认导包：下面这些包会由Groovy默认导入，我们不需要手动导入这些包就可以直接使用其中的类。 java.io.* java.lang.* java.math.BigDecimal java.math.BigInteger java.net.* java.util.* groovy.lang.* groovy.util.* 多方法：Groovy的方法调用时机在运行时决定，这叫做运行时分发或者多方法。下面是一个例子。 12345678int method(String arg) &#123; return 1;&#125;int method(Object arg) &#123; return 2;&#125;Object o = "Object";int result = method(o);12345678 在Java中下面的断言是成功的。 1assertEquals(2, result);1 在Groovy中下面的断言是成功的。 1assertEquals(1, result);1 在Java中由于方法调用时编译期决定的，而o的类型是Object，所以会返回2。而Groovy是在运行时决定方法调用的，由于对象的实际类型是字符串，所以会返回1。 数组初始化：由于在Groovy中花括号用作闭包声明，因此数组初始化需要使用方括号。 12345//java中合法，Groovy不能int[] array = &#123; 1, 2, 3&#125;//Groovy正确的声明方式int[] array = [1,2,3] 包访问权限：在Java中不带访问修饰符的字段默认是包可见的。在Grooy中默认是私有的。如果希望在Groovy中设置包访问权限。可以使用@PackageScope注解。 123class Person &#123; @PackageScope String name&#125; 自动资源管理：Java7中引入了自动资源管理功能，可以以较简便的方式打开和释放资源。在Groovy中，闭包让这些工作更简单。下面是一段Java代码。 1234567891011Path file = Paths.get("/path/to/file");Charset charset = Charset.forName("UTF-8");try (BufferedReader reader = Files.newBufferedReader(file, charset)) &#123; String line; while ((line = reader.readLine()) != null) &#123; System.out.println(line); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125;1234567891011 对应的Groovy代码非常简单。 123new File('/path/to/file').eachLine('UTF-8') &#123; println it&#125;123 或者还可以使用折中方式。 12345new File('/path/to/file').withReader('UTF-8') &#123; reader -&gt; reader.eachLine &#123; println it &#125;&#125; Lambda:Java 8 支持Lambda表达式，不过Groovy不支持。Groovy支持闭包。 12Runnable run = () -&gt; System.out.println("Run");list.forEach(System.out::println);12 对应的Groovy代码。 12Runnable run = &#123; println 'run' &#125;list.each &#123; println it &#125; // or list.each(this.&amp;println) GString:Groovy通过GString来支持内插字符串。如果在单引号字符串中发现${}，会发生编译错误。另外Groovy可以自动将GString转换为String，所以我们可以放心的引用各种Java类库。 字符串和字符常量:Groovy中单引号用作字符串常量，所以我们没办法声明一个字符常量。如果需要单个字符，我们必须显式声明一个字符变量，然后用单引号将字符赋给它。 1char a='a'1 对于字符串和字符之间的转换，也有两种方式：Groovy的as运算符和传统的Java转换方式。但是假如单引号之间是一个字符串，这两种转换方式就不一样了。Java转换会抛出异常，而Groovy方式会获取字符串的第一个字母作为转换后的字符。 123456789101112// for single char strings, both are the sameassert ((char) "c").class==Characterassert ("c" as char).class==Character// for multi char strings they are nottry &#123; ((char) 'cx') == 'c' assert false: 'will fail - not castable'&#125; catch(GroovyCastException e) &#123;&#125;assert ('cx' as char) == 'c'assert 'cx'.asType(char) == 'c'123456789101112 基本类型和包装器:Groovy是完全对象化的，所以所有基本类型都会转换为其包装器来使用。Groovy不支持Java的扩宽优先于包装器的规则。因此下面的代码，在Java中会执行第一个m方法，在Groovy中会执行第二个m方法。 12345678910int im(i)void m(long l) &#123; println "in m(long)"&#125;void m(Integer i) &#123; println "in m(Integer)"&#125;12345678910 相等运算符的行为:Java中==会比较对象引用是否是同一个。而在Groovy中，如果对象实现了Comparable，就会调用a.compareTo(b)==0方法；如果没有实现，则调用a.equals(b)。如果需要判断对象引用，可以使用is函数，a.is(b)。 额外的关键字:Groovy中还有一些关键字，而不是Java。不要将它们用于变量名称等 as def in trait Reference：http://www.groovy-lang.org/differences.html 参考资料：http://www.groovy-lang.org/ https://www.tutorialspoint.com/groovy/index.htm]]></content>
      <categories>
        <category>Groovy</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Groovy</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用 Now.sh来免费部署你的项目？]]></title>
    <url>%2F2017%2F09%2F10%2Fnowsh-note%2F</url>
    <content type="text"><![CDATA[前言 ZEIT：Our Mission，Make Cloud Computing as Easy and Accessible as Mobile computing. ZEIT是美国 (域名Ip指向美国华盛顿州西雅图市)一家提供云部署服务的公司，旗下的 Now.sh提供了Realtime global deployments(全球化实时部署)服务。 Now.sh 提供了免费的OSS 服务，配置如下： 名称 配置 带宽 1GB* 日志 100MB* 部署 ∞ 并发实例 3 域 - † MAX文件大小/存储空间 1MB / 1GB 自动增长支持 不支持 团队协作人数 支持 图例： *超出此限额时，您需支付“按需”的价格。服务不中断，不会造成停机。 †对于某些开源项目，我们赞助了自定义域的支持。请联系我们，以确定您是否适用。 ‡在免费计划中，您的代码将是公开的和开源的，可通过所有部署的路径URL提供。/_src Reference：https://zeit.co/pricing Now.sh - 简介：now allows you to take your JavaScript (Node.js) or Docker powered websites, applications and services to the cloud with ease, speed and reliability. In practical terms, any directory that contains a package.json or Dockerfile can be transported to the cloud with one command: now. Every time you deploy a project, now will provide you with a new, unique URL (even before the upload has finished). These URLs will look like this (my-app is your automatically determined application name): my-app-erkgfjtrna.now.sh. When it’s time to take your deployment to production, you simply pick an appropriate alias (a custom domain). Reference：https://zeit.co/now#whats-now Now.sh - 安装：基于客户端进行安装：客户端下载地址：https://zeit.co/download 安装过程就不一一赘述了，因为我也没安装过。我觉得使用homebrew或npm之类的工具安装使用会更方便一些。 基于 npm 进行安装：示例代码： 123456789101112➜ npm install -g now/usr/local/bin/now -&gt; /usr/local/lib/node_modules/now/download/dist/now&gt; now@8.2.2 postinstall /usr/local/lib/node_modules/now&gt; node download/install.js&gt; For the source code, check out: https://github.com/zeit/now-cli&gt; Downloading now CLI 8.2.2 [====================] 100%+ now@8.2.2added 1 package in 15.18s 如果你还不会使用 npm (Node Package Manager)，请翻阅之前发布的 npm使用教程。 Reference:https://www.npmjs.com/package/now Now.sh - CLI:以下是所有可用命令的完整列表，以及您可以使用的命令和您每天工作时应记住的命令： Syntax Description now deploy [path] 使用此命令时，当前目录中的文件将被上传到now.sh，并将创建一个新的部署。之后，您将立即收到其网址，以便与全球其他人分享。 now ls\list [app] 显示所有部署的列表。如果被定义，它将仅列出该命名空间下的部署。 now rm\remove [id] 从now.sh平台中删除部署。该参数可以是您之前的部署的URL或主机名。 now ln\alias [id] [url] 在现有部署上配置别名或自定义域名。 now domains [name] 允许您直接从命令行管理域名。 now certs [cmd] 默认情况下，now.sh将自动为您的部署配置证书。使用此子命令，您可以看到他们何时到期。 now secrets [name] 如果您需要将敏感信息存储在只能由其中运行的代码访问的部署上。这可以通过使用它来实现，它允许您以安全的方式存储应用程序所需的功能（如API令牌或密码） now dns [name] 列出使用zeit.world为域创建的所有DNS记录。该列表不包括由名称服务器自动生成的记录（如默认记录，为记录自动创建的记录等）。SOA``A / AAAA``ALIAS now open 运行此子命令将在默认浏览器的当前目录中打开项目的最新部署（别名此时无效） now billing\cc 轻松添加或删除帐户中的信用卡，并调整结算方式。 now upgrade\downgrade [plan] 从命令行界面切换您的计划。即使命令运行后，我们也不要求您使用Web界面。整个过程直接发生在你的终端上。 now help 显示终端中的子命令和选项列表 now login 登录你的 ZEIT账户 Reference：https://zeit.co/docs/features/now-cli Now.sh - 使用：要使用 Now.sh就必须要再 https://zeit.co 注册一个账户，只需要输入你的邮箱就好了，然后在本地进行认证，认证过程中需要输入你注册时所用的邮箱，然后打开邮箱点击链接进行认证。 示例代码： 123456➜ ~ now login&gt; We sent an email to youremail@gmail.com. Please follow the steps provided inside it and make sure the security code matches Silly Water Buffalo.✔ Email confirmed✔ Fetched your personal details&gt; Ready! Authentication token and personal details saved in "~/.now" 邮件内容： 12345678Hi!Login attempt from Shenzhen, ChinaVerify that the provided security code matches Confident African Civetbefore proceeding. Then please follow this link to verify your email address. Now.sh - 部署： Now.sh is free for open-source projects and static deployments. It supports Dockerfile, package.json and static sites out of the box. All builds are reproducible and executed in the cloud. 译：Now.sh对于开源项目和静态部署是免费的。它支持Dockerfile，package.json和静态网站开箱即用。所有的构建都是可重现的，并在云中执行。 现在你可以使用now命令来部署任何 web应用程序，现在 Now.sh 支持三种类型的部署： Static - 静态网页应用 Node.js - Node.js 应用 Docker - Docker应用(适用于所有其他应用) Static 部署：通过静态部署，可以将本地资源部署到 Now.sh 上，需要部署请访问应用程序目录并运行此命令： 1➜ yourproject/ now 如果你的静态 web 项目中包含index.html文件，则项目可正常显示，否则只会显示文件和文件夹(用来做 ftp 服务器也不错)。 For all static deployments, you will be charged only for the bandwidth. You do not pay for computing resources and storage. 对于所有静态部署，您将仅为带宽收费。您不支付计算资源和存储空间。 Node.js 部署:如果您的应用程序目录中有一个package.json文件，那么Now.sh会认为有效的Node.js部署。这是一个简单的Node.js部署在微服务的帮助下。 Node.js 应用必须要用以下两个文件才能被 Now.sh 识别。 index.js示例代码： 123module.exports = () =&gt; (&#123; date: new Date&#125;) package.json示例代码： 12345678910&#123; "name": "get-started-node", "version": "0.1.0", "dependencies": &#123; "micro": "latest" &#125;, "scripts": &#123; "start": "micro" &#125;&#125; 然后要部署此应用程序，请访问应用程序根目录并运行此命令： 1➜ yourproject/ now Docker 部署：如果您的应用程序目录包含一个Docker文件，那么现在考虑一个有效的Docker部署。它将基于Dockerfile构建一个docker映像，并基于此启动容器。 要部署一个简单的Go HTTP服务器，创建一个目录并添加这两个文件： hello.go示例代码： 1234567891011121314151617package mainimport ( "io" "net/http")func main() &#123; http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) &#123; io.WriteString(w, "Hello world!") &#125;) err := http.ListenAndServe(":8000", nil) if err != nil &#123; panic(err) &#125;&#125; Dockerfile示例代码： 12345FROM golang:alpineADD . /go/src/zeit/helloRUN go install zeit/helloCMD ["/go/bin/hello"]EXPOSE 8000 部署总结：项目在部署完成之后，我们会得到一个链接，可以通过这个链接来访问部署的项目。 123456789101112➜ Index now&gt; Deploying ~/WorkDir/Index under usrename&gt; Warning! Skipping file /Users/Uname/WorkDir/Index/img/background.jpg (size exceeded 1MB)&gt; Warning! 1 of the files exceeded the limit for your plan.&gt; Please run `now upgrade` to upgrade.&gt; Ready! https://index-xxxxxxxxx.now.sh (copied to clipboard) [2s]&gt; You (Username) are on the OSS plan. Your code and logs will be made public.&gt; NOTE: You can use `now --public` to skip this prompt&gt; Synced 3 files (877.42KB) [41s]&gt; Initializing…&gt; Deployment complete! 每次更新部署后， url 都会生成一个新的，但是老的 url 都还是可以用的。如果最终网站要产品化，可以很容易的绑定自己的域名。 Reference： https://zeit.co/docs/getting-started/deployment Now.sh - 域名：当我们部署完应用程序的时，Now.sh 会为我们生成一个唯一部署URL，如果我们修改项目后进行多次部署，Now.sh 会生成多个 URL 为我们的项目，使用这些特定的 URL 可以访问不同版本的应用，但是这些URL 不容易记住，每次部署新版本都会更新地址，因此我们需要一个固定的域名。我们将使用now alias命令将域名映射到应用的其中一个部署URL。 需要说明的是，自定义域仅适用于付费计划。如果您要为自己的应用使用自定义域，则需要升级您的帐户。具体价格请参考：https://zeit.co/pricing 使用now alias命令的四种不同的方法是： 使用now.sh提供的域名 使用now.sh管理的自定义域名 使用自定义域，由now管理的DNS 使用带有CNAME的自定义域名 使用now.sh提供的域名这种方法是使用域名的最简单方法。要立即使用now.sh 后缀获取域名，只需运行以下命令即可，示例代码 ： 1$ now alias https://my-web-app-avvuiuuwto.now.sh my-web-app 现在可以使用https://my-web-app.now.sh来访问部署的项目。 ###使用now.sh管理的自定义域 如果您想为自己的应用使用自定义域，最简单的方法是使用now为您的应用购买域名。 只需运行以下alias命令，示例代码： 1$ now alias https://my-web-app-avvuiuuwto.now.sh my-web-app.com 在这里，我们正在尝试将my-web-app.com域名分配给上述部署URL。如果域名可用，您可以在不离开终端的情况下确认并购买。 确认后，现在将处理您的所有技术细节，并允许您的用户使用https://my-web-app.com访问您的应用程序。 在这个过程中，now.sh将为我们的域名设置一个域加密SSL证书。 使用自定义域，由Now管理的DNS如果您已经有域名，这是您最好的选择。使用此方法，现在将处理您的域名的所有DNS管理。 首先，您需要将域名的域名服务器指向我们的全球DNS服务。这是怎么做到的: 访问您的域名提供商，并找到可以添加自定义nameserver的地方。 从此列表中选择两个或多个nameservers。 将now.sh 提供的nameserver设置为您的自定义域名的nameserver。 这里呢需要将我们购买的域名的解析权交给 now 来做，本网站域名再 godaddy购买，然后将其解析权交给 Dnspod ，使用管理起来更方便，跟 now.sh 原理一致。 例如，假设您的域名是my-custom-domain.com,设置name后，只需运行以下alias命令： 1$ now alias https://my-web-app-avvuiuuwto.now.sh my-custom-domain.com 然后，您可以使用https://my-custom-domain.com访问您的应用程序。 您也可以使用my-custom-domain.com的子域，如下所示： 1$ now alias https://my-web-app-avvuiuuwto.now.sh ui.my-custom-domain.com 在这个过程中，now.sh将为我们的域名设置一个域加密SSL证书。 Reference：Godaddy注册的域名如何使用DNSPod？ Reference：now.sh 提供的 Nameservers 使用带有CNAME的自定义域名如果您正在管理您的域名的DNS设置，您可以使用此选项。 例如，假设您有一个名为my-app.work的域名，并且您已经有一个DNS设置。要映射应用程序的一个部署URL的 ui.my-app.work 域名，请访问您的DNS提供程序，并为ui.my-app.work添加指向alias.zeit.co的CNAME记录。之后，运行以下命令： 1$ now alias https://my-web-app-avvuiuuwto.now.sh ui.my-app.work 现在您可以使用https://ui.my-app.work访问您的应用程序。 Reference：https://zeit.co/docs/getting-started/assign-a-domain-name Now.sh - 日志：日志很重要，因为它可以让您看到应用程序中发生的情况，尤其是在发生异常时。now可以保存所有部署的日志，并允许您搜索它们，让我们来看看如何访问日志： 通过CLI：通过现在的CLI访问日志很简单，调用这个命令： 1$ now logs [deployment-url] 您还可以使用应用的域名来搜索日志： 1$ now logs my-web-app.com 有关now日志的更多信息，请运行help命令： 1$ now logs --help 这是一个预先查看 now的日志命令，让您检查最后10个HTTP GET请求: 1$ now logs -a -q "GET" -n 10 my-web-app.com 通过Dashboard：您还可以通过您的Web信息板访问和搜索日志，网址为https://zeit.co/dashboard。 单击信息中心内的任何部署URL，然后开始搜索日志。 Reference：https://zeit.co/docs/getting-started/logs Now.sh - 注意事项：使用 Now.sh来部署应用的优势： 自带的 https 真正的一键部署，不用自己管理服务器，将 severless 进行到底 不翻墙，访问速度很棒 其他注意事项： 为了节省资源，应用一段时间不用就会被 frozen （冻结），但是只要我们去敲链接去访问，就会自动 unfrozen ，只不过初次访问速度会受影响。 在 Now.sh提供的免费服务中，您的代码将是公开的和开源的，如果介意可升级账户或放弃使用。 参考资料： ZEIT-官网 ZEIT-Github ZEIT-Twitter Github Now-CLI NpmJS Now Asynchronous HTTP microservices]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Now.sh</tag>
        <tag>Deployments</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『构建工具-Gradle』相关内容整理]]></title>
    <url>%2F2017%2F09%2F02%2Fgradle-node%2F</url>
    <content type="text"><![CDATA[Gradle - 简介：Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。 当前其支持的语言限于Java、Groovy和Scala，计划未来将支持更多的语言。Gradle，这是一个构建系统(工具)，我们认为这是Java（JVM）世界中构建技术的巨大飞跃。 Gradle提供了： 一个非常灵活的通用构建工具，如Ant。 一种可切换的，像 maven 一样的基于约定约定优于配置的构建框架 强大的多工程构建支持 强大的依赖管理(基于 ApacheIvy) 对已有的 maven 和 ivy 仓库的全面支持 支持传递性依赖管理，而不需要远程仓库或者 pom.xml 或者 ivy 配置文件 ant 式的任务和构建是 gradle 的第一公民 基于 groovy，其 build 脚本使用 groovy dsl 编写 具有广泛的领域模型支持你的构建 Reference：https://docs.gradle.org/4.1/userguide/introduction.html Gradle - 概述：基于声明的构建和基于约定的构建Gradle的核心是基于Groovy的丰富的可扩展的域特定语言（DSL）。Gradle通过提供可以根据需要进行组合的声明性语言元素将声明式构建推送到一个新的层次。这些元素还为Java，Groovy，OSGi，Web和Scala项目提供了逐个常规的支持。更重要的是，这种声明性语言是可扩展的。添加您自己的新语言元素或增强现有的元素，从而提供简洁，可维护和易于理解的构建。 为以依赖为基础的编程方式提供语言支持声明性语言优点在于通用任务图，你可以将其充分利用在构建中. 它提供了最大限度的灵活性，以让 Gradle 适应你的特殊需求。 构建结构化Gradle 的灵活和丰富性最终能够支持在你的构建中应用通用的设计模式。 例如，它可以很容易地将你的构建拆分为多个可重用的模块，最后再进行组装，但不要强制地进行模块的拆分。 不要把原本在一起的东西强行分开（比如在你的项目结构里），从而避免让你的构建变成一场噩梦。 最后，你可以创建一个结构良好，易于维护，易于理解的构建。 深度 APIGradle 允许你在构建执行的整个生命周期，对它的核心配置及执行行为进行监视并自定义。 Gradle 的扩展Gradle 有非常良好的扩展性。 从简单的单项目构建，到庞大的多项目构建，它都能显著地提升你的效率。 这才是真正的结构化构建。通过最先进的增量构建功能，它可以解决许多大型企业所面临的性能瓶颈问题。 多项目构建Gradle 对多项目构建的支持非常出色。项目依赖是首先需要考虑的问题。 我们允许你在多项目构建当中对项目依赖关系进行建模，因为它们才是你真正的问题域。 Gradle 遵守你的布局。 Gradle 提供了局部构建的功能。 如果你在构建一个单独的子项目，Gradle 也会帮你构建它所依赖的所有子项目。 你也可以选择重新构建依赖于特定子项目的子项目。 这种增量构建将使得在大型构建任务中省下大量时间。 多种方式管理依赖不同的团队喜欢用不同的方式来管理他们的外部依赖。 从 Maven 和 Ivy 的远程仓库的传递依赖管理，到本地文件系统的 jar 包或目录，Gradle 对所有的管理策略都提供了方便的支持。 Gradle 是第一个构建集成工具Ant tasks 是最重要的。而更有趣的是，Ant projects 也是最重要的。 Gradle 对任意的 Ant 项目提供了深度导入，并在运行时将 Ant 目标(target)转换为原生的 Gradle 任务(task)。 你可以从 Gradle 上依赖它们(Ant targets)，增强它们，甚至在你的 build.xml 上定义对 Gradle tasks 的依赖。Gradle 为属性、路径等等提供了同样的整合。 Gradle 完全支持用于发布或检索依赖的 Maven 或 Ivy 仓库。 Gradle 同样提供了一个转换器，用于将一个 Maven pom.xml 文件转换为一个 Gradle 脚本。Maven 项目的运行时导入的功能将很快会有。 易于移植Gradle 能适应你已有的任何结构。因此，你总可以在你构建项目的同一个分支当中开发你的 Gradle 构建脚本，并且它们能够并行进行。 我们通常建议编写测试，以保证生成的文件是一样的。 这种移植方式会尽可能的可靠和减少破坏性。这也是重构的最佳做法。 GroovyGradle 的构建脚本是采用 Groovy 写的，而不是用 XML。 但与其他方法不同，它并不只是展示了由一种动态语言编写的原始脚本的强大。 那样将导致维护构建变得很困难。 Gradle 的整体设计是面向被作为一门语言，而不是一个僵化的框架。 并且 Groovy 是我们允许你通过抽象的 Gradle 描述你个人的 story 的黏合剂。 Gradle 提供了一些标准通用的 story。这是我们相比其他声明性构建系统的主要特点。 我们的 Groovy 支持也不是简单的糖衣层，整个 Gradle 的 API 都是完全 groovy 化的。只有通过 Groovy才能去运用它并对它提高效率。 The Gradle wrapperGradle Wrapper 允许你在没有安装 Gradle 的机器上执行 Gradle 构建。 这一点是非常有用的。比如，对一些持续集成服务来说。 它对一个开源项目保持低门槛构建也是非常有用的。 Wrapper 对企业来说也很有用，它使得对客户端计算机零配置。 它强制使用指定的版本，以减少兼容支持问题。 自由和开源Gradle 是一个开源项目，并遵循 ASL 许可。 Reference：https://docs.gradle.org/4.1/userguide/overview.html Gradle - 安装：关于 Gradle 的安装官网上为我们提供了非常详细的过程，如果你使用的是 MacOS，那么建议使用 Homebrew 进行安装，简单快捷。 1234567891011121314➜ ~ brew install gradle # 安装Gradle➜ ~ gradle -v # 查看版本信息------------------------------------------------------------Gradle 4.1------------------------------------------------------------Build time: 2017-08-07 14:38:48 UTCRevision: 941559e020f6c357ebb08d5c67acdb858a3defc2Groovy: 2.4.11Ant: Apache Ant(TM) version 1.9.6 compiled on June 29 2015JVM: 1.8.0_121 (Oracle Corporation 25.121-b13)OS: Mac OS X 10.12.6 x86_64 配置Gradle的环境变量： 1GRADLE_HOME=/usr/local/gradle Reference：https://docs.gradle.org/4.1/userguide/installation.html Gradle - 构建基础：Projects &amp; tasks:projects 和 tasks是 Gradle 中最重要的两个概念。 任何一个 Gradle 构建都是由一个或多个 projects 组成。每个 project 包括许多可构建组成部分。 这完全取决于你要构建些什么。举个例子，每个 project 或许是一个 jar 包或者一个 web 应用，它也可以是一个由许多其他项目中产生的 jar 构成的 zip 压缩包。一个 project 不必描述它只能进行构建操作。它也可以部署你的应用或搭建你的环境。不要担心它像听上去的那样庞大。 Gradle 的 build-by-convention 可以让您来具体定义一个 project 到底该做什么。 每个 project 都由多个 tasks 组成。每个 task 都代表了构建执行过程中的一个原子性操作。如编译，打包，生成 javadoc，发布到某个仓库等操作。 build.gradle文件：示例代码： 12345task hello &#123; doLast &#123; println 'Hello world!' &#125;&#125; 在命令行里, 进入脚本所在的文件夹然后输入 gradle -q hello 来执行构建脚本，示例代码： 1gradle -q hello Hello world! 这里发生了什么? 这个构建脚本定义了一个独立的 task, 叫做 hello, 并且加入了一个 action. 当你运行 gradle hello, Gradle 执行叫做 hello 的 task, 也就是执行了你所提供的 action. 这个 action 是一个包含了一些 Groovy 代码的闭包(closure 这个概念不清楚的同学好好谷歌下). 如果你认为这些看上去和 Ant 的 targets 很相像, 好吧, 你是对的. Gradle tasks 和 Ant 的 targets 是对等的. 但是你将会会看到, Gradle tasks 更加强大. 我们使用一个不同于 Ant 的术语 task, 看上去比 target 更加能直白. 不幸的是这带来了一个术语冲突, 因为 Ant 称它的命令, 比如 javac 或者 copy, 叫 tasks. 所以当我们谈论 tasks, 是指 Gradle 的 tasks. 如果我们讨论 Ant 的 tasks (Ant 命令), 我们会直接称呼 ant task. -q. 代表 quite 模式. 它不会生成 Gradle 的日志信息 (log messages), 所以用户只能看到 tasks 的输出. 它使得的输出更加清晰. 你并不一定需要加入这个选项. Gradle - 构建项目：创建项目目录：示例代码： 12➜ ~ mkdir gradle-app➜ ~ cd gradle-app 使用 Gradle Wrapper构建：示例代码： 1234➜ gradle-app gradle wrapperBUILD SUCCESSFUL in 0s1 actionable task: 1 executed 以下是 Gradle Wrapper 生成的文件。 示例代码： 12345678910➜ gradle-app tree.├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew└── gradlew.bat2 directories, 4 files gradlew : 这是一个可执行文件，应用于运行gradle构建任务 gradlew.bat : 同上，运行再 windows/doc 平台。 gradle/wrapper/gradle-wrapper.properties ：gradle包装器配置文件 gradle-wrapper.properties：示例代码： 123456➜ gradle-app cat gradle/wrapper/gradle-wrapper.propertiesdistributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\://services.gradle.org/distributions/gradle-4.1-bin.zip 初始化你创建的项目：示例代码： 12345678910➜ gradle-app ./gradlew initDownloading https://services.gradle.org/distributions/gradle-4.1-bin.zip................................................................Unzipping /Users/UName/.gradle/wrapper/dists/gradle-4.1-bin/c3kp51zwwt108wc78u68yt7vs/gradle-4.1-bin.zip to /Users/UName/.gradle/wrapper/dists/gradle-4.1-bin/c3kp51zwwt108wc78u68yt7vsSet executable permissions for: /Users/UName/.gradle/wrapper/dists/gradle-4.1-bin/c3kp51zwwt108wc78u68yt7vs/gradle-4.1/bin/gradleBUILD SUCCESSFUL in 18s2 actionable tasks: 1 executed, 1 up-to-date 现在可以再次查看下项目： 123456789101112➜ gradle-app tree.├── build.gradle├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew├── gradlew.bat└── settings.gradle2 directories, 6 files 相较于之前，则多了build.gradle和settings.gradle两个文件。 build.gradle:123456789101112131415161718192021222324252627282930/* * 此构建文件是由Gradle'init'任务生成的。 * * 这个生成的文件包含一个注释掉的示例Java项目，让你开始。 * 有关更多详细信息，请参阅Gradle中的Java Quickstart一章 * 用户指南可在https://docs.gradle.org/4.1/userguide/tutorial_java_projects.html *//*// 应用 JAVA 插件来添加项目对 JAVA 的支持apply plugin: 'java'// 此处可以声明在何处找到项目的依赖关系repositories &#123; //项目空间引用远程仓库--- jcenter(),您可以在这里声明任何Maven / Ivy /文件库。 jcenter()&#125;// 声明生产和测试代码的依赖关系dependencies &#123; // 生产代码在编译时使用SLF4J logging API compile 'org.slf4j:slf4j-api:1.7.25' // 声明您希望在测试中使用的最喜欢的测试框架的依赖关系. // Gradache测试任务也支持TestNG. 只需要testCompile 依赖于 // testCompile 'org.testng:testng:6.8.1' ，和添加 // 'test.useTestNG()' 到你的构建脚本中。 testCompile 'junit:junit:4.12'&#125;*/ settings.gradle:123456789101112131415161718➜ gradle-app cat settings.gradle/* * 此设置文件是由Gradle'init'任务生成的。 * * 设置文件用于指定要在构建中包含哪些项目，在单个项目中构建此文件可以为空或甚至删除。 * * 在用户指南中可以找到有关在Gradle中配置多项目构建的详细信息 * https://docs.gradle.org/4.1/userguide/multi_project_builds.html *//*// 作为多项目构建的一部分 来声明项目使用'include'方法include 'shared'include 'api'include 'services:webservice'*/rootProject.name = 'gradle-app' 继续完善项目：整个项目的目录结构如下,与 Maven 工程目录结构无差别: 目录 说明 src/main/java JAVA 源码 src/main/resources 生产资源文件 src/test/java 测试源码 src/test/resources 测试资源文件 1234567891011121314151617181920212223242526➜ gradle-app tree.├── build.gradle├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradle-app.iml # 导入 IDEA 后生成的文件├── gradlew├── gradlew.bat├── settings.gradle└── src ├── main │ └── java │ └── ws │ └── object │ └── gradle │ └── App.java └── test └── java └── ws └── object └── gradle └── AppTest.java13 directories, 9 files App.java 123456789101112package ws.object.gradle;public class App&#123; public String getAppId() &#123; return "hello-world"; &#125; public static void main( String[] args ) &#123; System.out.println( "Hello World!" ); &#125;&#125; AppTest.java 123456789101112131415package ws.object.gradle;import junit.framework.TestCase;/** * Unit test for simple App. */public class AppTest extends TestCase &#123; public void testAppId() &#123; App app = new App(); assertEquals("App ID", "hello-world", app.getAppId()); &#125;&#125; 构建创建的项目：现在我们已经创建了App.java和AppTest.java，我们准备好构建项目。 这可以通过执行如下所示的构建任务来完成。示例代码： 1234➜ gradle-app ./gradlew buildBUILD SUCCESSFUL in 1s4 actionable tasks: 4 executed 让项目跑起来：使用内置的jar库运行应用程序，示例代码： 12➜ gradle-app java -cp build/libs/gradle-app.jar ws.object.gradle.AppHello World! 或者您可以使用内置的类文件夹运行，示例代码： 12➜ gradle-app java -cp build/classes/java/main/ ws.object.gradle.AppHello World! 参考资料：Gradle Official Website Gradle Wikipedia Gradle Github Building Java Projects with Gradle]]></content>
      <categories>
        <category>Build Tools</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot - Actuator QuickStart]]></title>
    <url>%2F2017%2F08%2F22%2Fspringboot-actuator%2F</url>
    <content type="text"><![CDATA[Spring Boot - Actuator简介:Spring Boot Actuator模块提供了一个监控和管理生产环境的模块，可以使用http、jmx、ssh、telnet等拉管理和监控应用。审计（Auditing）、 健康（health）、数据采集（metrics gathering）会自动加入到应用里面。 Spring Boot - Actuator的特点:Spring Boot Actuator的关键特性是在应用程序里提供了众多的Web站点，通过他们可以来了解应用程序运行时的内部状况。Actuator为Spring Boot项目带来了许多有用的特性，包括： 管理端点 合理的异常处理以及默认的”/error”映射端点 获取应用信息的”/info”端点 当启用Spring Security时，会有一个审计事件框架 SpringBoot - Actuator 的端点：Spring Boot Actuator提供了13个 端点，有了它，你可以知道 Bean 在 Spring应用上下文里是如何组装在一起的，掌握应用程序可以获取的环境属性信息，获取运行时度量信息的快照…… HTTP方法 路径 描述 GET /aotoconfig 提供一份自动配置报告，记录哪些自动配置条件通过那些没通过 GET /configprops 描述配置属性(包含默认值)如何注入 Bean GET /beans 描述应用程序上下文里全部的 Bean，以及他们的关系 GET /dump 获取线程活动的快照 GET /env 获取全部环境属性 GET /env/{name} 根据名称来获取特定的环境属性值 GET /health 报告应用程序的健康指标，这些值由 HealthIndicator 的实现来提供 GET /info 获取应用程序的定制信息，这些信息由 info 开头的属性提供 GET /mappings 描述全部的 URL 路径，以及它们和控制器(包含 Actuator 端点)的映射关系 GET /metrics 报告各种应用程序度量信息，比如内存用量和 HTTP 请求次数 GET /metrics/{name} 根据名称来获取应用程序的度量信息 POST /shutdown 关闭应用程序，要求 endpoints，shutdown，enabled 设置为 True GET /trace 提供基本的 HTTP 请求跟踪信息(时间戳、HTTP 请求头等) SpringBoot - Actuator的使用：需要启动 Actuator 的端点，只需要在项目中引入Actuator的起步依赖即可。 在 Maven 中使用：示例代码： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 在 Gradle 中使用：示例代码： 1compile 'org.springframework.boot:spring-boot-starter-actuator']]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot - 多环境配置(.properties & .yml)]]></title>
    <url>%2F2017%2F08%2F15%2Fspringboot-configuration%2F</url>
    <content type="text"><![CDATA[在Spring Boot的配置文件中，有两种后缀的配置文件，分别是.properties文件和.yml文件。Spring Boot 提供了对应用进行自动化配置。相比以前 XML 的配置方式，很多显式方式申明是不需要的。大多数默认的配置足够实现开发功能，从而更快速开发。 Spring Boot - 两种类型的配置文件 *.properties属性文件；属于最常见的一种； *.yml是yaml格式的文件，yaml是一种非常简洁的标记语言。 .properties文件配置：示例代码： 1234blog.config.title=&quot;柒索&quot;blog.config.subtitle=&quot;我见诸君多傻逼，料诸君见我应如是。&quot;blog.config.url=&quot;http://object.ws&quot;blog.config.number=4000 .yml文件配置：示例代码： 123456blog: config: title: "柒索" subtitle: "我见诸君多傻逼，料诸君见我应如是。" url: "http://object.ws" number: $&#123;random.int&#125; 可以看出两种配置文件的写法yaml 文件的方式更简洁一些，所以推荐使用 yaml 文件来作为 Spring Boot 的配置文件。 Spring Boot - 自定义配置：在配置文件中使用随机数：Spring Boot的属性配置文件中可以通过${random}来产生int值、long值或者string字符串，来支持属性的随机值。 示例代码： 123456789blog: config: url: "http://object.ws" strval: $&#123;random.value&#125; # 产生随机字符串 number: $&#123;random.int&#125; # 产生随机Int类型数值 longnum: $&#123;random.long&#125; # 产生随机 Long类型数值 test1: $&#123;random.int[10]&#125; # 产生10以内的的随机数 test2: $&#123;random.int[10,30]&#125; # 产生10-30之间的随机数 refval: $&#123;blog.config.url&#125;and$&#123;blog.config.strval&#125; # 参数之间的互相引用 自定义配置项代码演示：Spring Boot 为我们提供了许多默认的配置项，但是在开发的过程中，总是会有一些业务需要我们自定义配置，如下代码演示如何使用自定义配置： 示例代码：application.yml 123456blog: config: title: "柒索" subtitle: "我见诸君多傻逼，料诸君见我应如是。" url: "http://object.ws" number: $&#123;random.int&#125; 示例代码：BlogController.java 123456789101112131415161718192021222324252627package ws.object.springboot.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class BlogController &#123; @Value("$&#123;blog.config.title&#125;") String Title; @Value("$&#123;blog.config.subtitle&#125;") String subTitle; @Value("$&#123;blog.config.url&#125;") String Url; @Value("$&#123;blog.config.number&#125;") int Number; @RequestMapping(value = "/blog") public String Blog()&#123; return " Title:"+Title+ " subTitle:"+subTitle+ " URL:"+Url+ " Number:"+Number; &#125;&#125; 之后在浏览器输入http://localhost:8080/blog 就能看到配置在 .yml 文件中的值已经显示在页面里了。 Spring Boot - 多环境配置：在现实的开发环境中，我们需要不同的配置环境，在不同环境下可以配置不同的参数文件，便于部署，提高效率减少出错率，常见配置格式为application-{profile}.properties，其中{profile}对应你的环境标识，比如：dev(开发环境)、test(测试环境)、vis(演示环境)、prod(生产环境)。 application-test.yml：测试环境 application-dev.yml：开发环境 application-prod.yml：生产环境 如何使用？我们只需要在application.yml文件中加上： 123spring: profiles: active: test 其中application-dev.yml: 12server: port: 8080 application-test.yml 12server: port: 8081 启动项目之后，会发现程序的端口不再是8080，而是8081。 Spring Boot - 配置文件优先级：把所有配置全都打在一个jar包里，显然不是最好的做法，更常见的做法是把配置文件放在jar包外面，可以在需要时，不动java代码的前提下修改配置，spring-boot会按以下顺序加载配置文件 application.properties或application.yml： 先查找jar文件同级目录下的 ./config 子目录 有无配置文件 （外置) 再查找jar同级目录 有无配置文件（外置) 再查找config这个package下有无配置文件（内置) 最后才是查找classpath 下有无配置文件（内置) Spring Boot - 常见参数配置：Spring.io-Sring Boot常见配置属性列表 参考资料： 阮一峰-YAML 语言教程 Spring.io-Sring Boot常见配置属性列表]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot - Introduction & QuickStart]]></title>
    <url>%2F2017%2F08%2F10%2Fspringboot-quickstart%2F</url>
    <content type="text"><![CDATA[Spring Boot - 简介： Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. Spring.io Spring Boot - 核心特性： Spring Boot Starter：将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的依赖中。 自动配置：Spring Boot的自动配置特性利用了Spring 4对条件化配置的支持，合理的推测应用所需要的Bean并自动化配置它们。 命令行接口(CLI)：Spring Boot CLI 发挥了Groovy的优势，并结合自动配置进一步简化Spring应用程序的开发。 Actuator：Actuator为Spring Boot应用添加了一定的管理特性。 Spring Boot - QuickStart：使用Spring Initalizr构建Spring Boot项目:要想使用Spring Initalizr，最简单直接的办法就是打开 http://start.spring.io，使用Spring Initalizr的web界面来构建Spring Boot项目。打开Spring Initalizr的web界面后，根据自己需求选择合适的选项： 示例代码： Generate a Maven Project with Java and Spring Boot 1.5.6123Group: ws.object.springbootArtifact: SpringBootDependencies: Web JPA #可多选 如果在当前页面找不到你所需要的依赖，请点击 Switch to the full version ,打开后就能看到可用依赖的完整列表。 填写完成之后，点击Generate Project，Spring Initalizr就会为你生成一个名为SpringBoot.zip的文件，解压后项目结构如下： 123456789101112131415161718192021222324252627➜ unzip SpringBoot.zip➜ tree ./SpringBoot./SpringBoot├── mvnw├── mvnw.cmd├── pom.xml└── src ├── main │ ├── java │ │ └── ws │ │ └── object │ │ └── springboot │ │ └── SpringBoot │ │ └── Application.java │ └── resources │ ├── application.properties │ ├── static │ └── templates └── test └── java └── ws └── object └── springboot └── SpringBoot └── ApplicationTests.java16 directories, 6 files 如你所见，项目中基本没有代码，除了几个空目录之外，还包含了以下几样东西： pom.xml : Maven工程的主要配置文件。 Application.java ： 一个带有main()方法的类，用于引导启动应用程序。 ApplicationTests.java ：一个空的JUnit测试类，它加载了Spring Boot自动配置的Spring应用上下文。 application.properties ：一个空的properties配置文件，可以根据需要添加配置属性。 static目录 ： 放置Web应用程序的静态内容(js，css，images…)。 templates目录 ： 放置用于呈现模型数据的模板文件。 mvnw和mvnw.cmd文件：分别是Windows系统和类Unix系统下Maven的配置文件。 参考资料：Stack Overflow - What is the purpose of mvnw and mvnw.cmd files? 使用IntelliJ IDEA构建Spring Boot项目：打开 IntelliJ IDEA，到Welcome to IntelliJ IDEA 界面，选择 Create New Project，左侧列表栏找到Spring Initalizr，选择自己需要的Project SDk，还有Initalizr Service URL ，Next，填写相关信息： 名称 说明 示例 Group Maven工程组的标识 ws.object.springboot Artifact Maven工程的标识与项目名称一致 SpringBoot Type 项目的构建方式 Maven Project Packaging 打包方式 Jar Java Version Java的版本信息 1.8 Language 编程语言 Java Version 项目版本号 0.0.1-SNAPSHOT Name 项目名称 SpringBoot Description 项目简介 …… 当前页填写完成之后，点击Next，选择项目所需要的依赖，选择完成之后，进入到下一页选择项目的存放路径等信息，然后项目就构建完成了。 使用Spring Boot CLI构建Spring Boot项目：Spring Boot CLI中有一些命令，可以帮我们快速构建Spring Boot项目，示例代码： 12345678910111213141516171819202122232425262728293031➜ mkdir SpringBoot &amp;&amp; cd SpringBoot➜ SpringBoot spring initUsing service at https://start.spring.ioContent saved to 'demo.zip'➜ SpringBoot lsdemo.zip➜ SpringBoot unzip demo.zipArchive: demo.zip inflating: mvnw creating: .mvn/ creating: .mvn/wrapper/ creating: src/ creating: src/main/ creating: src/main/java/ creating: src/main/java/com/ creating: src/main/java/com/example/ creating: src/main/java/com/example/demo/ creating: src/main/resources/ creating: src/test/ creating: src/test/java/ creating: src/test/java/com/ creating: src/test/java/com/example/ creating: src/test/java/com/example/demo/ inflating: .gitignore inflating: .mvn/wrapper/maven-wrapper.jar inflating: .mvn/wrapper/maven-wrapper.properties inflating: mvnw.cmd inflating: pom.xml inflating: src/main/java/com/example/demo/DemoApplication.java inflating: src/main/resources/application.properties inflating: src/test/java/com/example/demo/DemoApplicationTests.java 解压完成之后，使用Tree命令查看一下目录结构： 1234567891011121314151617181920212223➜ SpringBoot tree ../SpringBoot../SpringBoot├── demo.zip├── mvnw├── mvnw.cmd├── pom.xml└── src ├── main │ ├── java │ │ └── com │ │ └── example │ │ └── demo │ │ └── DemoApplication.java │ └── resources │ └── application.properties └── test └── java └── com └── example └── demo └── DemoApplicationTests.java12 directories, 7 files 然后将构建好的项目导入到 IDEA或者 Eclipse中就好了。 Spring Boot - CLI：使用Homebrew安装Spring Boot CLI：示例代码： 123456789101112➜ ~ brew --version # 查看Homebrew版本信息Homebrew 1.3.1➜ ~ brew tap pivotal/tap # 安装Pivotal的tap==&gt; Tapping pivotal/tap ……➜ ~ brew install springboot # 安装Spring Boot==&gt; Installing springboot from pivotal/tap==&gt; Downloading ……➜ ~ spring --version # 查看版本Spring CLI v1.5.6.RELEASE pivotal/tap：Prvotal是Spring以及Spring Boot背后的公司，通过它的tap可以安装Spring Boot。tap是向Homebrew添加额外仓库的一种途径。 Spring Boot CLI:1$ spring init 这条命令会下载一个demo.zip文件，与之前使用spring init构建的项目一样的结构。 1$ spring init -dweb,jpa,security # 使用-d或--dependencies来指定依赖 与spring init命令一样，但是在pom.xml中添加了Spring Boot的Web，JPA，Security起步依赖。 1$ spring init -dweb,jpa,security --build gradle # --build 指定项目使用Grandle构建 使用Gradle来构建项目，默认情况下是使用Maven来构建的。 1$ spring init -dweb,jpa,security --build gradle -p war # -p或者-packaging 默认情况下，无论是Maven或Gradle构建项目成功之后都会产生一个可执行的JAR文件，如果你需要一个war文件，可以通过-p 参数来指定。 1$ spring init -dweb,jpa,security --build gradle ~/Project/SpringBoot 这里的最后一个参数可以指定你的demo.zip文件的解压目录。如果你希望CLI生成的项目解压到当前目录，可以使用 —extract或者-x参数。 1$ spring help 也可以使用 spring help来查看其他命令，并了解如何使用。 Spring Boot Maven Plugin:在pom.xml中配置插件：示例代码： 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 插件的指令详解：1➜ mvn spring-boot:help 显示spring-boot-maven-plugin的帮助信息。调用mvn spring-boot：help -Ddetail = true -Dgoal = &lt;goal-name&gt;显示参数细节。 1➜ mvn spring-boot:build-info 根据当前的内容生成一个build-info.properties文件,在你的Maven Project中。 1➜ mvn spring-boot:repackage 重新包装现有的JAR和WAR存档，以便可以从中执行命令行使用java -jar。使用layout = NONE也可以简单地使用使用嵌套依赖关系打包一个JAR（没有主类，因此不可执行）。 1➜ mvn spring-boot:run 运行基于Maven构建的Spring Boot应用程序。 1➜ mvn spring-boot:start 启动Spring Boot应用程序。通常使用这个命令在应用程序在测试之前启动的集成测试场景中。 1➜ mvn spring-boot:stop 停止由“start”目标开始的应用程序。通常测试套件完成后调用。 参考资料： Spring Boot-Spring.io Spring Boot-Github Spring Boot-Reference.pdf]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HighCharts - 学习笔记整理]]></title>
    <url>%2F2017%2F08%2F05%2Fhightcharts-note%2F</url>
    <content type="text"><![CDATA[HighCharts概述：HighCharts是用JavaScript编写的图表库，可以在Web应用中使用，开源，个人及非商可以任用。 HighCharts特点： 兼容性 - 支持所有主流浏览器和移动平台（android、iOS等）。 多设备 - 支持多种设备，如手持设备 iPhone/iPad、平板等。 免费使用 - 开源免费。 轻量 - highcharts.js 内核库大小只有 35KB 左右。 配置简单 - 使用 json 格式配置 动态 - 可以在图表生成后修改。 多维 - 支持多维图表 配置提示工具 - 鼠标移动到图表的某一点上有提示信息。 时间轴 - 可以精确到毫秒。 导出 - 表格可导出为 PDF/ PNG/ JPG / SVG 格式 输出 - 网页输出图表。 可变焦 - 选中图表部分放大，近距离观察图表； 外部数据 - 从服务器载入动态数据。 文字旋转 - 支持在任意方向的标签旋转。 HighCharts构成：界面构成：在Highcharts中，一个图表通常由图表区，标题，绘图区，坐标轴，图例，数据列等几个部分组成。 代码构成： 标题（Title）： 图表标题，包含标题和副标题（subTitle），其中副标题是非必须的。 坐标轴（Axis）： 坐标轴包含x轴（xAxis）和y轴（yAxis）。通常情况下，x轴显示在图表的底部，y轴显示在图表的左侧。多个数据列可以共同使用同一个坐标轴，为了对比或区分数据，Highcharts提供了多轴的支持。 数据列（Series）： 数据列即图表上一个或多个数据系列，比如曲线图中的一条曲线，柱状图中的一个柱形。 数据提示框（Tooltip）： 当鼠标悬停在某点上时，以框的形式提示该点的数据，比如该点的值、数据单位等。数据提示框内提示的信息完全可以通过格式化函数动态指定。 图例（Legend）： 图例是图表中用不同形状、颜色、文字等 标示不同数据列，通过点击标示可以显示或隐藏该数据列。 版权标签（Credits）： 显示在图表右下方的包含链接的文字，默认是Highcharts官网地址。通过指定credits.enabled=false即可不显示该信息。 导出功能（Exporting）： 通过引入 exporting.js即可增加图表导出为常见文件功能。 示线（PlotLines）： 可以在图表上增加一条标示线，比如平均值线，最高值线等。 示区（PlotBands）： 可以在图表添加不同颜色的区域带，标示出明显的范围区域。 HighCharts配置：HighCharts常用配置项: 配置项 说 明 chart 图表基本配置项 colors 全局颜色 credits 版权信息配置项 data 高级数据模块配置项 defs 定义SVG风格模式适配项 drilldown 下钻功能配置项 exporting 导出功能配置项 labels 标签配置项 legend 图例配置项 loading 加载动画配置项 navigation 导航配置项 noData 无数据模块配置项 pane 面板模块配置项 plotOptions 绘图区配置项 responsive 响应式适配配置项 series 数据列配置项 subtitle 副标题配置项 title 标题配置项 tooltip 提示框配置项 xAxis x轴配置项 yAxis y轴配置项 zAxis z轴配置项 HighCharts图表容器配置：1、通过 dom 调用 highcharts() 函数的方式123$(&quot;#container&quot;).highcharts(&#123; // Highcharts 配置 &#125;); 2、通过 chart.renderTo 来指定123456var charts = new Highcharts.Chart(&#123; // Highcharts 配置 chart : &#123; renderTo : &quot;container&quot; // 注意这里一定是 ID 选择器 &#125;&#125;); 3、通过构造函数123var charts = new Highcharts.Chart(&apos;container&apos;, &#123; // Highcharts 配置&#125;); Highcharts图表样式配置：图表样式属性包括 border、backgroundColor、margin、spacing、style等 边框：包括 borderColor、borderRadius、borderWidth 背景：包括 backgroundColor 外边距：包括 margin、marginTop、marginRight、marginBottom、marginLeft 内边距：包括 spacing、spacingTop、spacingRight、spacingBottom、spacingLeft 其他样式：其他属性例如字体等属性，实例代码 示例代码： 12345678chart: &#123; style: &#123; fontFamily: &quot;&quot;, fontSize: &apos;12px&apos;, fontWeight: &apos;bold&apos;, color: &apos;#006cee&apos; &#125;&#125; 另外还可以通过 chart.className来绑定 CSS 类并给定 CSS 样式。 ​ HIghcharts图表绘图配置：图表绘图区的可配置属性有： plotBackgroundColor ： 绘图区背景颜色 plotBackgroundImage ： 绘图区背景图片 plotBorderColor ： 绘图区边框颜色 plotBorderWidth ： 绘图区边框宽度 plotShadow ： 绘图投影 Highcharts图表常用事件： click ：图表点击事件，效果见 在线演示 load ：图表加载完后事件，效果见 在线演示 addSeries ：图表增加序列事件，效果见 在线演示 drilldown ：图表下钻事件，效果见 在线演示 drillup ： 图表上钻事件，效果见 在线演示 redraw ：图表重绘事件，效果见 在线演示 selection ： 图表范围选择事件，效果见 在线演示 beforePrint ： 图表打印前事件，效果见 在线演示 afterPrint ： 图表打印后事件,效果见 在线演示 Highcharts图表：直线图 - (line)：示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;折线图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1000px; height: 500px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var chart = new Highcharts.Chart('container', &#123; chart: &#123; type: 'line', //指定图表的类型，默认是折线图（line） style: &#123; fontFamily: "Microsoft YaHei", fontSize: '18px', fontWeight: 'bold' &#125; &#125; ,title: &#123; text: '不同城市的月平均气温', // 标题 x: -20 // 相对于水平对齐的偏移量，可以是负数，单位是px &#125;, subtitle: &#123; text: '数据来源: xxx.com', // 副标题 x: -20 //相对于水平对齐的偏移量，可以是负数，单位是px &#125;, xAxis: &#123; // x轴 categories: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'] &#125;, yAxis: &#123; //y轴 title: &#123; text: '温度 (°C)' &#125;, plotLines: [&#123; value: 0, width: 1, color: '#808080' &#125;] &#125;, tooltip: &#123; valueSuffix: '°C' &#125;, legend: &#123; // 图例配置项 layout: 'vertical', // horizontal" 或 "vertical align: 'right', // left，center 和 right verticalAlign: 'middle', // top，middle 和 bottom borderWidth: 0 &#125;, series: [&#123; name: '东京', data: [7.0, 6.9, 9.5, 14.5, 18.2, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6] &#125;, &#123; name: '纽约', data: [-0.2, 0.8, 5.7, 11.3, 17.0, 22.0, 24.8, 24.1, 20.1, 14.1, 8.6, 2.5] &#125;, &#123; name: '柏林', data: [-0.9, 0.6, 3.5, 8.4, 13.5, 17.0, 18.6, 17.9, 14.3, 9.0, 3.9, 1.0] &#125;, &#123; name: '伦敦', data: [3.9, 4.2, 5.7, 8.5, 11.9, 15.2, 17.0, 16.6, 14.2, 10.3, 6.6, 4.8] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 曲线图 - (spline)：示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;曲线图&lt;/title&gt;&lt;/head&gt;&lt;style&gt;#container&#123; width: 1200px; height: 600px; margin:0 auto;&#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart:&#123; // 图表类型 type:'spline' &#125;, title:&#123; // 标题 text:'城市平均气温-曲线图' &#125;, subtitle:&#123; //副标题 text:'东京，纽约，伦敦' &#125;, xAlias:&#123; // x轴 categories: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'] &#125;, yAlias:&#123; // y轴 title: &#123; enable:true, text: 'Temperature (\xB0C)' &#125;, plotLines: [&#123; value: 0, width: 1, color: '#808080' &#125;] &#125;, legend:&#123; layout: 'vertical', align: 'right', verticalAlign: 'middle', borderWidth: 0 &#125;, tooltip:&#123; valueSuffix: '\xB0C', crosshairs: true,//竖线 shared: true &#125;, plotOptions:&#123; spline: &#123; marker: &#123; radius: 4, lineColor: '#666666', lineWidth: 1 &#125; &#125; &#125;, series:[ &#123; name: 'Tokyo', data: [7.0, 6.9, 9.5, 14.5, 18.2, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6] &#125;, &#123; name: 'New York', data: [-0.2, 0.8, 5.7, 11.3, 17.0, 22.0, 24.8, 24.1, 20.1, 14.1, 8.6, 2.5] &#125;, &#123; name: 'London', data: [3.9, 4.2, 5.7, 8.5, 11.9, 15.2, 17.0, 16.6, 14.2, 10.3, 6.6, 4.8] &#125; ] &#125;);&lt;/script&gt;&lt;/html&gt; 面积图 - (area)：示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;面积图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container &#123; width: 1000px; height: 500px; margin: 0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var chat = new Highcharts.Chart('container', &#123; chart: &#123; type: 'area' &#125;, title: &#123; text: '面积图' &#125;, subtitle: &#123; text: '一个简单的面积图' &#125;, xAlias: &#123; //allowDecimals: true, title:&#123; text:'Y轴', categories: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月'] &#125; &#125;, tooltip: &#123; valueSuffix: '单位' &#125;, legend: &#123; layout: 'vertical', align: 'right', verticalAlign: 'middle', borderWidth: 0 &#125;, yAlias: &#123; title: &#123; text: 'Y轴' &#125;,plotLines: [&#123; value: 0, width: 1, color: '#808080' &#125;] &#125;, series: [ &#123; name: '列一', data: [13, 83, 56, 32, 89, 97, 143, 45, 67, 87, 98] &#125;, &#123; name: '列二', data: [13, 23, 61, 62, 15, 27, 83, 75, 47, 17, 28] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 曲线面积图 - (areaspline)：示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;曲线面积图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'areaspline' &#125;, title: &#123; text: '不同家庭一周水果消费情况' &#125;, legend: &#123; layout: 'vertical', align: 'left', verticalAlign: 'top', x: 150, y: 100, floating: true, borderWidth: 1, backgroundColor: (Highcharts.theme &amp;&amp; Highcharts.theme.legendBackgroundColor) || '#FFFFFF' &#125;, xAxis: &#123; categories: [ '周一', '周二', '周三', '周四', '周五', '周六', '周日' ], plotBands: [&#123; // visualize the weekend from: 4.5, to: 6.5, color: 'rgba(68, 170, 213, .2)' &#125;] &#125;, yAxis: &#123; title: &#123; text: '水果 单位' &#125; &#125;, tooltip: &#123; shared: true, valueSuffix: ' 单位' &#125;, credits: &#123; enabled: false &#125;, plotOptions: &#123; areaspline: &#123; fillOpacity: 0.5 &#125; &#125;, series: [&#123; name: '甲', data: [3, 4, 3, 5, 4, 10, 12] &#125;, &#123; name: '乙', data: [1, 3, 4, 3, 3, 5, 4] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 柱状图 - (column)：示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;柱状图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'column' &#125;, title: &#123; text: '堆叠柱形图' &#125;, xAxis: &#123; categories: ['苹果', '橘子', '梨', '葡萄', '香蕉'] &#125;, yAxis: &#123; min: 0, title: &#123; text: '水果消费总量' &#125;, stackLabels: &#123; enabled: true, style: &#123; fontWeight: 'bold', color: 'gray' &#125; &#125; &#125;, legend: &#123; align: 'right', x: -30, verticalAlign: 'top', y: 25, floating: true, backgroundColor: 'white', borderColor: '#CCC', borderWidth: 1, shadow: false &#125;, tooltip: &#123; formatter: function () &#123; return '&lt;b&gt;' + this.x + '&lt;/b&gt;&lt;br/&gt;' + this.series.name + ': ' + this.y + '&lt;br/&gt;' + '总量: ' + this.point.stackTotal; &#125; &#125;, plotOptions: &#123; column: &#123; stacking: 'normal', dataLabels: &#123; enabled: true, color: '#FFF', style: &#123; textShadow: '0 0 3px black' &#125; &#125; &#125; &#125;, series: [&#123; name: '甲', data: [5, 3, 4, 7, 2] &#125;, &#123; name: '乙', data: [2, 2, 3, 2, 1] &#125;, &#123; name: '丙', data: [3, 4, 4, 2, 5] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 条形图 - (bar)：示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;条形图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'bar' &#125;, title: &#123; text: '各洲不同时间的人口条形图' &#125;, subtitle: &#123; text: '数据来源: Wikipedia.org' &#125;, xAxis: &#123; categories: ['非洲', '美洲', '亚洲', '欧洲', '大洋洲'], title: &#123; text: null &#125; &#125;, yAxis: &#123; min: 0, title: &#123; text: '人口总量 (百万)', align: 'high' &#125;, labels: &#123; overflow: 'justify' &#125; &#125;, tooltip: &#123; valueSuffix: ' 百万' &#125;, plotOptions: &#123; bar: &#123; dataLabels: &#123; enabled: true, allowOverlap: true &#125; &#125; &#125;, legend: &#123; layout: 'vertical', align: 'right', verticalAlign: 'top', x: -40, y: 100, floating: true, borderWidth: 1, backgroundColor: '#FFFFFF', shadow: true &#125;, credits: &#123; enabled: false &#125;, series: [&#123; name: '1800 年', data: [107, 31, 635, 203, 2] &#125;, &#123; name: '1900 年', data: [133, 156, 947, 408, 6] &#125;, &#123; name: '2008 年', data: [973, 914, 4054, 732, 34] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 饼图 - (pie)：示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;饼图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; plotBackgroundColor: null, plotBorderWidth: null, plotShadow: false &#125;, title: &#123; text: '2014 某网站各浏览器浏览量占比' &#125;, tooltip: &#123; headerFormat: '&#123;series.name&#125;&lt;br&gt;', pointFormat: '&#123;point.name&#125;: &lt;b&gt;&#123;point.percentage:.1f&#125;%&lt;/b&gt;' &#125;, plotOptions: &#123; pie: &#123; allowPointSelect: true, cursor: 'pointer', dataLabels: &#123; enabled: true, format: '&lt;b&gt;&#123;point.name&#125;&lt;/b&gt;: &#123;point.percentage:.1f&#125; %', style: &#123; color:'black' &#125; &#125; &#125; &#125;, series: [&#123; type: 'pie', name: '浏览器访问量占比', data: [ ['Firefox', 45.0], ['IE', 26.8], &#123; name: 'Chrome', y: 12.8, sliced: true, selected: true &#125;, ['Safari', 8.5], ['Opera', 6.2], ['其他', 0.7] ] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 散点图 - (scatter)：示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;散点图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'scatter', zoomType: 'xy' &#125;, title: &#123; text: '507 人按性别划分的身高和体重分布图' &#125;, subtitle: &#123; text: '数据来源: Heinz 2003' &#125;, xAxis: &#123; title: &#123; enabled: true, text: '身高 (cm)' &#125;, startOnTick: true, endOnTick: true, showLastLabel: true &#125;, yAxis: &#123; title: &#123; text: '体重 (kg)' &#125; &#125;, legend: &#123; layout: 'vertical', align: 'left', verticalAlign: 'top', x: 100, y: 70, floating: true, backgroundColor: '#FFFFFF', borderWidth: 1 &#125;, plotOptions: &#123; scatter: &#123; marker: &#123; radius: 5, states: &#123; hover: &#123; enabled: true, lineColor: 'rgb(100,100,100)' &#125; &#125; &#125;, states: &#123; hover: &#123; marker: &#123; enabled: false &#125; &#125; &#125;, tooltip: &#123; headerFormat: '&lt;b&gt;&#123;series.name&#125;&lt;/b&gt;&lt;br&gt;', pointFormat: '&#123;point.x&#125; cm, &#123;point.y&#125; kg' &#125; &#125; &#125;, series: [&#123; name: '女', color: 'rgba(223, 83, 83, .5)', data: [[161.2, 51.6], [167.5, 59.0], [159.5, 49.2], [157.0, 63.0], [155.8, 53.6], [170.0, 59.0], [159.1, 47.6], [166.0, 69.8], [176.2, 66.8], [160.2, 75.2], [172.5, 55.2], [170.9, 54.2], [172.9, 62.5], [153.4, 42.0], [160.0, 50.0], [147.2, 49.8], [168.2, 49.2], [175.0, 73.2], [157.0, 47.8], [167.6, 68.8], [159.5, 50.6], [175.0, 82.5], [166.8, 57.2], [176.5, 87.8], [170.2, 72.8], [174.0, 54.5], [173.0, 59.8], [179.9, 67.3], [170.5, 67.8], [160.0, 47.0], [154.4, 46.2], [162.0, 55.0], [176.5, 83.0], [160.0, 54.4], [152.0, 45.8], [162.1, 53.6], [170.0, 73.2], [160.2, 52.1], [161.3, 67.9], [166.4, 56.6], [168.9, 62.3], [163.8, 58.5], [167.6, 54.5], [160.0, 50.2], [161.3, 60.3], [167.6, 58.3], [165.1, 56.2], [160.0, 50.2], [170.0, 72.9], [157.5, 59.8], [167.6, 61.0], [160.7, 69.1], [163.2, 55.9], [152.4, 46.5], [157.5, 54.3], [168.3, 54.8], [180.3, 60.7], [165.5, 60.0], [165.0, 62.0], [164.5, 60.3], [156.0, 52.7], [160.0, 74.3], [163.0, 62.0], [165.7, 73.1], [161.0, 80.0], [162.0, 54.7], [166.0, 53.2], [174.0, 75.7], [172.7, 61.1], [167.6, 55.7], [151.1, 48.7], [164.5, 52.3], [163.5, 50.0], [152.0, 59.3], [169.0, 62.5], [164.0, 55.7], [161.2, 54.8], [155.0, 45.9], [170.0, 70.6], [176.2, 67.2], [170.0, 69.4], [162.5, 58.2], [170.3, 64.8], [164.1, 71.6], [169.5, 52.8], [163.2, 59.8], [154.5, 49.0], [159.8, 50.0], [173.2, 69.2], [170.0, 55.9], [161.4, 63.4], [169.0, 58.2], [166.2, 58.6], [159.4, 45.7], [162.5, 52.2], [159.0, 48.6], [162.8, 57.8], [159.0, 55.6], [179.8, 66.8], [162.9, 59.4], [161.0, 53.6], [151.1, 73.2], [168.2, 53.4], [168.9, 69.0], [173.2, 58.4], [171.8, 56.2], [178.0, 70.6], [164.3, 59.8], [163.0, 72.0], [168.5, 65.2], [166.8, 56.6], [172.7, 105.2], [163.5, 51.8], [169.4, 63.4], [167.8, 59.0], [159.5, 47.6], [167.6, 63.0], [161.2, 55.2], [160.0, 45.0], [163.2, 54.0], [162.2, 50.2], [161.3, 60.2], [149.5, 44.8], [157.5, 58.8], [163.2, 56.4], [172.7, 62.0], [155.0, 49.2], [156.5, 67.2], [164.0, 53.8], [160.9, 54.4], [162.8, 58.0], [167.0, 59.8], [160.0, 54.8], [160.0, 43.2], [168.9, 60.5], [158.2, 46.4], [156.0, 64.4], [160.0, 48.8], [167.1, 62.2], [158.0, 55.5], [167.6, 57.8], [156.0, 54.6], [162.1, 59.2], [173.4, 52.7], [159.8, 53.2], [170.5, 64.5], [159.2, 51.8], [157.5, 56.0], [161.3, 63.6], [162.6, 63.2], [160.0, 59.5], [168.9, 56.8], [165.1, 64.1], [162.6, 50.0], [165.1, 72.3], [166.4, 55.0], [160.0, 55.9], [152.4, 60.4], [170.2, 69.1], [162.6, 84.5], [170.2, 55.9], [158.8, 55.5], [172.7, 69.5], [167.6, 76.4], [162.6, 61.4], [167.6, 65.9], [156.2, 58.6], [175.2, 66.8], [172.1, 56.6], [162.6, 58.6], [160.0, 55.9], [165.1, 59.1], [182.9, 81.8], [166.4, 70.7], [165.1, 56.8], [177.8, 60.0], [165.1, 58.2], [175.3, 72.7], [154.9, 54.1], [158.8, 49.1], [172.7, 75.9], [168.9, 55.0], [161.3, 57.3], [167.6, 55.0], [165.1, 65.5], [175.3, 65.5], [157.5, 48.6], [163.8, 58.6], [167.6, 63.6], [165.1, 55.2], [165.1, 62.7], [168.9, 56.6], [162.6, 53.9], [164.5, 63.2], [176.5, 73.6], [168.9, 62.0], [175.3, 63.6], [159.4, 53.2], [160.0, 53.4], [170.2, 55.0], [162.6, 70.5], [167.6, 54.5], [162.6, 54.5], [160.7, 55.9], [160.0, 59.0], [157.5, 63.6], [162.6, 54.5], [152.4, 47.3], [170.2, 67.7], [165.1, 80.9], [172.7, 70.5], [165.1, 60.9], [170.2, 63.6], [170.2, 54.5], [170.2, 59.1], [161.3, 70.5], [167.6, 52.7], [167.6, 62.7], [165.1, 86.3], [162.6, 66.4], [152.4, 67.3], [168.9, 63.0], [170.2, 73.6], [175.2, 62.3], [175.2, 57.7], [160.0, 55.4], [165.1, 104.1], [174.0, 55.5], [170.2, 77.3], [160.0, 80.5], [167.6, 64.5], [167.6, 72.3], [167.6, 61.4], [154.9, 58.2], [162.6, 81.8], [175.3, 63.6], [171.4, 53.4], [157.5, 54.5], [165.1, 53.6], [160.0, 60.0], [174.0, 73.6], [162.6, 61.4], [174.0, 55.5], [162.6, 63.6], [161.3, 60.9], [156.2, 60.0], [149.9, 46.8], [169.5, 57.3], [160.0, 64.1], [175.3, 63.6], [169.5, 67.3], [160.0, 75.5], [172.7, 68.2], [162.6, 61.4], [157.5, 76.8], [176.5, 71.8], [164.4, 55.5], [160.7, 48.6], [174.0, 66.4], [163.8, 67.3]] &#125;, &#123; name: '男', color: 'rgba(119, 152, 191, .5)', data: [[174.0, 65.6], [175.3, 71.8], [193.5, 80.7], [186.5, 72.6], [187.2, 78.8], [181.5, 74.8], [184.0, 86.4], [184.5, 78.4], [175.0, 62.0], [184.0, 81.6], [180.0, 76.6], [177.8, 83.6], [192.0, 90.0], [176.0, 74.6], [174.0, 71.0], [184.0, 79.6], [192.7, 93.8], [171.5, 70.0], [173.0, 72.4], [176.0, 85.9], [176.0, 78.8], [180.5, 77.8], [172.7, 66.2], [176.0, 86.4], [173.5, 81.8], [178.0, 89.6], [180.3, 82.8], [180.3, 76.4], [164.5, 63.2], [173.0, 60.9], [183.5, 74.8], [175.5, 70.0], [188.0, 72.4], [189.2, 84.1], [172.8, 69.1], [170.0, 59.5], [182.0, 67.2], [170.0, 61.3], [177.8, 68.6], [184.2, 80.1], [186.7, 87.8], [171.4, 84.7], [172.7, 73.4], [175.3, 72.1], [180.3, 82.6], [182.9, 88.7], [188.0, 84.1], [177.2, 94.1], [172.1, 74.9], [167.0, 59.1], [169.5, 75.6], [174.0, 86.2], [172.7, 75.3], [182.2, 87.1], [164.1, 55.2], [163.0, 57.0], [171.5, 61.4], [184.2, 76.8], [174.0, 86.8], [174.0, 72.2], [177.0, 71.6], [186.0, 84.8], [167.0, 68.2], [171.8, 66.1], [182.0, 72.0], [167.0, 64.6], [177.8, 74.8], [164.5, 70.0], [192.0, 101.6], [175.5, 63.2], [171.2, 79.1], [181.6, 78.9], [167.4, 67.7], [181.1, 66.0], [177.0, 68.2], [174.5, 63.9], [177.5, 72.0], [170.5, 56.8], [182.4, 74.5], [197.1, 90.9], [180.1, 93.0], [175.5, 80.9], [180.6, 72.7], [184.4, 68.0], [175.5, 70.9], [180.6, 72.5], [177.0, 72.5], [177.1, 83.4], [181.6, 75.5], [176.5, 73.0], [175.0, 70.2], [174.0, 73.4], [165.1, 70.5], [177.0, 68.9], [192.0, 102.3], [176.5, 68.4], [169.4, 65.9], [182.1, 75.7], [179.8, 84.5], [175.3, 87.7], [184.9, 86.4], [177.3, 73.2], [167.4, 53.9], [178.1, 72.0], [168.9, 55.5], [157.2, 58.4], [180.3, 83.2], [170.2, 72.7], [177.8, 64.1], [172.7, 72.3], [165.1, 65.0], [186.7, 86.4], [165.1, 65.0], [174.0, 88.6], [175.3, 84.1], [185.4, 66.8], [177.8, 75.5], [180.3, 93.2], [180.3, 82.7], [177.8, 58.0], [177.8, 79.5], [177.8, 78.6], [177.8, 71.8], [177.8, 116.4], [163.8, 72.2], [188.0, 83.6], [198.1, 85.5], [175.3, 90.9], [166.4, 85.9], [190.5, 89.1], [166.4, 75.0], [177.8, 77.7], [179.7, 86.4], [172.7, 90.9], [190.5, 73.6], [185.4, 76.4], [168.9, 69.1], [167.6, 84.5], [175.3, 64.5], [170.2, 69.1], [190.5, 108.6], [177.8, 86.4], [190.5, 80.9], [177.8, 87.7], [184.2, 94.5], [176.5, 80.2], [177.8, 72.0], [180.3, 71.4], [171.4, 72.7], [172.7, 84.1], [172.7, 76.8], [177.8, 63.6], [177.8, 80.9], [182.9, 80.9], [170.2, 85.5], [167.6, 68.6], [175.3, 67.7], [165.1, 66.4], [185.4, 102.3], [181.6, 70.5], [172.7, 95.9], [190.5, 84.1], [179.1, 87.3], [175.3, 71.8], [170.2, 65.9], [193.0, 95.9], [171.4, 91.4], [177.8, 81.8], [177.8, 96.8], [167.6, 69.1], [167.6, 82.7], [180.3, 75.5], [182.9, 79.5], [176.5, 73.6], [186.7, 91.8], [188.0, 84.1], [188.0, 85.9], [177.8, 81.8], [174.0, 82.5], [177.8, 80.5], [171.4, 70.0], [185.4, 81.8], [185.4, 84.1], [188.0, 90.5], [188.0, 91.4], [182.9, 89.1], [176.5, 85.0], [175.3, 69.1], [175.3, 73.6], [188.0, 80.5], [188.0, 82.7], [175.3, 86.4], [170.5, 67.7], [179.1, 92.7], [177.8, 93.6], [175.3, 70.9], [182.9, 75.0], [170.8, 93.2], [188.0, 93.2], [180.3, 77.7], [177.8, 61.4], [185.4, 94.1], [168.9, 75.0], [185.4, 83.6], [180.3, 85.5], [174.0, 73.9], [167.6, 66.8], [182.9, 87.3], [160.0, 72.3], [180.3, 88.6], [167.6, 75.5], [186.7, 101.4], [175.3, 91.1], [175.3, 67.3], [175.9, 77.7], [175.3, 81.8], [179.1, 75.5], [181.6, 84.5], [177.8, 76.6], [182.9, 85.0], [177.8, 102.5], [184.2, 77.3], [179.1, 71.8], [176.5, 87.9], [188.0, 94.3], [174.0, 70.9], [167.6, 64.5], [170.2, 77.3], [167.6, 72.3], [188.0, 87.3], [174.0, 80.0], [176.5, 82.3], [180.3, 73.6], [167.6, 74.1], [188.0, 85.9], [180.3, 73.2], [167.6, 76.3], [183.0, 65.9], [183.0, 90.9], [179.1, 89.1], [170.2, 62.3], [177.8, 82.7], [179.1, 79.1], [190.5, 98.2], [177.8, 84.1], [180.3, 83.2], [180.3, 83.2]] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 箱线图 - (boxplot)：示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;箱线图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://img.hcharts.cn/highcharts/highcharts-more.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'boxplot' &#125;, title: &#123; text: 'Highcharts 箱线图' &#125;, legend: &#123; enabled: false &#125;, xAxis: &#123; categories: ['1', '2', '3', '4', '5'], title: &#123; text: '' &#125; &#125;, yAxis: &#123; title: &#123; text: '观测值' &#125;, plotLines: [&#123; value: 932, color: 'red', width: 1, label: &#123; text: '理论模型: 932', align: 'center', style: &#123; color: 'gray' &#125; &#125; &#125;] &#125;, tooltip: &#123; pointFormat: '&lt;span style="color:&#123;point.color&#125;"&gt;\u25CF&lt;/span&gt; &lt;b&gt; &#123;series.name&#125;&lt;/b&gt;&lt;br/&gt;' + // eslint-disable-line no-dupe-keys '最大值: &#123;point.high&#125;&lt;br/&gt;' + 'Q2\t: &#123;point.q3&#125;&lt;br/&gt;' + '中位数: &#123;point.median&#125;&lt;br/&gt;' + 'Q1\t: &#123;point.q1&#125;&lt;br/&gt;' + '最小值: &#123;point.low&#125;&lt;br/&gt;' &#125;, series: [&#123; name: '观测值', data: [ [760, 801, 848, 895, 965], [733, 853, 939, 980, 1080], [714, 762, 817, 870, 918], [724, 802, 806, 871, 950], [834, 836, 864, 882, 910] ], tooltip: &#123; headerFormat: '&lt;em&gt;实验号码： &#123;point.key&#125;&lt;/em&gt;&lt;br/&gt;' &#125; &#125;, &#123; name: '异常值', color: Highcharts.getOptions().colors[0], type: 'scatter', data: [ // x, y positions where 0 is the first category [0, 644], [4, 718], [4, 951], [4, 969] ], marker: &#123; fillColor: 'white', lineWidth: 1, lineColor: Highcharts.getOptions().colors[0] &#125;, tooltip: &#123; pointFormat: 'Observation: &#123;point.y&#125;' &#125; &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 气泡图 - (bubble)：示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;气泡图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://img.hcharts.cn/highcharts/highcharts-more.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'bubble', zoomType: 'xy' &#125;, title: &#123; text: 'Highcharts 气泡图' &#125;, series: [&#123; name:'数据列 1', // 每个气泡包含三个值，x，y，z；其中 x，y用于定位，z 用于计算气泡大小 data: [[97, 36, 79], [94, 74, 60], [68, 76, 58], [64, 87, 56], [68, 27, 73], [74, 99, 42], [7, 93, 87], [51, 69, 40], [38, 23, 33], [57, 86, 31]] &#125;, &#123; name:'数据列 2', data: [[25, 10, 87], [2, 75, 59], [11, 54, 8], [86, 55, 93], [5, 3, 58], [90, 63, 44], [91, 33, 17], [97, 3, 56], [15, 67, 48], [54, 25, 81]] &#125;, &#123; name:'数据列 3', data: [[47, 47, 21], [20, 12, 4], [6, 76, 91], [38, 30, 60], [57, 98, 64], [61, 17, 80], [83, 60, 13], [67, 78, 75], [64, 12, 10], [30, 77, 82]] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 误差线图 - (errorbar)：示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;误差图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://img.hcharts.cn/highcharts/highcharts-more.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; zoomType: 'xy' &#125;, title: &#123; text: '误差图' &#125;, xAxis: [&#123; categories: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'] &#125;], yAxis: [&#123; // Primary yAxis labels: &#123; format: '&#123;value&#125; °C', style: &#123; color: Highcharts.getOptions().colors[1] &#125; &#125;, title: &#123; text: '温度', style: &#123; color: Highcharts.getOptions().colors[1] &#125; &#125; &#125;, &#123; // Secondary yAxis title: &#123; text: '降水', style: &#123; color: Highcharts.getOptions().colors[0] &#125; &#125;, labels: &#123; format: '&#123;value&#125; mm', style: &#123; color: Highcharts.getOptions().colors[0] &#125; &#125;, opposite: true &#125;], tooltip: &#123; shared: true &#125;, series: [&#123; name: '降水', type: 'column', yAxis: 1, data: [49.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4], tooltip: &#123; pointFormat: '&lt;span style="font-weight: bold; color: &#123;series.color&#125;"&gt;&#123;series.name&#125;&lt;/span&gt;: &lt;b&gt;&#123;point.y:.1f&#125; mm&lt;/b&gt; ' &#125; &#125;, &#123; name: '降雨误差', type: 'errorbar', yAxis: 1, data: [[48, 51], [68, 73], [92, 110], [128, 136], [140, 150], [171, 179], [135, 143], [142, 149], [204, 220], [189, 199], [95, 110], [52, 56]], tooltip: &#123; pointFormat: '(误差范围: &#123;point.low&#125;-&#123;point.high&#125; mm)&lt;br/&gt;' &#125; &#125;, &#123; name: '温度', type: 'spline', data: [7.0, 6.9, 9.5, 14.5, 18.2, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6], tooltip: &#123; pointFormat: '&lt;span style="font-weight: bold; color: &#123;series.color&#125;"&gt;&#123;series.name&#125;&lt;/span&gt;: &lt;b&gt;&#123;point.y:.1f&#125;°C&lt;/b&gt; ' &#125; &#125;, &#123; name: '温度误差', type: 'errorbar', data: [[6, 8], [5.9, 7.6], [9.4, 10.4], [14.1, 15.9], [18.0, 20.1], [21.0, 24.0], [23.2, 25.3], [26.1, 27.8], [23.2, 23.9], [18.0, 21.1], [12.9, 14.0], [7.6, 10.0]], tooltip: &#123; pointFormat: '(误差范围: &#123;point.low&#125;-&#123;point.high&#125;°C)&lt;br/&gt;' &#125; &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 漏斗图 - (funnel)：示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;漏斗图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1000px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://img.hcharts.cn/highcharts/modules/funnel.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'funnel', marginRight: 100 &#125;, title: &#123; text: '销售漏斗', x: -50 &#125;, plotOptions: &#123; series: &#123; dataLabels: &#123; enabled: true, format: '&lt;b&gt;&#123;point.name&#125;&lt;/b&gt; (&#123;point.y:,.0f&#125;)', color: 'black', softConnector: true &#125;, neckWidth: '30%', neckHeight: '25%' //-- Other available options // height: pixels or percent // width: pixels or percent &#125; &#125;, legend: &#123; enabled: false &#125;, series: [&#123; name: '用户', data: [ ['访问网站', 15654], ['下载产品', 4064], ['询价', 1987], ['发送合同', 976], ['成交', 846] ] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 蜘蛛图：示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;蜘蛛图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; min-width: 400px; max-width: 600px; height: 400px; margin: 0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://img.hcharts.cn/highcharts/highcharts-more.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; polar: true, type: 'line' &#125;, title: &#123; text: '预算与支出', x: -80 &#125;, pane: &#123; size: '80%' &#125;, xAxis: &#123; categories: ['销售', '市场营销', '发展', '客户支持', '信息技术', '行政管理'], tickmarkPlacement: 'on', lineWidth: 0 &#125;, yAxis: &#123; gridLineInterpolation: 'polygon', lineWidth: 0, min: 0 &#125;, tooltip: &#123; shared: true, pointFormat: '&lt;span style="color:&#123;series.color&#125;"&gt;&#123;series.name&#125;: &lt;b&gt;$&#123;point.y:,.0f&#125;&lt;/b&gt;&lt;br/&gt;' &#125;, legend: &#123; align: 'right', verticalAlign: 'top', y: 70, layout: 'vertical' &#125;, series: [&#123; name: '预算拨款', data: [43000, 19000, 60000, 35000, 17000, 10000], pointPlacement: 'on' &#125;, &#123; name: '实际支出', data: [50000, 39000, 42000, 31000, 26000, 14000], pointPlacement: 'on' &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 极地图：示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;极地图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; min-width: 400px; max-width: 600px; height: 400px; margin: 0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://img.hcharts.cn/highcharts/highcharts-more.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; polar: true &#125;, title: &#123; text: '极地图' &#125;, pane: &#123; startAngle: 0, endAngle: 360 &#125;, xAxis: &#123; tickInterval: 45, min: 0, max: 360, labels: &#123; formatter: function () &#123; return this.value + '°'; &#125; &#125; &#125;, yAxis: &#123; min: 0 &#125;, plotOptions: &#123; series: &#123; pointStart: 0, pointInterval: 45 &#125;, column: &#123; pointPadding: 0, groupPadding: 0 &#125; &#125;, series: [&#123; type: 'column', name: '柱形', data: [8, 7, 6, 5, 4, 3, 2, 1], pointPlacement: 'between' &#125;, &#123; type: 'line', name: '线', data: [1, 2, 3, 4, 5, 6, 7, 8] &#125;, &#123; type: 'area', name: '面积', data: [1, 8, 2, 7, 3, 6, 4, 5] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 参考资料： HighCharts官网 HighCharts中文网 HighCharts中文社区 HighCharts官网API]]></content>
      <categories>
        <category>Charts</category>
      </categories>
      <tags>
        <tag>HighCharts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『构建工具-Webpack』相关内容整理]]></title>
    <url>%2F2017%2F07%2F23%2Fwebpack-note%2F</url>
    <content type="text"><![CDATA[Webpack是什么？ webpack is a module bundler.Webpack是一个模块打包器。 webpack 是一个现代 JavaScript 应用程序的模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成少量的 bundle - 通常只有一个，由浏览器加载。 Webpack的特点： 代码拆分： Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。 Loader： Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成Javascript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。 智能解析： Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 js 文件。甚至在加载依赖的时候，允许使用动态表达式 require(“./templates/“ + name + “.jade”)。 插件系统： Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。 快速运行： Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。 Webpack与Gulp的区别？ gulp: gulp强调的是前端开发的工作流程，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程。 PS：Automate and enhance your workflow webpack: webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。 PS：webpack is a module bundle Webpack的核心概念：Web是高度可配置的，在开始前需要先理解四个核心概念：入口(entry)、输出(output)、loader、插件(plugins)。 entry: 在 webpack 中，我们使用 webpack 配置对象(webpack configuration object)中的 entry 属性来定义入口。看一个最简单的例子： 123module.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;&#125;; Output:将所有的资源(assets)归拢在一起后，还需要告诉 webpack 在哪里打包应用程序。webpack 的 output 属性描述了如何处理归拢在一起的代码(bundled code)。例子： 123456789const path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; &#125;&#125;; Loader: webpack loader 在文件被添加到依赖图中时，其转换为模块。例子： 12345678910111213141516const path = require(&apos;path&apos;);const config = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125; ] &#125;&#125;;module.exports = config; Plugins：想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 来创建它的一个实例。例子： 12345678910111213141516171819202122const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //installed via npmconst webpack = require(&apos;webpack&apos;); //to access built-in pluginsconst path = require(&apos;path&apos;);const config = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;) ]&#125;;module.exports = config; 参考资料:核心概念简介 Webpack的安装配置：前提条件:请安装和使用 Node.js 最新的长期支持版本(LTS - Long Term Support)，使用旧版本，你可能遇到各种问题，因为它们可能缺少 webpack 功能以及/或者缺少相关 package 包。 本地安装：最新版本的webpack是: Github-Webpack-Releases1npm install -g webpack --save-dev 安装完成之后，会在package.json中会添加如下信息： 123&quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^3.4.1&quot;&#125; 对于大多数项目，建议本地安装。这可以使我们在引入破坏式变更(breaking change)的依赖时，更容易分别升级项目。一般不推荐全局安装 webpack。这会将您项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中，可能会导致构建失败。 Webpack的简单使用:构建项目：新建一个index.js文件，在跟该文件中编写一个函数： 1234// index.js 文件function func(str) &#123; alert(str);&#125; 编写完成之后可以使用webpack命令了来打包index.js文件，如下所示： 12345678910语法: webpack [待打包文件] [打包完成文件名]例子: webpack index.js index.bundle.js➜ js webpack index.js index.bundle.jsHash: 72aeecc257bb3571dac7Version: webpack 3.4.1Time: 61ms Asset Size Chunks Chunk Namesindex.bundle.js 2.51 kB 0 [emitted] main [0] ./index.js 37 bytes &#123;0&#125; [built] 打包输出信息说明： Name Description Hash 文件的HASH值 Version webpack的版本 Time 打包所花费的时间 Asset 打包生成的文件 Size 生成文件的大小 Chunks 打包的分块 Chunk Names 打包的块名称 这样就完成了一次简单的打包操作，打包完成之后可以打开index.bundle.js查看一下，Webpack会自动给该文件中添加一些注释还会给一些模块进行编号。 参考资料：Webpack官网简单Demo Webpack的基本配置:按照如下目录结构进行构建一个项目： 1234567891011121314151617➜ ~ tree WebpackWebpack├── dist│ ├── css│ └── js├── node_modules├── package-lock.json├── package.json├── src│ ├── css│ │ └── style.css│ ├── index.html│ └── js│ └── index.js└── webpack.config.js7 directories, 6 files webpack.config.js编写webpack.config.js文件： 123456789101112131415161718const webpack = require(&apos;webpack&apos;);module.exports = &#123; entry:&apos;./src/js/index.js&apos;, output:&#123; path:&apos;/Users/Yang/Documents/Webstorm-Work/Webpack/dist/js&apos;, // 设置输出目录 filename:&apos;[name].bundle.js&apos; // 输出文件名 &#125;,module:&#123; loaders:[ test:/\.css$/,//支持正则 loader:&apos;style-loader!css-loader&apos; ] &#125;,resolve:&#123; //添加在此的后缀所对应的文件可以省略后缀 extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;, &apos;.css&apos;, &apos;.scss&apos;] &#125;,plugins:[ new webpack.BannerPlugin(&apos;This file is created by ly&apos;); // 插件设置 ]&#125; Webpack的Loader使用：loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 简单示例：可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loader： 12npm install --save-dev css-loader # CSS loadernpm install --save-dev ts-loader # TypeScript loader 然后指示 webpack 对每个 .css 使用 css-loader，以及对所有 .ts 文件使用 ts-loader： webpack.config.js 12345678module.exports = &#123; module: &#123; rules: [ &#123; test: /\.css$/, use: &apos;css-loader&apos; &#125;, &#123; test: /\.ts$/, use: &apos;ts-loader&apos; &#125; ] &#125;&#125;; 使用 Loader：在应用程序中，有三种使用 loader 的方式： 配置（推荐）：在 webpack.config.js 文件中指定 loader。 内联：在每个 import 语句中显式指定 loader。 CLI：在 shell 命令中指定它们。 配置[Configuration]:module.rules 允许你在 webpack 配置中指定多个 loader。 这是展示 loader 的一种简明方式，并且有助于使代码变得简洁。同时让你对各个 loader 有个全局概览： 12345678910111213141516module: &#123; rules: [ &#123; test: /\.css$/, use: [ &#123; loader: &apos;style-loader&apos; &#125;, &#123; loader: &apos;css-loader&apos;, options: &#123; modules: true &#125; &#125; ] &#125; ]&#125; 内联:可以在 import 语句或任何等效于 “import” 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。 1import Styles from &apos;style-loader!css-loader?modules!./styles.css&apos;; 通过前置所有规则及使用 !，可以对应覆盖到配置中的任意 loader。 选项可以传递查询参数，例如 ?key=value&amp;foo=bar，或者一个 JSON 对象，例如 ?{&quot;key&quot;:&quot;value&quot;,&quot;foo&quot;:&quot;bar&quot;}。 尽可能使用 module.rules，因为这样可以减少源码中的代码量，并且可以在出错时，更快地调试和定位 loader 中的问题。 CLI:你也可以通过 CLI 使用 loader： 1webpack --module-bind jade-loader --module-bind &apos;css=style-loader!css-loader&apos; 这会对 .jade 文件使用 jade-loader，对 .css 文件使用 style-loader 和 css-loader。 Loader 特性: loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照先后顺序进行编译。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。 loader 可以是同步的，也可以是异步的。 loader 运行在 Node.js 中，并且能够执行任何可能的操作。 loader 接收查询参数。用于对 loader 传递配置。 loader 也能够使用 options 对象进行配置。 除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。 插件(plugin)可以为 loader 带来更多特性。 loader 能够产生额外的任意文件。 loader 通过（loader）预处理函数，为 JavaScript 生态系统提供了更多能力。用户现在可以更加灵活地引入细粒度逻辑，例如压缩、打包、语言翻译和其他更多。 解析 Loader:loader 遵循标准的模块解析。多数情况下，loader 将从模块路径（通常将模块路径认为是 npm install, node_modules）解析。 loader 模块需要导出为一个函数，并且使用 Node.js 兼容的 JavaScript 编写。通常使用 npm 进行管理，但是也可以将自定义 loader 作为应用程序中的文件。按照约定，loader 通常被命名为 xxx-loader（例如 json-loader）。有关详细信息，请查看如何编写 loader？。 参考资料：Webpack-Loader详解 Webpack的CLI使用:Output：通过以下这些配置，你可以调整构建流程的某些输出参数。 常用参数说明： 参数 说明 输入类型 默认值 –output-chunk-filename 输出的附带 chunk 的文件名 string 含有[id] 的文件名，而不是 [name] 或者 [id] 作为前缀 –output-filename 打包文件的文件名 string [name].js –output-jsonp-function 加载 Chunk 时使用的 JSONP 函数名 string webpackJsonp –output-library 以库的形式导出入口文件 string –output-library-target 以库的形式导出入口文件时，输出的类型 string var –output-path 输出的路径（在公共路径的基础上） string 当前目录 –output-pathinfo 加入一些依赖信息的注解 boolean false –output-public-path 输出文件时使用的公共路径 string / –output-source-map-filename 生成的 SourceMap 的文件名 string [name].map or [outputFilename].map Debug：以下这些配置可以帮助你在 Webpack 编译过程中更好地 debug。 常用参数说明： 参数 说明 输入类型 默认值 –debug 把 loader 设置为 debug 模式 boolean false –devtool 为打包好的资源定义source map 的类 string - –progress 打印出编译进度的百分比值 boolean false Model：这些配置可以用于绑定 Webpack 允许的模块。 常用参数说明： 参数 说明 使用方法 –module-bind 为 loader 绑定一个扩展 –module-bind js=babel-loader –module-bind-post 为 post loader 绑定一个扩展 –module-bind-pre 为 pre loader 绑定一个扩展 Watch:这些配置可以用于观察依赖文件的变化，一旦有变化，则可以重新执行构建流程。 常用参数说明： 参数 说明 –watch, -w 观察文件系统的变化 –save, -s 在保存的时候重新编译，无论文件是否变化 –watch-aggregate-timeout 指定一个毫秒数，在这个时间内，文件若发送了多次变化，会被合并 –watch-poll 轮询观察文件变化的时间间隔（同时会打开轮询机制 –watch-stdin, –stdin 当 stdin 关闭时，退出进程 Optimize：在生产环境的构建时，这些配置可以用于调整的一些性能相关的配置。 常用参数说明： 参数 解释说明 使用的插件 –optimize-max-chunks 限制 chunk 的数量 LimitChunkCountPlugin –optimize-min-chunk-size 限制 chunk 的最小体积 MinChunkSizePlugin –optimize-minimize 压缩混淆 javascript，并且把 loader 设置为 minimizing UglifyJsPlugin &amp; LoaderOptionsPlugin Resolve：这些配置可以用于设置 webpack resolver 时使用的别名(alias)和扩展名(extension)。 常用参数说明： 参数 说明 示例 –resolve-alias 指定模块的别名 –resolve-alias jquery-plugin=jquery.plugin –resolve-extensions 指定需要被处理的文件的扩展名 –resolve-extensions .es6 .js .ts –resolve-loader-alias Minimize javascript and switches loaders to minimizing Display：以下选项用于配置 Webpack 在控制台输出的统计数据，以及这些数据的样式。 常用参数说明： 参数 说明 类型 –color, –colors 开启/关闭控制台的颜色 [默认值: (supports-color)] boolean –display-cached 在输出中显示缓存的模块 boolean –display-cached-assets 在输出中显示缓存的 assets boolean –display-chunks 在输出中显示 chunks boolean –display-depth 显示从入口起点到每个模块的距离 boolean –display-entrypoints 在输出中显示入口文件 boolean –display-error-details 显示详细的错误信息 boolean –display-exclude 在输出中显示被排除的文件 boolean –display-max-modules 设置输出中可见模块的最大数量 number –display-modules 在输出中显示所有模块，包括被排除的模块 boolean –display-optimization-bailout 作用域提升回退触发器(Scope hoisting fallback trigger)（从 webpack 3.0.0 开始） boolean –display-origins 在输出中显示最初的 chunk boolean –display-provided-exports 显示有关从模块导出的信息 boolean –display-reasons 显示模块包含在输出中的原因 boolean –display-used-exports 显示模块中被使用的接口（Tree Shaking） boolean –hide-modules 隐藏关于模块的信息 boolean –sort-assets-by 对 assets 列表以某种属性排序 string –sort-chunks-by 对 chunks 列表以某种属性排序 string –sort-modules-by 对模块列表以某种属性排序 string –verbose 显示更多信息 boolean –display 选择显示预设(verbose - 繁琐, detailed - 细节, normal - 正常, minimal - 最小, errors-only - 仅错误, none - 无; 从 webpack 3.0.0 开始) string Other： 参数 说明 用法 –bail 一旦发生错误，立即终止 –cache 开启缓存 [watch 时会默认打开] –cache=false –define 定义 bundle 中的任意自由变量，查看 shimming –define process.env.NODE_ENV=’development’ –hot 开启模块热替换 [使用 HotModuleReplacementPlugin] -hot=true –labeled-modules Enables 开启模块标签 [使用 LabeledModulesPlugin] -plugin 加载某个插件 –prefetch 预加载某个文件 –prefetch=./files.js –provide 在所有模块中将这些模块提供为自由变量，查看 shimming –provide jQuery=jquery –records-input-path 记录文件的路径（读取） –records-output-path 记录文件的路径（写入） –records-path 记录文件的路径 –target 目标的执行环境 –target=’node’ 参考资料：Webpack-CLI使用 参考资料: Webpack 1.x 官方文档 Webpack 2.x 官方文档 Webpack 中文网 Webpack 视频教程 Webpack-API]]></content>
      <categories>
        <category>Build Tools</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『构建工具-Maven』相关内容整理]]></title>
    <url>%2F2017%2F07%2F04%2Fmaven-note%2F</url>
    <content type="text"><![CDATA[Maven-工具简介: Apache Maven是跨平台的项目管理工具，主要服务于基于Java平台的项目构建、依赖管理和项目信息管理。Maven可以自动化构建过程，从清理、编译、测试到生成报告，再到打包和部署。Maven最大化地消除了构建的重复，抽象了构建生命周期，并且为绝大部分的构建任务提供了已实现的插件，我们不再需要定义过程，甚至不需要再去实现这些过程中的一些任务。 最简单的例子就是测试，我们没必要告诉Maven去测试，更不需要告诉Maven如何运行测试，只需要遵循Maven的约定编写好测试用例当我们运行构建的时候，这些测试便会自动运行。 Maven-环境配置: Maven是一个基于Java的构建工具，所以在安装Maven之前必须配置好Java的相关环境。 检查JAVA环境是否正常: 1java -version 下载并解压Maven: 下载 123 Mac用户可以使用[Homebrew](https://brew.sh/)来安装Mavenbrew search maven # 搜索brew install maven # 安装 设置Maven环境变量: 12export M2_HOME=/Users/Hostname/Software/apache-maven-3.3.9export PATH=$PATH:$M2_HOME/bin 验证Maven是否安装成功: 1234567输入： mvn -v 或者 mvn -versionApache Maven 3.3.9 (bb52d8502b132ec38323dc5; 2015-11-11T00:41:47+08:00)Maven home: /Users/Hostname/Software/apache-maven-3.3.9Java version: 1.8.0_121, vendor: Oracle CorporationJava home: /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jreDefault locale: zh_CN, platform encoding: UTF-8OS name: &quot;mac os x&quot;, version: &quot;10.12.3&quot;, arch: &quot;x86_64&quot;, family: &quot;mac&quot; Maven-POM:什么是POM?POM 代表工程对象模型。它是使用 Maven 工作时的基本组建，是一个 xml 文件。它被放在工程根目录下，文件命名为 pom.xml。POM 包含了关于工程和各种配置细节的信息，Maven 使用这些信息构建工程。 * project dependencies * plugins * goals * build profiles * project version * developers * mailing list 在仓库中工程组（groupId），及其名称（artifactId）和版本这些属性是工程的唯一标识。 POM文件示例：&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;ws.object&lt;/groupId&gt; &lt;artifactId&gt;mvnPro&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;mvnPro&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 需要说明的是每个工程应该只有一个 POM 文件。 所有的 POM 文件需要 project 元素和三个必须的字段：groupId, artifactId,version。 在仓库中的工程标识为 groupId:artifactId:version POM.xml 的根元素是 project，它有三个主要的子节点： POM文件节点详解： 节点 描述 groupId 这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，一个银行组织 ws.object.mvn 拥有所有的和银行相关的项目。 artifactId 这是工程的标识。它通常是工程的名称。例如，消费者银行。groupId和artifactId 一起定义了 artifact 在仓库中的位置。 version 这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。例如:ws.object.mvn:consumer-banking:1.0 ws.object.mvn:consumer-banking:1.1. Maven-构建生命周期什么是构建?除了编写源代码，我们每天有相当一部分时间花在了编译、运行单元测试、生成文档、打包和部署等繁琐而不起眼的工作上，这就是构建（build）。 Maven的三套生命周期Maven有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，一般容易将Maven的生命周期看成一个整体，其实不然。这三套生命周期分别是： Clean Lifecycle 在进行真正的构建之前进行一些清理工作。 Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。 Site Lifecycle 生成项目报告，站点，发布站点。 我再次强调一下它们是相互独立的，你可以仅仅调用clean来清理工作目录，仅仅调用site来生成站点。当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。 每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行mvn clean ，这个的clean是Clean生命周期的一个阶段。Clean生命周期，也有clean阶段。Clean生命周期一共包含了三个阶段： pre-clean 执行一些需要在clean之前完成的工作 clean 移除所有上一次构建生成的文件 post-clean 执行一些需要在clean之后立刻完成的工作 Site生命周期的各个阶段： pre-site 执行一些需要在生成站点文档之前完成的工作 site 生成项目的站点文档 post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 site-deploy 将生成的站点文档部署到特定的服务器上 Default生命周期：Maven中最重要的Default生命周期,绝大部分工作都发生在这个生命周期中，下面列出一些常用的阶段： 生命周期阶段 描述 validate 检查工程配置是否正确，完成构建过程的所有必要信息是否能够获取到。 initialize 初始化构建状态，例如设置属性。 generate-sources 生成编译阶段需要包含的任何源码文件。 process-sources 处理源代码，例如，过滤任何值（filter any value）。 generate-resources 生成工程包中需要包含的资源文件。 process-resources 拷贝和处理资源文件到目的目录中，为打包阶段做准备。 compile 编译工程源码。 process-classes 处理编译生成的文件，例如 Java Class 字节码的加强和优化。 generate-test-sources 生成编译阶段需要包含的任何测试源代码。 process-test-sources 处理测试源代码，例如，过滤任何值（filter any values)。 test-compile 编译测试源代码到测试目的目录。 process-test-classes 处理测试代码文件编译后生成的文件。 test 使用适当的单元测试框架（例如JUnit）运行测试。 prepare-package 在真正打包之前，为准备打包执行任何必要的操作。 package 获取编译后的代码，并按照可发布的格式进行打包，例如 JAR、WAR或者EAR文件。 pre-integration-test 在集成测试执行之前，执行所需的操作。例如，设置所需的环境变量。 integration-test 处理和部署必须的工程包到集成测试能够运行的环境中。 post-integration-test 在集成测试被执行后执行必要的操作。例如，清理环境。 verify 运行检查操作来验证工程包是有效的，并满足质量要求。 install 安装工程包到本地仓库中，该仓库可以作为本地其他工程的依赖。 deploy 拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程。 Maven-仓库什么是 Maven 仓库？在 Maven 的术语中，仓库是一个位置（place），例如目录，可以存储所有的工程 jar 文件、library jar 文件、插件或任何其他的工程指定的文件。 Maven 仓库有三种类型： 本地（local） 中央（central） 远程（remote） 本地仓库:Maven 本地仓库是机器上的一个文件夹。它在你第一次运行任何 maven 命令的时候创建。 Maven 本地仓库保存你的工程的所有依赖（library jar、plugin jar 等）。当你运行一次 Maven 构建，Maven会自动下载所有依赖的 jar 文件到本地仓库中。它避免了每次构建时都引用存放在远程机器上的依赖文件。Maven 本地仓库默认被创建在 %USER_HOME% 目录下。要修改默认位置，在 %M2_HOME%\conf 目录中的 Maven 的 settings.xml 文件中定义另一个路径。 ​1234567&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; &lt;localRepository&gt;/Users/HostName/Public/MavenRepository&lt;/localRepository&gt;&lt;/settings&gt;​ 中央仓库:Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。中央仓库的关键概念： * 这个仓库由 Maven 社区管理。 * 不需要配置。 * 需要通过网络才能访问。 要浏览中央仓库的内容，maven 社区提供了一个 URL：http://search.maven.org/#browse。使用这个仓库，开发人员可以搜索所有可以获取的代码库。 远程仓库:如果 Maven 在中央仓库中也找不到依赖的库文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的jar 文件。举例说明，使用下面的 POM.xml，Maven 将从远程仓库中下载该 pom.xml 中声明的所依赖的（在中央仓库中获取不到的）文件。 ​123456789101112131415161718192021222324252627&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;ws.object&lt;/groupId&gt; &lt;artifactId&gt;mvnPro&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.companyname.common-lib&lt;/groupId&gt; &lt;artifactId&gt;common-lib&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependencies&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;companyname.lib1&lt;/id&gt; &lt;url&gt;http://download.companyname.org/maven2/lib1&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;companyname.lib2&lt;/id&gt; &lt;url&gt;http://download.companyname.org/maven2/lib2&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt;​ Maven 依赖搜索顺序: 当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库： 1. 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。 2. 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中已被将来引用。 3. 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。 4. 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库已被将来引用，否则 Maven将停止处理并抛出错误（无法找到依赖的文件）。 Maven-插件什么是 Maven 插件？Maven实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。Maven插件通常被用来： 创建 jar 文件 创建 war 文件 编译代码文件 代码单元测试 创建工程文档 创建工程报告 插件通常提供了一个目标的集合，并且可以使用下面的语法执行： 1mvn [plugin-name]:[goal-name] 例如，一个 Java 工程可以使用 maven-compiler-plugin 的 compile-goal 编译，使用以下命令： 1mvn compiler:compile 插件类型Maven 提供了下面两种类型的插件： 类型 描述 Build plugins 在构建时执行，并在 pom.xml 的元素中配置。 Reporting plugins 在网站生成过程中执行，并在 pom.xml 的元素中配置。 ###常用插件列表： 插件 描述 clean 构建之后清理目标文件。删除目标目录。 compiler 编译 Java 源文件。 surefile 运行 JUnit 单元测试。创建测试报告。 jar 从当前工程中构建 JAR 文件。 war 从当前工程中构建 WAR 文件。 javadoc 为工程生成 Javadoc。 antrun 从构建过程的任意一个阶段中运行一个 ant 任务的集合。 Maven-创建工程Maven 使用原型（archetype）插件创建工程。要创建一个简单的Java应用，我们将使用 maven-archetype-quickstart 插件。在下面的例子中，我们将创建一个基于 maven 的 java 应用工程。 12345mvn archetype:generate \-DgroupId=ws.object \-DartifactId=Example \-DarchetypeArtifactId=maven-archetype-quickstart \-DinteractiveMode=false 12345678910111213[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building Maven Stub Project (No POM) 1[INFO] ------------------------------------------------------------------------……------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 4.277 s[INFO] Finished at: 2017-07-13T14:10:19+08:00[INFO] Final Memory: 14M/214M[INFO] ------------------------------------------------------------------------ 出现 BUILD SUCCESS 即项目创建成功！ 模板 含义 mvn archetype:generate 固定格式 -DgroupId 组织标识（包名) -DartifactId 项目名称 -DinteractiveMode 是否使用交互模式 -DarchetypeArtifactId 指定ArchetypeId，maven-archetype-quickstart,创建一个Java Project；maven-archetype-webapp，创建一个Web Project Maven-工程模板(archetype)Maven 使用原型（Archetype）概念为用户提供了大量不同类型的工程模版（614 个）。Maven 使用下面的命令帮助用户快速创建 java 项目。 1mvn archetype:generate 什么是原型？ 原型是一个 Maven 插件，它的任务是根据模板创建一个项目结构。我们将使用 quickstart 原型插件创建一个简单的 java 应用程序。 Maven-web应用 创建 Web 应用建立一个简单的 Java web 应用，我们可以使用 maven-archetype-webapp 插件。首先我们打开terminal，输入以下的 mvn 命令。mvn archetype:generate \-DgroupId=ws.object.example \-DartifactId=example \-DarchetypeArtifactId=maven-archetype-webapp \-DinteractiveMode=falseMaven 将开始处理并且将创建完整的基于 Web 的 java 应用工程结构。 Maven-参考资料 Maven官网:http://maven.apache.org/ 官网介绍:http://maven.apache.org/what-is-maven.html Wikipedia:https://zh.wikipedia.org/wiki/Apache_Maven Maven教程:http://www.yiibai.com/maven/ Maven详解:http://www.cnblogs.com/hongwz/p/5456578.html 国外Maven教程:http://www.tutorialspoint.com/maven/index.htm 常用骨架简介:http://www.cnblogs.com/iusmile/archive/2012/11/14/2770118.html]()]]></content>
      <categories>
        <category>Build Tools</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lombok - 使用注解让你的JavaBean变得更加简洁]]></title>
    <url>%2F2017%2F06%2F23%2Flombok-note-md%2F</url>
    <content type="text"><![CDATA[Lombok - 工具简介：Lombok是一个编译时注释预处理器，有助于在编译时注入一些代码。Lombok提供了一组在开发时处理的注释，以将代码注入到Java应用程序中，注入的代码在开发环境中立即可用。在详细介绍之前，可以去其官网看一下作者提供的视频，视频中阐述了Lombok 的简单用法。https://projectlombok.org/ Lombok - 安装过程：基于 Maven：示例代码： 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加好 Maven 依赖之后，就可以在代码中使用 Lombok 的注解来简化代码了。 基于IntelliJ IDEA：安装 Lombok IntelliJ plugin:Jetbrains IntelliJ IDEA Editor完全兼容 Lombok，要在 IDEA 中使用 Lombok，那就需要在IntelliJ IDEA 中安装 Lombok IntelliJ plugin 插件，以下为安装步骤： Go to File &gt; Settings &gt; Plugins Click on Browse repositories... Search for Lombok Plugin Click on Install plugin Restart IntelliJ IDEA 具体安装过程可参考官网或者插件 Github 主页。 在IntelliJ IDEA使用Lombok: Go to Refactor &gt; Lombok 在打开的 JavaBean 文件中按照需求添加相应的注解即可。 Lombok - 常用注解：你如果是使用IDEA的话，在当前文件上按command+F12，或者长按command在左侧找到Structure，就能够看到 lombok 为当前类生成的方法。 @Data ：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法 示例代码： 12345678import lombok.Data;@Datapublic class Person &#123; private String firstName; private String lastName; private String job;&#125; @Setter/@Getter：注解在属性或类上；为属性提供 Setter/Getter 方法 示例代码： 1234567891011import lombok.Getter;import lombok.Setter;// 只为 firstName 生成Getter、Setter 方法public class Person &#123; @Getter @Setter private String firstName; private String lastName; private String job;&#125; 123456789101112import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class Person &#123;// 为所有字段生成Getter、Setter 方法 private String firstName; private String lastName; private String job;&#125; @Log4j ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象 @Value：此注解集@equals()、@hashCode()、@toString()、@Getter()于一身。 示例代码： 123456789101112131415import lombok.Value;import lombok.experimental.NonFinal;@Valuepublic class Person &#123; /** 类本身以及类中所有的字段都是private final类型的，不会生成Setter方法。 * 可以通过显式指定某个注解覆盖掉默认的属性。 * 通过@NonFinal注解修饰的字段，不是final类型的。 */ String firstName; String lastName; @NonFinal String job;&#125; ​ @NoArgsConstructor/@AllArgsConstructor: 自动生成无参数构造函数/全参构造函数。 示例代码： 123456789101112import lombok.AllArgsConstructor;import lombok.NoArgsConstructor;@NoArgsConstructor@AllArgsConstructorpublic class Person &#123; private String firstName; private String lastName; private String job;&#125; ​ @NonNull :修饰方法、构造函数的参数或者类字段，Lombok自动生成一个非空检测语句。 示例代码： 12345678import lombok.NonNull;public class Person&#123; public String Example(@NonNull String sum)&#123; return null; &#125;&#125; ​ @Synchronized 将方法变成同步方法 @SneakyThrows：将受检异常转换为非受检异常，避免抛出或尝试语句。 ​ lombok 项目官网上还有一些其他注解的用法，此处就不列举了，附链接：https://projectlombok.org/features/all 参考资料： Lombok Official Website Lombok Github Lombok IntelliJ plugin]]></content>
      <categories>
        <category>Java Tools</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Lombok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『Enterprise Java - Servlet』 在 Java8中使Servlet 3.1]]></title>
    <url>%2F2017%2F06%2F05%2Fentjava-servlet%2F</url>
    <content type="text"></content>
      <categories>
        <category>Ent Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『管理工具-NPM』相关内容整理]]></title>
    <url>%2F2017%2F05%2F09%2Fnpm-note%2F</url>
    <content type="text"><![CDATA[NPM是什么？ npm（全称 Node Package Manager，即node包管理器）是Node.js默认的、以JavaScript编写的软件包管理系统。 NPM的使用场景: 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用 NPM-工作原理： npm依赖解析的主要思想：尽可能地减少间接依赖安装目录的深度，最理想的情况是与直接依赖安装在同一目录下，通过这种方式来减少依赖目录的嵌套，缓解整个依赖目录层次过深的问题。（因为 Windows 中文件路径的长度不能大于 260 个字符。） 参考资料：NPM基本用法和使用技巧 NPM-基础操作：NPM是随同Node.js一起安装的包管理工具，所以我们只需要安装nodejs就可以同时安装成功NPM。 安装Node.js并更新npmWin系统：进入Node.js 官方网站，找到 Downloads 栏目，选择适合自己系统的安装包进行安装。 MacOS系统：在MacOS系统上建议先安装Homebrew，然后使用homebrew来安装NPM。 12brew search nodejs #搜索brew install nodejs #安装 CentOS系统：在CentOS系统上，我们可以使用yum命令来安装Node.js,前提是需要配置好yum源。 1yum -y install nodejs Ubuntu系统：在 Ubuntu系统上，我们可以使用apt-get方式来安装Node.js。 1apt-get install nodejs 安装完成并且配置好相关环境之后，我们可以再Terminal中输入node -v 和npm -v分别来测试nodejs和npm是否安装成功。 npm常用参数： -g, –global：安装全局依赖，如果没有指定依赖包名，则将当前目录中的包安装至全局 -S, –save：安装依赖的同时将该依赖写入 dependencies -D, –save-dev：安装依赖的同时将该依赖写入 devDependencies -O, –save-optional：安装依赖的同时将该依赖写入 optionalDependencies -E, –save-exact：写入 package.json 时带有确切版本号 –no-optional：不安装 optional dependencies，可继承 –only={dev[elopment]|prod[uction]}：无视 NODE_ENV，只安装 devDependencies 或仅安装除了 devDependencies 之外的依赖项 –dry-run：走一遍安装的过程并报告结果，但实际上没有安装任何依赖 在本地安装npm软件包有两种方法来安装NPM包：本地或全局，你选择哪一种安装使用基于你想如何使用包。 如果你想使用类似的Node.js依赖于包从自己的模块 require，然后要在本地安装，这是npm install的默认行为。在另一方面，如果你想使用它作为一个命令行工具，像繁重的CLI的东西，那么你要在全局安装它。 npm install命令的使用可在下文npm-cli部分查看。 init初始化项目：12npm init #在项目根目录下使用它会创建一个package.json文件,需要填写一些内容，详见下文npm init -y # 在package.json文件中全部使用默认选项 使用 package.json管理本地安装的npm软件包的最佳方法是创建一个package.json文件。 一个package.json文件为你提供了很多方便： - 它作为您的项目所依赖的包的文档。 - 它允许您使用语义版本控制规则来指定项目可以使用的包的版本。 - 使您的构建可重复，这意味着它的方式更容易与其他开发人员共享。 package.json语法： “name” 全部小写 一个字，没有空格 破折号和下划线允许 “version” 的形式 x.x.x 遵循semver spec命名规范 demo: 1234&#123; &quot;name&quot;: &quot;my-awesome-package&quot;, &quot;version&quot;: &quot;1.0.0&quot;&#125; 其他字段释义： 字段名称 说明 name 当前项目名称 version 项目版本信息，默认为1.0.0 description 来自readme的信息，否则为空字符串 “” main 默认为index.js scripts 默认情况下会创建一个空test脚本 keywords 关键词信息，默认空 author 作者信息，默认空 license 软件许可证 ISC bugs 来自当前项目的信息（如果存在） homepage 来自当前项目的信息（如果存在） dependencies 您的应用程序在生产中需要这些软件包 devDependencies 这些软件包仅用于开发和测试 安装npm软件包安装本地(local)软件包:1npm install &lt;packageName&gt; # 需要在当前项目项目根目录下，与package.json 文件在同一目录下 安装全局(global)软件包:1npm install -g &lt;packageName&gt; 在全局安装时出现Permission denied错误时，请在npm指令前加上 sudo(类UNIX系统下) 查看npm软件包查看本地(local)软件包:1npm list # 与package.json 在同一目录下运行 查看全局(global)软件包:1npm list -g # Terminal中运行 更新npm软件包1npm list -g # 查看系统中全局安装过的软件包 应该经常更新您依赖的软件包，以便您可以获得对上游代码进行的任何更改。 更新本地(local)软件包:1npm update &lt;packageName&gt; #对单个包升级 更新全局(global)软件包：npm -g是管理本地全局包的命令。 1234567891011121314➜ ~ npm -g outdated # 使用此命令可以查看那些包有更新：Package Current Wanted Latest Locationcordova 6.5.0 7.0.1 7.0.1create-react-app 1.3.0 1.3.3 1.3.3elf-cli 1.4.0 1.7.0 1.7.0express 4.15.2 4.15.3 4.15.3ionic 2.2.2 3.5.0 3.5.0node-gyp 3.6.0 3.6.2 3.6.2node-inspector 1.0.0 1.1.1 1.1.1npm 4.4.1 5.3.0 5.3.0wechat-api 1.32.0 1.33.0 1.33.0npm update -g &lt;packageName&gt; # 更新全局的软件包 参考:npm升级所有可更新包 卸载npm软件包卸载本地(local)软件包1npm uninstall &lt;packageName&gt; 删除本地模块时你应该思考的问题：是否将在package.json上的相应依赖信息也消除？ npm uninstall 模块: 删除模块，但不删除模块留在package.json中的对应信息 npm uninstall --save 模块: 删除模块，同时删除模块留在package.json中dependencies下的对应信息 npm uninstall --save-dev 模块: 删除模块，同时删除模块留在package.json中devDependencies下的对应信息 卸载全局(global)软件包1npm uninstall -g &lt;packageName&gt; 发布npm包你可以推送任何包含 package.json 文件的文件夹，比如一个 node module ####注册账号 要发布软件包，你必要有一个 npm 账号，如果没有可以使用 npm adduser 创建一个。然后使用 npm login 登录。 参考: 手把手教你用npm发布一个包 如何发布Node模块到NPM社区 Publishing npm packages npm的语义版本控制语义版本控制是许多项目用于传达此版本中的哪些更改的标准。沟通发布中的哪些更改很重要，因为有时这些更改将会破坏依赖于该包的代码。 semver:语义化版本标准Link 作为发布者：如果一个项目将与其他人共享，那么应该从1.0.0项目开始，尽管有些项目在npm不符合这个规则。之后，变更应处理如下： 错误修正和其他微小变化：修补程序释放，增加最后一个数字，例如1.0.1 不破坏现有功能的新功能：轻微释放，增加中间数字，例如1.1.0 破坏向后兼容性的更改：主要版本，增加第一个数字，例如2.0.0 作为使用者：作为开发者，可以指定应用程序在package.json文件中可以接受哪些类型的更新。 如果您从1.0.4开始，那么您将如何指定范围： 补丁版本：1.0或1.0.x或~1.0.4 次要版本：1或1.x或^1.0.4 主要版本：*或x NPM-私有模块：你可以使用 NPM 命令行工具来管理你在 NPM 仓库的私有模块代码，这使得在项目中使用公共模块变的更加方便。 准备工作你需要一个 2.7.0 以上版本的 npm ，并且需要有一个可以登陆 npm 仓库的账号。 12npm install -g npmnpm login 软件包配置所有的私有模块都是 scoped package 的。 scope 是 npm 的新特性。如果一个模块的名字以 “@” 开始，那么他就是一个scoped package。scope 就是”@”与”/“之间的部分。 1@scope/project-name 当你注册私有模块到一个用户下时，你的 scope 就是当前用户的用户名。 1@username/project-name 如果要使用npm init 初始化一个软件包，你可以通过自定义 --scope 选项设置你的 scope 1npm init --scope=&lt;your_scope&gt; 如果你在大多数时候使用的 scope 都是相同的，可以设置一个默认的 scope ，这样在我们初始化的时候会自动使用该 scope。 1npm config set scope &lt;your_scope&gt; 发布模块1npm publish 默认情况下，scoped package 会发布为私有模块，发布为私有模块是需要付费的，费用是每个月 $7。 一旦完成发布，你将会在npm库站点上看到你的 scoped package，有 private 标志，说明是非公共的模块，他人无法使用。 私有仓库授权访问如果你要授权给其他人使用你的模块，你可以在 package 的权限设置页面设置哪些用户可以拥有 只读或读写、权限。也可以通过命令行进行相关设置 1npm owner add &lt;user&gt; &lt;package name&gt; 安装私有模块如果要安装私有模块，你必须要有权限访问到要安装的私有模块。安装的时候可以使用 scope package name 1npm install @scope/project-name 当你在项目中使用这些代码模块时可以如下使用 1var project = require(&apos;@scope/project-name&apos;) 参考资料： NPM私有模块 创建一个私有的npm库 NPM-CLI命令： 命令 释义 npm install 安装模块 npm uninstall 卸载模块 npm update 更新模块 npm outdated 检查模块是否已经过时 npm ls 查看安装的模块 npm init 在项目中引导创建一个package.json文件 npm help 查看某条命令的详细帮助 npm root 查看包的安装路径 npm config 管理npm的配置路径 npm cache 管理模块的缓存 npm start 启动模块 npm stop 停止模块 npm restart 重新启动模块 npm test 测试模块 npm version 查看模块版本 npm view 查看模块的注册信息 npm adduser 用户登录 npm publish 发布模块 npm access 在发布的包上设置访问级别 npm package.json 的语法 参考资料： NPM官网 CLI Commands NPM-常用配置：常用配置项: cache：npm 本地缓存目录，默认 ~/.npm cache-max：保持缓存项目且不向 registry 检查的最长时间，单位秒，默认 Infinity，缓存中的数据不会自动删除除非执行 npm cache clean 命令 cache-min：保持缓存项目且不向 registry 检查的最短时间，单位秒，默认 10，可以置为 999999 等以尽量延长缓存生效时间 depth：npm ls 等命令中的默认深度，默认 Infinity editor：npm 默认使用的编辑器 engine-strict：如果置为 true，npm 将会拒绝安装不符合当前 Node.js 版本的模块 force：强力执行一些命令 生命周期脚本执行失败不再阻塞安装过程 发布会覆盖已经发布的版本 访问 registry 时会跳过缓存 global：全局模式 globalconfig：全局配置文件的路径 global-style：以安装全局依赖的方式安装局部依赖，只有直接依赖会被放在顶层依赖目录中 https-proxy：代理 if-present：如果置为 true，npm run-script 就不会在脚本找不到时报错 ignore-scripts：如果置为 true，npm 就不会运行 package.json 定义的脚本 init-module：指定 npm init 命令运行的模块 init-author-name：npm init 使用的默认作者名 init-author-email：npm init 使用的默认作者邮箱 init-author-url：npm init 使用的默认作者 URL init-license：npm init 使用的默认许可证 init-version：npm init 使用的默认版本号 json：npm ls 等命令输出 JSON 格式的数据 link：如果置为 true，如果全局依赖中有合适的包，安装局部依赖时将会直接链接到这个全局依赖的包；如果全局依赖中没有该包的任何版本，则全局安装这个包，并链接到局部依赖中；其他情况则在局部依赖中安装该包 long：npm ls 和 npm search 显示额外信息 message：npm version 写在 git 提交中的信息，%s 将被替换为版本号 npat：安装时运行测试 onload-script：指定一个在 npm 加载时 require() 的包，编程使用 npm 时可能会有用 only：与命令中的 --only 效果类似 optional：如果置为 false，则不安装 optionalDependencies 中的依赖 prefix：指定安装全局依赖的路径 production：如果置为 true，则开启生产模式，npm install 将不安装开发依赖，声明周期脚本运行时自动设置 NODE_ENV=&quot;production&quot; registry：指定 npm registry 的 URL rollback：移除安装失败的模块 save：与命令中的 --save 效果类似 scope：与命令中的 --scope 效果类似 shrinkwrap：如果置为 false，安装时忽略 npm-shrinkwrap.json progress：如果置为 false，不显示进度条 loglevel：设置输出日志的 level，置为 silly 可以显示全部日志 npmrc:配置文件有： 项目配置文件（/path/to/my/project/.npmrc） 用户配置文件（~/.npmrc） 全局配置文件（/path/to/node/etc/npmrc） 内置配置文件（/path/to/npm/npmrc） scripts:npm 支持的生命周期脚本有： prepublish: 发布模块之前执行，也在不带任何参数的局部 npm install 之前执行 publish、postpublish: 发布模块之后执行 preinstall: 安装该模块之前执行 install、postinstall: 安装该模块之后执行 preuninstall、uninstall: 移除该模块之前执行 postuninstall: 移除该模块之后执行 preversion、version: 修改模块版本号之前执行 postversion: 修改模块版本号之后执行 pretest、test、posttest: 在 test 命令的前后执行 prestop、stop、poststop: 在 stop 命令的前后执行 prestart、start、poststart: 在 start 命令的前后执行. prerestart、restart、postrestart: 在 restart 命令的前后执行，如果 restart 脚本没有提供，restart 命令将会执行 stop 脚本再执行 start 脚本 对于自定义名称的脚本，可以通过 npm run-script &lt;pkg&gt; &lt;stage&gt; 来执行，匹配名称的 pre 和 post 命令同样也会执行。 NPM-参考资料： 维基百科 NPM官网 淘宝镜像 NPM手册 NPM命令详解 NPM升级更新包 NPM基本用法和使用技巧 NPM脚本命令学习笔记]]></content>
      <categories>
        <category>Build Tools</category>
      </categories>
      <tags>
        <tag>NPM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『构建工具-Gulp』相关内容整理]]></title>
    <url>%2F2017%2F04%2F26%2Fgulp-note%2F</url>
    <content type="text"><![CDATA[Gulp- 简介 Automate and enhance your workflow | 用自动化构建工具增强你的工作流程 Gulp 是什么？gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用它，不仅可以很愉快的编写代码，而且大大提高我们的工作效率。 gulp是基于Nodejs的自动任务运行器，它能自动化地完成 javascript、coffee、sass、less、html/image、css 等文件的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。通过本文，我们将学习如何使用Gulp来改变开发流程，从而使开发更加快速高效。 gulp 和 grunt 非常类似，但相比于 grunt 的频繁 IO 操作，gulp 的流操作，能更快地更便捷地完成构建工作。 Gulp的核心概念？流，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向。流不但可以处理文件，还可以处理动态内存、网络数据等多种数据形式。 而gulp正是通过流和代码优于配置的策略来尽量简化任务编写的工作。这看起来有点“像jQuery”的方法，把动作串起来创建构建任务。早在Unix的初期，流就已经存在了。流在Node.js生态系统中也扮演了重要的角色，类似于*nix将几乎所有设备抽象为文件一样，Node将几乎所有IO操作都抽象成了stream的操作。因此用gulp编写任务也可看作是用Node.js编写任务。当使用流时，gulp去除了中间文件，只将最后的输出写入磁盘，整个过程因此变得更快。 Gulp的特点? 易于使用: 通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理。 构建快速:利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。 易于学习:通过最少的 API，掌握 gulp 毫不费力，构建工作尽在掌握：如同一系列流管道。 插件高质:gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。 Gulp- 环境搭建gulp 是基于 node 实现的，那么我们就需要先安装 node。 Node是一个基于Google V8 JavaScript引擎建立的一个平台，可以利用它实现Web服务，做类似PHP的事。 12345npm install -g gulp # 全局安装gulp gulp -v # 查看gulp是否安装成功➜ ~ gulp -v [20:17:32] CLI version 3.9.1 Gulp- 构建项目使用Gulp来构建项目:1234567891011121314151617mkdir Gulp &amp;&amp; cd Gulp &amp;&amp; npm init -y &amp;&amp; npm install gulp --save-dev#使用npm初始化项目并且安装Gulp模块,能够看到如下的package.json文件中已经包含了Gulp的相关信息。&#123; &quot;name&quot;: &quot;Gulp&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;gulp&quot;: &quot;^3.9.1&quot; &#125;&#125; gulpfile.js文件的使用： gulp也需要一个文件作为它的主文件，在gulp中这个文件叫做gulpfile.js。 创建gulpfile.js文件，与package.json文件一样放在项目根目录中，之后需要做的就是在gulpfile.js文件中定义任务了。 在gulpfile.js文件中写入以下内容： 1234var gulp = require(&apos;gulp&apos;);gulp.task(&apos;default&apos;, function() &#123; console.log(&quot;Gulp OK!&quot;);&#125;); 完成之后在Terminal中运行gulp命令，然后会看到刚才在task任务中要输出的内容.12345➜ gulp[00:35:29] Using gulpfile ~/WebStrom-Work/Gulp/gulpfile.js[00:35:29] Starting &apos;default&apos;...Gulp OK![00:35:29] Finished &apos;default&apos; after 141 μs Gulp- APIgulp.src()语法：1gulp.src(globs[, options]) 输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中。 名称 类型 含义 globs String 或 Array 所要读取的 glob 或者包含 globs 的数组。 options Object 通过 glob-stream 所传递给 node-glob 的参数。 gulp.dest()语法：1gulp.dest(path[, options]) 能被 pipe 进来，并且将会写文件。并且重新输出（emits）所有数据，因此你可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。 path 类型： String or Function ,文件将被写入的路径（输出目录）。也可以传入一个函数，在函数中返回相应路径，这个函数也可以由 vinyl 文件实例 来提供。 options类型： Object , 为一个可选的参数对象，通常我们不需要用到 gulp.task()语法：1gulp.task(name[, deps], fn) name 类型： String，任务的名字，如果你需要在命令行中运行你的某些任务，那么，请不要在名字中使用空格。 deps 类型： Array，一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。 demo 123gulp.task(&apos;mytask&apos;, [&apos;array&apos;, &apos;of&apos;, &apos;task&apos;, &apos;names&apos;], function() &#123; // 做一些事&#125;); 注意： 你的任务是否在这些前置依赖的任务完成之前运行了？请一定要确保你所依赖的任务列表中的任务都使用了正确的异步执行方式：使用一个 callback，或者返回一个 promise 或 stream。 fn该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：gulp.src().pipe(someplugin())。 gulp.watch()语法：1gulp.watch(glob[, opts], tasks) gulp.watch()用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务。 glob类型： String or Array ,一个 glob 字符串，或者一个包含多个 glob 字符串的数组，用来指定具体监控哪些文件的变动。 opts 类型： Object 传给 gaze 的参数。 cb(event) 类型： Function ,每次变动需要执行的 callback。 参考：Gulp-API Gulp- 常用插件压缩JS -&gt; gulp-uglify:安装 gulp-uglify:1npm install gulp-uglify --save-dev 示例代码：12345678var gulp = require(&apos;gulp&apos;);var uglify = require(&apos;gulp-uglify&apos;);gulp.task(&apos;javascript&apos;,function () &#123; // javascript: 任务名称 gulp.src(&apos;./src/js/*.js&apos;) // src: 定位到需要压缩的js文件目录下 .pipe(uglify()) // 执行压缩文件 .pipe(gulp.dest(&apos;./dist/js&apos;)); // 输出到指定目录&#125;); API参考：gulp-uglify 压缩CSS -&gt; gulp-minify-css:安装 gulp-minify-css：1npm install gulp-minify-css --save-dev 示例代码：12345678var gulp = require(&apos;gulp&apos;);var minify = require(&apos;gulp-minify-css&apos;)gulp.task(&apos;css&apos;,function () &#123; gulp.src(&apos;./src/css/*.css&apos;) .pipe(minify()) .pipe(gulp.dest(&apos;./dist/css&apos;));&#125;); API参考：gulp-minify-css 压缩图片 -&gt; gulp-imagemin：安装 gulp-imagemin：1npm install gulp-imagemin --save-dev 示例代码：12345678var gulp = require(&apos;gulp&apos;);var image = require(&apos;gulp-imagemin&apos;);gulp.task(&apos;image&apos;,function () &#123; gulp.src(&apos;./src/images/*.*&apos;) .pipe(imagemin()) .pipe(gulp.dest(&apos;./dist/images&apos;));&#125;); API参考：gulp-imagemin 编译Less-&gt; gulp-less:安装 gulp-less：1npm install gulp-less --save-dev 示例代码：12345678var gulp = require(&apos;gulp&apos;);var less = require(&apos;gulp-less&apos;);gulp.task(&apos;less&apos;,function () &#123; gulp.src(&apos;./src/less/*.*&apos;) .pipe(less()) .pipe(gulp.dest(&apos;./dist/less&apos;));&#125;); API参考：gulp-less 自动刷新-&gt; gulp-livereload：安装gulp-livereload：1npm install gulp-livereload --save-dev 示例代码：1在每个gulp.task()方法中的gulp.src()方法后追加 .pipe(livereload()); 即可。 需要配合谷歌浏览器插件 LiveReload插件来使用，实现自动刷新。 API参考：gulp-livereload Google Chrome Plugin：LiveReload 完整gulpfile.js文件：123456789101112131415161718192021222324252627282930313233343536var gulp = require(&apos;gulp&apos;); // Gulpvar uglify = require(&apos;gulp-uglify&apos;); // JavaScriptvar minify = require(&apos;gulp-minify-css&apos;); // CSSvar imagemin = require(&apos;gulp-imagemin&apos;); // Imagesvar less = require(&apos;gulp-less&apos;); // Lessvar livereload = require(&apos;gulp-livereload&apos;) // LiveReload// 执行所有任务gulp.task(&apos;default&apos;, [&apos;javascript&apos;,&apos;css&apos;,&apos;less&apos;,&apos;image&apos;]);gulp.task(&apos;javascript&apos;,function () &#123; // jsscript: 任务名称 gulp.src(&apos;./src/js/*.js&apos;) // src: 定位到需要压缩的js文件目录下 .pipe(uglify()) // 执行压缩文件 .pipe(gulp.dest(&apos;./dist/js&apos;)); // 输出到指定目录&#125;);gulp.task(&apos;css&apos;,function () &#123; gulp.src(&apos;./src/css/*.css&apos;) .pipe(minify()) .pipe(gulp.dest(&apos;./dist/css&apos;));&#125;);gulp.task(&apos;less&apos;,function () &#123; gulp.src(&apos;./src/less/*.*&apos;) .pipe(less()) .pipe(gulp.dest(&apos;./dist/css&apos;));&#125;);gulp.task(&apos;image&apos;,function () &#123; gulp.src(&apos;./src/images/*.*&apos;) .pipe(imagemin()) .pipe(gulp.dest(&apos;./dist/images&apos;));&#125;); Gulp- 参考资料 Gulp官网 Gulp中文网 一点CSS-Gulp npmjs Gulp-插件 Gulp常用插件介绍 Gulp使用介绍和技巧 Thenewboston-视频教程 常见web项目目录：在当前项目的根目录下执行tree命令，即可看到项目的整个目录结构，如果没有tree命令，在Mac系统下可以使用brew进行安装： 123456789101112131415161718192021222324➜ Glup tree ../Glup../Glup├── build # 项目构建脚本├── src # 源码目录│ ├── css # CSS文件│ ├── fonts # 字体文件│ ├── images # 图片文件│ ├── js # js脚本文件│ ├── less # less文件│ └── sass # sass文件├── dist # 编译出来的发布版本目录│ ├── css │ ├── fonts│ ├── images│ └── js ├── docs # 文档├── test # 测试脚本├── gulpfile.js # Gulp工具构建项目的主文件├── node_modules # npm包存放目录├── package-lock.json #npm5.0以上项目依赖文件├── package.json # npm包管理配置文件├── LICENSE # 授权协议└── README.md # 项目说明文件]]></content>
      <categories>
        <category>Build Tools</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
</search>
