<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Docker - Compose]]></title>
    <url>%2F2018%2F05%2F23%2Fdocker-compose%2F</url>
    <content type="text"><![CDATA[Docker - Compose简介:Compose 是什么？Compose是定义和运行多容器Docker应用程序的工具。使用Compose，您可以使用YAML文件来配置应用程序的服务。然后，使用单个命令，您可以创建并启动配置中的所有服务。 Compose适用于所有环境：生产，分期，开发，测试以及CI工作流程。 Compose 历史版本？Docker Compose目前为止迭代了三个版本，官网建议使用最新的3版本，Docker从1.13.0+开始支持3版本。 本机的Docker版本是： 12[vagrant@docker-host ~]$ docker -vDocker version 18.05.0-ce, build f150324 参考：https://docs.docker.com/compose/compose-file/#reference-and-guidelines Docker - Compose.yml:一个简单的dokcer-compose.yml文件： 123456789101112131415161718version: '3'services: web: build: . ports: - "5000:5000" volumes: - .:/code - logvolume01:/var/log links: - redis redis: image: redisvolumes: logvolume01: &#123;&#125;networks: my-bridge: driver: bridge 以上文件可以看出，一个docker-compose.yml文件主要包含了四个部分:version、services、volumes、networks。 Version:用于指定docker-compose.yml文件的版本。 Services：一个Service代表一个Container，这个Container可以从dockerhub的image来创建，或者从本地的Dockerfile build出来的image来创建。 service的启动类类似docker run,我们可以给Service指定network和volume，所以可以给service指定network和volume的引用。 Volumes:可以再Service中给镜像定义volumes，然后再在volumes中引用Service中定义的volumes的名称。 Networks:指定docker-compose使用的网络。 Docker - Compose安装:如果是直接在电脑上安装了Docker for Mac或Docker for Win，那么Docker Toolbox中已经包含了Docker Compose，无需单独安装。 Centos7安装Docker-Compose:1、下载最新版本的Docker Compose： 1curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 2、 给予Docker Compose执行权限： 1sudo chmod +x /usr/local/bin/docker-compose 3、测试安装： 12docker-compose -vdocker-compose version 1.21.2, build a133471 Docker - Compose使用:使用Compose基本上是一个三步过程： 用一个定义你的应用程序的环境，Dockerfile这样它就可以在任何地方再现。 定义组成您的应用程序的服务，docker-compose.yml 以便它们可以在隔离的环境中一起运行。 运行docker-compose up和撰写启动并运行您的整个应用程序。 Docker - Compose命令: 命令 说明 build 构建或重建服务 bundle 从Compose文件中生成一个Docker bundle config 验证并查看Compose文件 create 创建服务 down 停止并移除容器，网络，图像和卷 events 接收来自容器的实时事件 exec 在正在运行的容器中执行命令 help 获取有关命令的帮助 images 列出镜像 kill 杀死运行的容器 logs 查看容器的输出 pause 暂停服务 port 打印端口绑定的公共端口 ps 查看容器列表 pull 拉取服务镜像 push 推送服务镜像 restart 重启服务 rm 移除停止的容器 run 运行一次性命令 scale 设置服务的容器数量 start 启动服务 stop 停止服务 top 显示正在运行的进程 unpause 取消暂停服务 unpause 创建并启动容器 version 显示Docker-Compose版本信息 Docker - Compose实践:使用Compse构建多容器WordPress：1、创建一个目录： 1mkdir wp 2、进入目录撰写docker-compose.yml: 1cd wp &amp;&amp; touch docker-compose.yml docker-compose.yml： 123456789101112131415161718192021222324252627version: '3.3'services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest ports: - "8000:80" restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpressvolumes: db_data: 3、使用docker-compose构建容器： 1docker-compose up -d 4、查看运行状态： 12345[vagrant@docker-host ~]$ docker-compose ps Name Command State Ports-----------------------------------------------------------------------------------vagrant_db_1 docker-entrypoint.sh mysqld Up 3306/tcpvagrant_wordpress_1 docker-entrypoint.sh apach ... Up 0.0.0.0:8000-&gt;80/tcp 使用Compose结果Dockerfile构建一个web应用：1、创建一个工程目录： 1mkdir dk_web &amp;&amp; cd dk_web 2、创建web工程文件： app.py: 1234567891011121314151617181920212223242526272829import timeimport redisfrom flask import Flaskapp = Flask(__name__)cache = redis.Redis(host='redis', port=6379)def get_hit_count(): retries = 5 while True: try: return cache.incr('hits') except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5)@app.route('/')def hello(): count = get_hit_count() return 'Hello World! I have been seen &#123;&#125; times.\n'.format(count)if __name__ == "__main__": app.run(host="0.0.0.0", debug=True) requirements.txt： 12flaskredis 3、撰写Dockerfile： 12345FROM python:3.4-alpineADD . /codeWORKDIR /codeRUN pip install -r requirements.txtCMD ["python", "app.py"] 4、撰写docker-compose.yml： 12345678version: '3'services: web: build: . ports: - "5000:5000" redis: image: "redis:alpine" 5、使用Docker Compose来构建应用程序： 1docker-compose up 6、查看容器运行状态： 12345[vagrant@docker-host dk_web]$ docker-compose ps Name Command State Ports--------------------------------------------------------------------------------dk_web_redis_1 docker-entrypoint.sh redis ... Up 6379/tcpdk_web_web_1 python app.py Up 0.0.0.0:5000-&gt;5000/tcp 7、访问： http://192.168.10.10:5000]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
        <tag>Docker</tag>
        <tag>Docker-Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker - 持久化存储和数据共享]]></title>
    <url>%2F2018%2F05%2F15%2Fdocker-data%2F</url>
    <content type="text"><![CDATA[Docker - Data Volume想要了解Docker Volume,首先我们需要知道Docker的文件系统是如何工作的.Docker镜像是由多个文件系统(只读层)叠加而成.当我们启动一个容器的时候,Docker会加载镜像层并在其上添加一个读写层.如果运行中的容器修改了现有的一个已存在的文件,那该文件将会从读写层下的只读层复制到读写层,该文件的只读版本仍然存在,只是已经被读写层中该文件的副本所隐藏.当删除Docker容器,并通过该镜像重新启动时,之前的更改将会丢失.在Docker中,只读层以及在顶部的读写层的组合被称为Union FIle System(联合文件系统).为了能够保存(持久化)数据以及共享容器间的数据,Docker提出了Volume的概念.简单来说,Volume就是目录或者文件,它可以绕过默认的联合文件系统,而以正常的文件或者目录的形式存在于宿主机上. 环境准备:拉取MySQL的镜像： 1docker pull mysql:latest 启动一个MySQL容器： 1docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag some-mysql： 容器别名 my-secret-pw：初始化设置的root用户的密码 tag：mysql的版本，不写默认使用最新版 参考：https://hub.docker.com/_/mysql/ 创建一个Volume：12[vagrant@docker-host ~]$ docker run --name dk-mysql -v mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:latest48a6888c4061c89f760685827e98955c8323747452c24deb1af688c2f56d38b6 -v : 指定MySQL的Volume路径以及名称 查看Volume:12345678910111213141516[vagrant@docker-host ~]$ docker volume ls # 查看当前机器上的VolumeDRIVER VOLUME NAMElocal mysql [vagrant@docker-host ~]$ docker volume inspect mysql # 查看volume的信息[ &#123; "CreatedAt": "2018-06-15T16:23:27Z", "Driver": "local", "Labels": null, "Mountpoint": "/var/lib/docker/volumes/mysql/_data", "Name": "mysql", "Options": null, "Scope": "local" &#125;] 可以看出Volume的数据的Mountpoint是存储在机器的/var/lib/docker/volumes/目录下。 测试Volume是否生效：进入到MySQL容器中：123456789[vagrant@docker-host ~]$ docker exec -it dk-mysql /bin/sh# mysql -u root -p # 进入到MySQL的shell中Enter password:Welcome to the MySQL monitor. Commands end with ; or \g.≈≈≈≈mysql&gt; create database docker; # 创建数据库，名为dockerQuery OK, 1 row affected (0.08 sec)mysql&gt; exitBye# exit 强制删除容器：1234567[vagrant@docker-host ~]$ docker rm -f dk-mysql # 强制删除MySQL容器dk-mysql[vagrant@docker-host ~]$ docker ps -a # 查看容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[vagrant@docker-host ~]$ docker volume ls # 查看volume mysql还在DRIVER VOLUME NAMElocal mysql 创建新容器使用旧的Volume：12[vagrant@docker-host ~]$ docker run --name mysql-new -v mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:latest # 创建mysql容器 名为：mysql-new9ab58b633584c5eab99cf28402dfdde22f349f79da9453115a8eab2cc41dc0bf 查看数据是否存在：12345678910111213141516[vagrant@docker-host ~]$ docker exec -it mysql-new /bin/sh # 进入到新的容器中# mysql -u root -p Enter password:Welcome to the MySQL monitor. Commands end with ; or \g.mysql&gt; show databases; # 查看所有数据库 发现docker在列+--------------------+| Database |+--------------------+| docker || information_schema || mysql || performance_schema || sys |+--------------------+5 rows in set (0.00 sec) Docker容器被删除之后Volume并不会被删除。 Docker - Bing Mounting:环境准备：在机器上创建一个目录，放一个html网页，然后将这个目录挂载到容器中： 12345[vagrant@docker-host ~]$ mkdir web &amp;&amp; touch web/index.html[vagrant@docker-host ~]$ vim web/index.html[vagrant@docker-host ~]$ cd web/[vagrant@docker-host web]$ more index.html&lt;h1&gt;From Dokcer Container!&lt;/h1&gt; 挂载目录到容器中：将当前目录中的文件挂载到Nginx容器中： 1[vagrant@docker-host web]$ docker run -d -p 8088:80 -v $(pwd):/usr/share/nginx/html --name webnginx nginx $(pwd): 当前目录 待容器启动后，可以访问容器： 1http://192.168.10.10:8088/ 容器中修改网页内容：12345[vagrant@docker-host web]$ docker exec -it webnginx /bin/sh# cd /usr/share/nginx/html# vim index.html&lt;h1&gt;From Dokcer Container! Edit&lt;/h1&gt; # 修改完成后再次访问 可看到内容已更新 同样，在机器上修改文件，容器中的文件也会同步更新。 退出容器查看文件：退出容器，查看机器上的文件，会发现已有变化： 12[vagrant@docker-host web]$ more index.html&lt;h1&gt;From Dokcer Container! Edit&lt;/h1&gt; Done.]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker - NetWork]]></title>
    <url>%2F2018%2F05%2F09%2Fdocker-network%2F</url>
    <content type="text"><![CDATA[Linux - Namespace:目前，Linux实现了六种不同类型的命名空间。每个命名空间的目的都是将一个特定的全局系统资源包装在一个抽象中，使得它看起来像名称空间内的进程，它们拥有自己独立的全局资源实例。命名空间的总体目标之一是支持容器的实现，这是一种轻量级虚拟化（以及其他目的）工具，它为一组进程提供了一种愿景，即它们是系统上唯一的进程。 如果要深入研究docker技术，linux namespace是必须掌握的基础知识。 Linux的六种Namespace： 名称 系统调用参数 相关内核版本 作用 Mount namespace (挂载命名空间 CLONE_NEWNS Linux 2.4.19 提供磁盘挂载点和文件系统的隔离能力 UTS namespace(UTS命名空间) CLONE_NEWUTS Linux 2.6.19 提供主机名隔离能力 IPC namespace(IPC命名空间) CLONE_NEWIPC Linux 2.6.19 提供进程间通信的隔离能力 PID namespace(PID命名空间) CLONE_NEWPID Linux 2.6.24 提供进程隔离能力 Network namespace(网络命名空间) CLONE_NEWNET 始于Linux 2.6.24，在Linux 2.6.29中完成 提供网络隔离能力 User namespace(用户命名空间) CLONE_NEWUSER 始于Linux 2.6.23，在Linux 3.8中完成 提供用户隔离能力 参考资料：https://lwn.net/Articles/531114/ 参考资料：https://www.cnblogs.com/linhaifeng/p/6657119.html 网络常用命令： 命令 说明 ping 基于(ICMP)协议，验证IP地址的可达性 telnet 检查服务的可用性 brctl 网桥命令工具(bridge-utils) ifconfig 用于显示或配置网络设备 ip ip命令和ifconfig类似但ip功能更强大用于网络管理 route 路由管理 dhclient 使用DHCP协议在局域网取得IP netstat 查看网络接口所监听的端口 host 分析测试域名（bind-utils） tracerout 跟踪IP路由 Docker - bridge:Bridge网络是Docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。 Brdige桥接模式为Docker Container创建独立的网络栈，保证容器内的进程组使用独立的网络环境，实现容器间、容器与宿主机之间的网络栈隔离。另外，Docker通过宿主机上的网桥(docker0)来连通容器内部的网络栈与宿主机的网络栈，实现容器与宿主机乃至外界的网络通信。 查看当前网络：123456[vagrant@docker-host ~]$ docker network lsNETWORK ID NAME DRIVER SCOPEb2e275fbd33a bridge bridge local93e25809038e host host locale2f76a9525ed mynet bridge localacb32226a73d none null local Docke会自动为每个主机创建三个网络： 名称 作用 bridge bridge网络是Docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将并将一个主机上的Docker容器连接到一个虚拟网桥上。当Docker server启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。 none 在none模式下，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。 host 如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。 容器之间的网络：查看网络：123456[vagrant@docker-host ~]$ docker network lsNETWORK ID NAME DRIVER SCOPEb2e275fbd33a bridge bridge local93e25809038e host host locale2f76a9525ed mynet bridge localacb32226a73d none null local 查看bridge网络信息：1234567891011121314151617181920212223242526272829303132333435363738[vagrant@docker-host ~]$ docker network inspect bridge[ &#123; "Name": "bridge", "Id": "b2e275fbd33af36182e5c7a6468ac98c4e98a9063e3a3dae83b7765144a759bb", "Created": "2018-06-14T11:30:28.762530396Z", "Scope": "local", "Driver": "bridge", "EnableIPv6": false, "IPAM": &#123; "Driver": "default", "Options": null, "Config": [ &#123; "Subnet": "172.17.0.0/16", "Gateway": "172.17.0.1" &#125; ] &#125;, "Internal": false, "Attachable": false, "Ingress": false, "ConfigFrom": &#123; "Network": "" &#125;, "ConfigOnly": false, "Containers": &#123;&#125;, "Options": &#123; "com.docker.network.bridge.default_bridge": "true", "com.docker.network.bridge.enable_icc": "true", "com.docker.network.bridge.enable_ip_masquerade": "true", "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0", "com.docker.network.bridge.name": "docker0", "com.docker.network.driver.mtu": "1500" &#125;, "Labels": &#123;&#125; &#125;] 创建容器：1234[vagrant@docker-host ~]$ docker run -d -it --name bbox1 busyboxf5afcc66498d2ed8b25a27177986f76362327c5d8c8a0ebf1adb0c03e6a6dbcb[vagrant@docker-host ~]$ docker run -d -it --name bbox2 busybox2bee3ba2ea6070daf4a9c0ace26bcd533b0dcd15ac121ba46b4389a7795e31c3 此时再次查看docker的bridge网络,会发现Container中多出了两个网络信息： 1234567891011121314151617"ConfigOnly": false, "Containers": &#123; "1b0a788f72866e87e7d244bfa1e07dc9c02d9f98d4813259f5a47ef76596fda3": &#123; "Name": "bbox2", "EndpointID": "fd6c43f1e1699777b4b936cccad4450e75dce6f8ec0ca1dc974bc3739b066e41", "MacAddress": "02:42:ac:11:00:03", "IPv4Address": "172.17.0.3/16", "IPv6Address": "" &#125;, "d28333de578e1cd2007b9fa4c22807a59d61b53bc451017d83292237cdd37639": &#123; "Name": "bbox1", "EndpointID": "86334095fbf03eaa0cfe2d2082ac119ee5af10e00fed4df37cb1e6909fddd465", "MacAddress": "02:42:ac:11:00:02", "IPv4Address": "172.17.0.2/16", "IPv6Address": "" &#125; &#125; 由此可见，创建docker容器默认使用的网络是bridge网络，而且默认容器之间是可以相互通信的。 12345678910111213141516171819202122232425262728293031[vagrant@docker-host ~]$ docker ps -a # 查看容器CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES1b0a788f7286 busybox "sh" 2 minutes ago Up 2 minutes bbox2d28333de578e busybox "sh" 3 minutes ago Up 3 minutes bbox1[vagrant@docker-host ~]$ docker exec -it bbox1 /bin/sh # 进入bbox1 / # ifconfig # 查看网络信息eth0 Link encap:Ethernet HWaddr 02:42:AC:11:00:02 inet addr:172.17.0.2 Bcast:172.17.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:8 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:648 (648.0 B) TX bytes:0 (0.0 B)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B)/ # ping 172.17.0.3 # 检查与bbox2容器之间的网络是否是可通的PING 172.17.0.3 (172.17.0.3): 56 data bytes64 bytes from 172.17.0.3: seq=0 ttl=64 time=0.101 ms64 bytes from 172.17.0.3: seq=1 ttl=64 time=0.097 ms64 bytes from 172.17.0.3: seq=2 ttl=64 time=0.102 ms^C--- 172.17.0.3 ping statistics ---4 packets transmitted, 4 packets received, 0% packet lossround-trip min/avg/max = 0.083/0.095/0.102 ms 创建网络：创建新的网络：12[vagrant@docker-host ~]$ docker network create -d bridge mybridgee2f76a9525edd675a14ed84b228d114b2694cb636deb49719e424a05776a8384 查看创建的网络：12345678910111213141516171819202122232425262728293031[vagrant@docker-host ~]$ docker network inspect mybridge[ &#123; "Name": "mybridge", "Id": "3232217a802ec7a9366afdc37bb1148a708f63f5db0e73113b35fb6adbf48ca7", "Created": "2018-06-15T11:38:34.313795476Z", "Scope": "local", "Driver": "bridge", "EnableIPv6": false, "IPAM": &#123; "Driver": "default", "Options": &#123;&#125;, "Config": [ &#123; "Subnet": "172.18.0.0/16", "Gateway": "172.18.0.1" &#125; ] &#125;, "Internal": false, "Attachable": false, "Ingress": false, "ConfigFrom": &#123; "Network": "" &#125;, "ConfigOnly": false, "Containers": &#123;&#125;, "Options": &#123;&#125;, "Labels": &#123;&#125; &#125;] 12345[vagrant@docker-host ~]$ brctl showbridge name bridge id STP enabled interfacesbr-3232217a802e 8000.02425d812be6 nodocker0 8000.024276ae1bbc no veth538e4f9 vethc2ffaee 这个br-3232217a802e就是刚才创建的bridge网络mybrdge。 创建容器指定网络：12[vagrant@docker-host ~]$ docker run -d -it --name bbox3 --network mybridge busybox55734c3f7b2e0e61070b07e69ce8b6cc7f1e28fb05090858e1f619812e740387 创建完成后，再次查看网桥： 12345[vagrant@docker-host ~]$ brctl showbridge name bridge id STP enabled interfacesbr-3232217a802e 8000.02425d812be6 no vethc2922cedocker0 8000.024276ae1bbc no veth538e4f9 vethc2ffaee 可以看出br-3232217a802e上多了一个interfaces。 查看Bridge网络:123456789101112131415161718192021222324252627282930313233343536373839[vagrant@docker-host ~]$ docker network inspect mybridge[ &#123; "Name": "mybridge", "Id": "3232217a802ec7a9366afdc37bb1148a708f63f5db0e73113b35fb6adbf48ca7", "Created": "2018-06-15T11:38:34.313795476Z", "Scope": "local", "Driver": "bridge", "EnableIPv6": false, "IPAM": &#123; "Driver": "default", "Options": &#123;&#125;, "Config": [ &#123; "Subnet": "172.18.0.0/16", "Gateway": "172.18.0.1" &#125; ] &#125;, "Internal": false, "Attachable": false, "Ingress": false, "ConfigFrom": &#123; "Network": "" &#125;, "ConfigOnly": false, "Containers": &#123; "55734c3f7b2e0e61070b07e69ce8b6cc7f1e28fb05090858e1f619812e740387": &#123; "Name": "bbox3", "EndpointID": "0cca477b8c13b65ee6c301c7c71096e90f94c01a13c07614a299af5e102a3b97", "MacAddress": "02:42:ac:12:00:02", "IPv4Address": "172.18.0.2/16", "IPv6Address": "" &#125; &#125;, "Options": &#123;&#125;, "Labels": &#123;&#125; &#125;] 可以看出 container部分多了一个容器 bbox3。 将其他容器连接至创建的网络中： 将创建的bbox2连接至mybridge中： 1[vagrant@docker-host ~]$ docker network connect mybridge bbox2 再次查看网络: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647See 'docker --help'[vagrant@docker-host ~]$ docker network inspect mybridge[ &#123; "Name": "mybridge", "Id": "3232217a802ec7a9366afdc37bb1148a708f63f5db0e73113b35fb6adbf48ca7", "Created": "2018-06-15T11:38:34.313795476Z", "Scope": "local", "Driver": "bridge", "EnableIPv6": false, "IPAM": &#123; "Driver": "default", "Options": &#123;&#125;, "Config": [ &#123; "Subnet": "172.18.0.0/16", "Gateway": "172.18.0.1" &#125; ] &#125;, "Internal": false, "Attachable": false, "Ingress": false, "ConfigFrom": &#123; "Network": "" &#125;, "ConfigOnly": false, "Containers": &#123; "1b0a788f72866e87e7d244bfa1e07dc9c02d9f98d4813259f5a47ef76596fda3": &#123; "Name": "bbox2", "EndpointID": "d00a5c16de03fdb0b6f93eb275ba1e0415aa6496da17e4279dda547c70871ca1", "MacAddress": "02:42:ac:12:00:03", "IPv4Address": "172.18.0.3/16", "IPv6Address": "" &#125;, "55734c3f7b2e0e61070b07e69ce8b6cc7f1e28fb05090858e1f619812e740387": &#123; "Name": "bbox3", "EndpointID": "0cca477b8c13b65ee6c301c7c71096e90f94c01a13c07614a299af5e102a3b97", "MacAddress": "02:42:ac:12:00:02", "IPv4Address": "172.18.0.2/16", "IPv6Address": "" &#125; &#125;, "Options": &#123;&#125;, "Labels": &#123;&#125; &#125;] 会发现Containers中多了一个bbox2。 查看网桥： 123456[vagrant@docker-host ~]$ brctl showbridge name bridge id STP enabled interfacesbr-3232217a802e 8000.02425d812be6 no veth7d193ff vethc2922cedocker0 8000.024276ae1bbc no veth538e4f9 vethc2ffaee 会发现br-3232217a802e上又多了一个interfaces。 多容器使用一个bridge网络，容器之间是可以互相通信的。 Docker - link：在使用Docker的时候，经常可能需要连接到其他的容器，比如：web服务需要连接数据库。按照往常的做法，需要先启动数据库的容器，映射出端口来，然后配置好客户端的容器，再去访问。其实针对这种场景，Docker提供了--link 参数来满足。 使用link建立容器连接：当前有两个容器，bbox1和bbox2： 1234[vagrant@docker-host ~]$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES1b0a788f7286 busybox "sh" 2 hours ago Up 2 hours bbox2d28333de578e busybox "sh" 2 hours ago Up 2 hours bbox1 再创建一个容器bbox4 链接到bbox1上去： 12[vagrant@docker-host ~]$ docker run -d -it --name bbox4 --link bbox1 busybox b90ae3c8bc107e5f53879449997a95ea313c388e959e44f75ded764f8f2ea9d3 进入到bbox3容器中测试网络： 1234567891011121314151617181920[vagrant@docker-host ~]$ docker exec -it bbox4 /bin/s/ # ping bbox1PING bbox1 (172.17.0.2): 56 data bytes64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.096 ms64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.087 ms64 bytes from 172.17.0.2: seq=2 ttl=64 time=0.099 ms64 bytes from 172.17.0.2: seq=3 ttl=64 time=0.085 ms^C--- bbox1 ping statistics ---4 packets transmitted, 4 packets received, 0% packet lossround-trip min/avg/max = 0.085/0.091/0.099 ms/ # cat /etc/hosts127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.17.0.2 bbox1 d28333de578e172.17.0.4 b90ae3c8bc10 可以看出在使用--link的时候docker在容器的/etc/hosts下添加了一个DNS服务。 Done.]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker - Container & Image]]></title>
    <url>%2F2018%2F04%2F26%2Fdocker-cntrimg%2F</url>
    <content type="text"><![CDATA[Docker - 核心概念：docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(Images)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 Docker - 镜像[Image]:镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构(layer)，由一系列指令一步一步构建出来，不同image 之间可以共享 layer ,Image本身是只读的(read-only)。 构建Base Image:通过简单的 Dockerfile 来构建一个 baseimage: 1、编写一个简单的 C语言程序： 12345678[vagrant@docker-host ~]$ mkdir baseimg &amp;&amp; cd baseimg &amp;&amp; vim base.c#include&lt;stdio.h&gt;int main(void)&#123; printf("hello world"); return 0;&#125; 2、编译刚才写的程序，得到一个简单的二进制文件： 1[vagrant@docker-host baseimg]$ gcc -static base.c -o base 3、编写 Dockerfile: 123456[vagrant@docker-host baseimg]$ vim Dockerfile# start FROM scratchADD base /CMD ["/base"]# end 4、构建 baseimage: 123456789101112[vagrant@docker-host baseimg]$ docker build -t zhangyangdev/baseimg .Sending build context to Docker daemon 868.9kBStep 1/3 : FROM scratch ---&gt;Step 2/3 : ADD base / ---&gt; 985f7dd1d401Step 3/3 : CMD ["/base"] ---&gt; Running in b8241cf4dc5cRemoving intermediate container b8241cf4dc5c ---&gt; f048aeb88f64Successfully built f048aeb88f64Successfully tagged baseimg:latest 5、查看并运行镜像： 12345[vagrant@docker-host baseimg]$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEzhangyangdev/baseimg latest f048aeb88f64 About a minute ago 865kB[vagrant@docker-host baseimg]$ docker run f048aeb88f64hello world 至此，已经构建好了一个简单的 baseimage。 镜像发布：docker hub 是一个docker提供的镜像托管网站，可以下载pull 一些官方或者非官方的镜像，同时 也可以将自己构建好的镜像push到自己的 Docker Hub 仓库中。 要发布自己制作的镜像，首先得在 Docker Hub 上进行注册激活，之后会得到一个用户名和密码，然后在控制台输入docker login进行登录，登录成功会显示Login Succeeded。 Docker Hub:https://hub.docker.com/ 1234[vagrant@docker-host baseimg]$ docker push zhangyangdev/baseimg:latestThe push refers to repository [docker.io/zhangyangdev/baseimg]2e492296c0e4: Pushedlatest: digest: sha256:2ad65382bb199a75a40535fb0adbdbb941211c114d856efd1147eae054022393 size: 527 push 结束后，刷新 Docker Hub 的个人中心页面就可以看到push 的镜像了。 此时，可以将本地的镜像 删除掉，再从 dockhub 上 pull 下来： 12345678[vagrant@docker-host baseimg]$ docker rm $(docker ps -aq)[vagrant@docker-host baseimg]$ docker rmi zhangyangdev/baseimg[vagrant@docker-host baseimg]$ docker pull zhangyangdev/baseimgUsing default tag: latestlatest: Pulling from zhangyangdev/baseimg9c94da54d2ab: Pull completeDigest: sha256:2ad65382bb199a75a40535fb0adbdbb941211c114d856efd1147eae054022393Status: Downloaded newer image for zhangyangdev/baseimg:latest Docker - 容器[Container]:Docker - 容器概述容器是应用程序层的一个抽象，将代码和依赖关系打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为孤立进程运行。容器占用的空间少于虚拟机（容器图像的大小通常为几十MB），并且几乎立即启动。 Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像创建起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。 Container是在 Image 镜像上建立的一个 layer是可读可写的，Image 负责app 的存储和分发Container 负责运行。 创建容器：1234567[vagrant@docker-host ~]$ docker images # 查看镜像REPOSITORY TAG IMAGE ID CREATED SIZEbaseimg latest f048aeb88f64 9 minutes ago 865kBhello-world latest e38bc07ac18e 8 weeks ago 1.85kB[vagrant@docker-host ~]$ docker run hello-world # 启动容器Hello from Docker! 示例：创建Nginx容器我们需要安装一个Nginx 的Web服务器，Web 服务器可以使网站文件和程序通过浏览器来访问，操作之前建议关闭系统的防火墙： 1[root@localhost ~]# systemctl stop firewalld.service # 关闭防火墙 1234567[root@localhost ~]# docker search nginx # 搜索镜像 选择OFFICIAL状态为[OK]的官方镜像[root@localhost ~]# docker pull nginx # 下载Nginx镜像[root@localhost ~]# docker run --name docker_nginx -d -p 80:80 nginx # 启动nginx [80:80] 主机端口:容器端口[root@localhost ~]# docker ps # 查看运行中的容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 876b4161c793 nginx "nginx -g 'daemon ..." About a minute ago Up About a minute 0.0.0.0:80-&gt;80/tcp nervous_thompson [root@localhost ~]# docker logs docker_nginx # 查看启动日志 运行交互式容器：dokcer的容器是基于镜像而创建的，所以在运行交互式容器之前需要先pull一个镜像： 12345678[vagrant@docker-host ~]$ docker pull ubuntu # 拉取镜像[vagrant@docker-host ~]$ docker images # 查看镜像REPOSITORY TAG IMAGE ID CREATED SIZEubuntu latest 113a43faa138 42 hours ago 81.2MB[vagrant@docker-host ~]$ docker run -it ubuntu # 创建交互式容器root@4948b39a7d56:/# cat /etc/issue # 此时会发现进入了一个 Ubuntu 系统中Ubuntu 18.04 LTS \n \l root@4948b39a7d56:~# exit # 此时容器的状态由Up变为Exited Docker - 常用命令：简单命令： 命令 简写 作用 docker container ls -aq docker ps -aq 查看退出状态的容器 docker container commit docker commit 提交对容器的操作 docker image build docker build 通过Dockerfile构建Image docker container inspect docker inspect 用于获取容器/镜像的元数据 docker container stop docker stop 停止容器 docker container start docker start 启动容器 组合命令： 命令 作用 docker rm $(docker container ls -aq) 删除掉状态为exited的容器 dokcer rm $(dokcer container ls -f “status=exited” -q) 删除掉状态为exited的容器 docker top docker ps -q 获取docker执行进程 docker run –name dk_ubuntu -it ubuntu bash 进入Ubuntu系统 docker attach [image id / name] 退出后再次进入 正在运行的容器的数量: 1docker ps -q | wc -l 监控容器数量: 1docker ps -a -q | wc -l 删除掉状态为exited的容器 1docker rm $(docker ps -a | grep Exited | awk '&#123;print $1&#125;') Dockerfile:语法详解：官方文档：https://docs.docker.com/engine/reference/builder/ FROM :示例： 1FROM centos # 指定基础镜像为 centos 作用：FROM指定一个基础镜像， 一般情况下一个可用的 Dockerfile一定是 FROM 为第一个指令。至于镜像则可以是任何合理存在的image镜像，不建议使用任何非官方镜像，为了安全。 FROM 一定是首个非注释指令 Dockerfile， FROM 可以在一个 Dockerfile 中出现多次，以便于创建混合的images。 如果没有指定 tag ，latest 将会被指定为要使用的基础镜像版本。 LABEL ：示例： 12LABLE version="1.0" # dockefile 版本信息LABLE maintainer="zhang@gmail.com" # dockerfile 维护者信息 作用： 指定镜像制作者[meta data]的信息信息，如maintainer、version、description等 RUN :示例： 12RUN yum update # 运行 yum update 命令RUN yum makecache 作用：RUN命令将在当前image中执行任意合法命令并提交执行结果。命令执行提交后，就会自动执行Dockerfile中的下一个指令，每执行一次就会多分一层 layer，建议合并多条命令为一行。 CMD:示例： 12ENV name docker # 定义 name 变量CMD echo "$name" # 输出 name 变量 作用：容器启动时默认执行的命令，如果 docker run 指定了其他命令，CMD 命令会被忽略。如果定义了多个 CMD 命令，则只有最后一个会被执行。 ENTRYPOINT ：示例： 12345COPY docker-entrypoint.sh /usr/local/binENTRYPOINT EXPOSE 27017CMD ["mongod"] 作用：让容器以应用程序或者服务的形式运行，不会被忽略，一定会被执行，可以指定一个 shell脚本来作为 entrypoint。 WORKDIR：示例： 1WORKDIR /opt #指定当前工作目录为/opt 如果不存在 opt 目录，则会自动创建 作用： WORKDIR 用来设置当前的工作目录的，尽量使用绝对路径。Docker 默认的工作目录是/，只有 RUN 能执行 cd 命令切换目录，而且还只作用在当下下的 RUN，也就是说每一个 RUN 都是独立进行的。如果想让其他指令在指定的目录下执行，就得靠 WORKDIR。WORKDIR 动作的目录改变是持久的，不用每个指令前都使用一次 WORKDIR。 ADD ：示例： 1ADD hello.c / # 将 hello.c 文件添加到容器的/目录下 作用：COPY 将文件从路径 复制添加到容器内部路径 。 必须是对于源文件夹的一个文件或目录，也可以是一个远程的url， 是目标容器中的绝对路径。 COPY：示例： 1COPY hello.c / # 将 hello.c 文件复制到容器的/目录下 作用：COPY 将文件从路径 复制添加到容器内部路径 。 所有的新文件和文件夹都会创建UID 和 GID。事实上如果 是一个远程文件URL，那么目标文件的权限将会是600。 ADD命令和 COPY 命令在很大层度上功能是一样的。但是 COPY 语义更加直接，所以推荐尽量使用 COPY 命令。例外的是 ADD 命令自带解压功能，如果需要拷贝并解压一个文件到镜像中，那么可以使用 ADD 命令。 除此之外，都推荐使用 COPY 命令。 需要添加远程文件，推荐使用 RUN 来执行wget/curl。 ENV：示例： 12ENV MYSQL_VERSION 5.7 # 添加常量 设置 MySQL 的版本为5.7RUN apt-get install -y mysql-server="$&#123;MYSQL_VERSION&#125;" # 在RUN中引用ENV 作用： ENV指令可以用于为docker容器设置环境变量 ENV设置的环境变量，可以使用 docker inspect命令来查看。同时还可以使用docker run –env =来修改环境变量。 ENV 可以尽量多使用，以便于增加程序的可维护性。 VOLUME：示例： 1VOLUME /data # 共享 /data文件夹中的数据 作用： 创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。 EXPOSE：示例： 1EXPOSE 80 # 请求通过80端口来转发 作用： EXPOSE 指令指定在docker允许时指定的端口进行转发。 简单实践：Dockerfile内容：12345FROM nginx:latestLABEL MAINTAINER="xxx xxx@gmail.com"WORKDIR /usr/share/nginx/htmlCOPY index.html index.html html网页内容：123456789&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;title&gt;Docer&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;From Docker Nginx&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 构建image:1[vagrant@docker-host ]$ docker build -t dk_nginx . 启动容器：1[vagrant@docker-host ]$ docker run -d -p 80:80 dk_nginx 测试访问[虚拟机环境下]：12345678910[vagrant@docker-host ]$ curl 127.0.0.1&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;title&gt;Docer&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;From Docker Nginx&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 测试访问(物理机环境下)：1浏览器访问虚拟机IP地址： 192.168.10.10 Done.]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Vagrant + VirtualBox 快速构建 CentOS 下的 Docker 环境]]></title>
    <url>%2F2018%2F04%2F12%2Fvagrant%2F</url>
    <content type="text"><![CDATA[​ Vagrant - 基础概念:Vagrant 是什么？Vagrant是一款用于在单个工作流程中构建和管理虚拟机环境的工具。凭借易于使用的工作流程和专注于自动化，Vagrant降低了开发环境设置时间，提高了开发效率。 Vagrant 是构建在虚拟化技术之上的虚拟机运行环境管理工具： 建立和删除虚拟机 配置虚拟机运行参数 管理虚拟机运行状态 自动化配置和安装开发环境 打包和分发虚拟机运行环境 Vagrant的适用范围 开发 测试 参考：https://www.vagrantup.com/intro/index.html Vagrant - 下载安装:Vagrant 下载：https://www.vagrantup.com/downloads.html VirtualBox 下载：https://www.virtualbox.org/wiki/Downloads Vagrant - 常用操作：以下是 Vagrant 的常用操作命令： 命令 作用 vagrant box add 添加box的操作 vagrant init 初始化box的操作，会生成vagrant的配置文件Vagrantfile vagrant up 启动本地环境 vagrant ssh 通过ssh登录本地环境所在虚拟机 vagrant halt 关闭本地环境 vagrant suspend 暂停本地环境 vagrant resume 恢复本地环境 vagrant reload 修改了Vagrantfile后，使之生效（相当于先 halt，再 up） vagrant destroy 彻底移除本地环境 vagrant box list 显示当前已经添加的box列表 vagrant box remove 删除相应的box vagrant package 打包命令，可以把当前的运行的虚拟机环境进行打包 vagrant plugin 用于安装卸载插件 vagrant status 获取当前虚拟机的状态 vagrant global-status 显示当前用户Vagrant的所有环境状态 Vagrant - Vgrantfile：Vagrantfile的主要功能是对虚拟机器进行配置， 官方文档: https://www.vagrantup.com/docs/vagrantfile/ 当执行过vagrant init之后 vagrant 会生成一个名为Vagrantfile的文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# -*- mode: ruby -*-# vi: set ft=ruby :# All Vagrant configuration is done below. The "2" in Vagrant.configure# configures the configuration version (we support older styles for# backwards compatibility). Please don't change it unless you know what# you're doing.Vagrant.configure("2") do |config| # The most common configuration options are documented and commented below. # For a complete reference, please see the online documentation at # https://docs.vagrantup.com. # Every Vagrant development environment requires a box. You can search for # boxes at https://vagrantcloud.com/search. config.vm.box = "base" # Disable automatic box update checking. If you disable this, then # boxes will only be checked for updates when the user runs # `vagrant box outdated`. This is not recommended. # config.vm.box_check_update = false # Create a forwarded port mapping which allows access to a specific port # within the machine from a port on the host machine. In the example below, # accessing "localhost:8080" will access port 80 on the guest machine. # NOTE: This will enable public access to the opened port # config.vm.network "forwarded_port", guest: 80, host: 8080 # Create a forwarded port mapping which allows access to a specific port # within the machine from a port on the host machine and only allow access # via 127.0.0.1 to disable public access # config.vm.network "forwarded_port", guest: 80, host: 8080, host_ip: "127.0.0.1" # Create a private network, which allows host-only access to the machine # using a specific IP. # config.vm.network "private_network", ip: "192.168.33.10" # Create a public network, which generally matched to bridged network. # Bridged networks make the machine appear as another physical device on # your network. # config.vm.network "public_network" # Share an additional folder to the guest VM. The first argument is # the path on the host to the actual folder. The second argument is # the path on the guest to mount the folder. And the optional third # argument is a set of non-required options. # config.vm.synced_folder "../data", "/vagrant_data" # Provider-specific configuration so you can fine-tune various # backing providers for Vagrant. These expose provider-specific options. # Example for VirtualBox: # # config.vm.provider "virtualbox" do |vb| # # Display the VirtualBox GUI when booting the machine # vb.gui = true # # # Customize the amount of memory on the VM: # vb.memory = "1024" # end # # View the documentation for the provider you are using for more # information on available options. # Enable provisioning with a shell script. Additional provisioners such as # Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the # documentation for more information about their specific syntax and use. # config.vm.provision "shell", inline: &lt;&lt;-SHELL # apt-get update # apt-get install -y apache2 # SHELLend 配置版本:在命令终端执行完vagrant init之后，Vagrant 大致有以下几种形式： 1234567Vagrant.configure("1") do |config| # v1 configs...endVagrant.configure("2") do |config| # v2 configs...end 目前，只有两个受支持的版本：“1”和“2”。 版本”1”代表Vagrant 1.0.x的配置。 版本“2”代表1.1以上到2.0.x的配置。 最低Vagrant版本:可以在Vagrantfile中指定一组Vagrant版本要求，以强制人们使用Vagrant文件的特定版本的Vagrant。 这可以帮助解决使用带有Vagrantfile的过时或过时的Vagrant版本可能引起的兼容性问题。 应使用Vagrant.require_version帮助程序在Vagrant文件的顶部指定Vagrant版本要求： 1Vagrant.require_version "&gt;= 1.3.5" 在上面的情况下，只有加载它的版本是Vagrant 1.3.5或更高版本，Vagrantfile才会加载。 还可以指定多个需求： 1Vagrant.require_version "&gt;= 1.3.5", "&lt; 1.4.0" 提示与技巧Vagrantfile是一种非常灵活的配置格式。 它基于Ruby，你可以用它做很多事情。 然而，同样的道理，因为它是Ruby，所以有很多方法可以让你在脚下自我射击。 在本页使用一些提示和技巧时，请注意正确使用它们。 参考：https://www.vagrantup.com/docs/vagrantfile/tips.html 循环创建虚拟机如果你想对许多多机器应用稍微不同的配置，你可以使用一个循环来做到这一点。 例如，如果你想创建三台机器： 123456(1..3).each do |i| config.vm.define "node-#&#123;i&#125;" do |node| node.vm.provision "shell", inline: "echo hello from node #&#123;i&#125;" endend 在ssh会话中覆盖主机语言环境：通常，主机语言环境变量传递给虚拟机。 如果虚拟机软件不支持主机语言环境，则可能会导致失败。 一种可能的解决方案是覆盖Vagrantfile中的语言环境： 12345ENV["LC_ALL"] = "en_US.UTF-8"Vagrant.configure("2") do |config| # ...end 机器设置：以下几组配置以config.开头的配置信息定义了虚拟机的配置信息。 config.vmconfig.vm中设置了Vagrant管理的机器的配置。 配置 作用 config.vm.boot_timeout Vagrant等待机器启动并可访问的时间（秒 默认情况下，这是300秒。 config.vm.box 这将配置该机器要下载的box。可以去HashiCorp/Vagrant Cloud中查找已安装框的名称或框的简写名称。此选项需要Vagrant 1.5或更高版本。 config.vm.box_check_update 如果为true，Vagrant会在每次执行vagrant up时检查配置的config.vm.box的更新。 如果发现更新，Vagrant会告诉用户. config.vm.box_download_checksum 由config.vm.box_url指定的box的校验。如果未指定，则不会执行校验和比较。如果指定，Vagrant会将下载的box校验与这个值和错误进行比较，如果指定了此选项，则还必须指定`config.vm.box_download_checksum_type。 config.vm.box_download_checksum_type 指定的校验和类型。支持的值目前是“md5”，“sha1”和“sha256”，如果执行则还必须指定config.vm.box_download_checksum config.vm.box_download_client_cert 下载邮箱时使用的客户端证书的路径（如果有必要）。 默认情况下，不使用客户端证书来下载该框。 config.vm.box_download_ca_cert 直接下载盒子时使用的CA证书包的路径。 默认情况下，Vagrant将使用Mozilla CA证书包。 config.vm.box_download_ca_path 包含CA证书的目录的路径，用于直接下载box。 默认情况下，Vagrant将使用Mozilla CA证书包。 config.vm.box_download_insecure 如果为true，则来自服务器的SSL证书将不会被验证。 默认情况下，如果URL是HTTPS URL，则SSL证书将被验证。 config.vm.box_download_location_trusted 如果为true，则所有HTTP重定向将被视为可信。这意味着用于初始URL的凭证将用于所有后续重定向。默认情况下，重定向位置不受信任，因此凭据（如果指定）仅用于初始HTTP请求。 config.vm.box_url 可以找到配置的 box的URL。如果config.vm.box的是值是HashiCorp或者Vagrant Cloud中的一个box的简写，那么不需要指定该值。否则，它应该指向没有安装的盒子可以找到的适当位置。 config.vm.box_version 要使用box的版本 config.vm.communicator 用于连接到 guest box 的通信器类型。默认情况下是“ssh”，但对于 Windows 虚拟机应更改为“winrm”。 config.vm.graceful_halt_timeout 调用 vagrant halt 时 Vagrant 等待机器正常停止的时间。默认为 60 秒。 config.vm.guest 将在本机中运行的客户操作系统。默认为 linux，Vagrant 会自动检测正确的发行版。Vagrant 需要知道这些信息才能执行某些客户操作系统特定的事情，例如挂载目录和配置网络。 config.vm.hostname 机器应具有的主机名。默认为 nil。如果为 nil，Vagrant 将不管理主机名。如果设置为字符串，主机名将在引导时设置。 config.vm.network 参考下文网络配置 config.vm.post_up_message 执行 vagrant up 之后显示给用户的消息，可以用于指示如何访问开发环境的各个组件等。 config.vm.provider 配置 provider 特定的配置，该配置用于修改特定于某个 provider 的设置。如果您正在配置的 provider 不存在或未在运行 Vagrant 的系统上设置，则 Vagrant 将忽略此配置块。这允许共享一个适用于多个 provider 的 Vagrantfile，即使没有安装所有的 provider（至少要安装 Vagrantfile 要求的一个 provider）。 config.vm.provision 在机器上配置 provisioner，以便在创建机器时自动安装和配置软件。 参考：provisioner config.vm.synced_folder 在机器上配置已同步的目录，以便主机上的目录可以与客户机同步。 config.vm.usable_port_range Vagrant 可以使用的用来处理端口冲突的一系列端口。默认为 2200..2250。 config.sshconfig.ssh涉及配置Vagrant如何通过SSH访问你的机器。大多数Vagrant的设置，默认值通常就够用了，但是我们还是可以根据自己的实际情况做出微调。 配置 作用 config.ssh.username 默认设置Vagrant将SSH作为用户名。如果自定义设置了用户名，则可以自由覆盖此内容。 config.ssh.password 设置Vagrant将用于验证SSH用户的密码。Vagrant建议在下面使用基于密钥的身份验证而不是密码。 config.ssh.host SSH进入的主机名或IP。默认情况下，这是空的，因为服务提供商通常会为您解决这个问题。 config.ssh.port 进入SSH的端口。默认情况下，这是端口22。 config.ssh.guest_port 运行SSH的guest虚拟机上的端口。这被一些提供商用来检测转发的SSH端口。例如，如果设置为22（默认值），并且Vagrant从主机上的端口4567检测到来宾端口22上的转发端口，则Vagrant将尝试使用端口4567与来宾进行对话（如果没有其他端口）选项。 config.ssh.private_key_path 用于SSH访问客机的私钥的路径。默认情况下，这是随Vagrant一起提供的不安全私钥，因为这是公共盒子使用的私钥。如果您使用自定义SSH密钥创建自己的自定义框，则应该指向该私钥。 config.ssh.keys_only 仅使用Vagrant提供的SSH私钥（不要使用存储在ssh-agent中的任何密钥）。默认值是true。 config.ssh.verify_host_key 执行严格的主机密钥验证。默认值是false。 config.ssh.forward_agent 如果为true，则启用通过SSH连接的代理转发。默认为false。 config.ssh.forward_x11 如果为true，则启用通过SSH连接进行的X11转发。默认为false。 config.ssh.forward_env 要转发给guest虚拟机的主机环境变量数组 config.ssh.insert_key 如果为true，Vagrant将自动插入一个用于SSH的密钥对，如果检测到，则替换机器内部的Vagrant默认不安全密钥。默认为 true config.ssh.proxy_command 执行命令行命令，接收要在stdin上发送到SSH的数据。 config.ssh.pty 如果为true，pty将用于供应。默认为false。 config.ssh.keep_alive 如果为true，则此设置将默认每隔5秒发送一次保持活动数据包，以保持连接处于活动状态。 config.ssh.shell 执行来自Vagrant的SSH命令时使用的shell。默认情况下，这是bash -l。请注意，这对运行vagrant ssh时获得的shell没有影响。此配置选项仅影响在Vagrant内部执行命令时使用的shell。 config.ssh.export_command_template 用于在活动会话中生成导出的环境变量的模板。 config.ssh.sudo_command 使用sudo执行命令时使用的命令。 config.ssh.compression 如果设置为false，则此设置将不包括ssh进入机器时的压缩设置。 如果没有设置，它将默认为true，Compression = yes将使用ssh启用。 config.ssh.dsa_authentication 如果为false，则此设置在ssh登录到计算机时不包括DSAAuthentication。 如果未设置，则默认为true，DSAAuthentication = yes将与ssh一起使用。 config.ssh.extra_args 此设置值直接传递到ssh可执行文件中。 这使您可以传递任何命令来执行诸如反向隧道切入ssh程序之类的任务。 config.vagrant:在设置中config.vagrant修改Vagrant本身的行为。 config.vagrant.host: 设置运行Vagrant主机的类型。默认情况下，这是:detect，这会导致Vagrant自动检测主机。Vagrant需要知道，以执行一些特定主机的东西，如准备NFS文件夹，如果他们启用了此信息。如果自动检测失败的话，您应该手动设置此配置。 config.vagrant.sensitive:(字符串，数组) 值不应该显示在Vagrant的输出值或列表。值将从Vagrant的正常UI输出以及记录器输出中去除。 1config.vagrant.sensitive = [&quot;MySecretPassword&quot;, ENV[&quot;MY_TOKEN&quot;]] config.winrm:https://www.vagrantup.com/docs/vagrantfile/winrm_settings.html config.winssh: https://www.vagrantup.com/docs/vagrantfile/winssh_settings.html Vagrant - 环境构建：镜像下载：由于网络的原因只能在:http://www.vagrantbox.es/下载。 下载完成之后是一个 .box文件。 环境构建：创建一个文件夹，用来存放vagrantfile： 1➜ ~ cd Vagrant &amp;&amp; mkdir centos &amp;&amp; cd centos 添加一个 box 到当前的 目录中： 123456➜ centos vagrant box add --name centos ~/Public/Mirrors/centos-7.3.16.box==&gt; box: Box file was not detected as metadata. Adding it directly...==&gt; box: Adding box 'centos' (v0) for provider: box: Unpacking necessary files from: file:///Users/Yang/Public/Mirrors/centos-7.3.16.box==&gt; box: Successfully added box 'centos' (v0) for 'virtualbox'! 初始化一个Vagrant文件： 12345➜ centos vagrant init centosA `Vagrantfile` has been placed in this directory. You are nowready to `vagrant up` your first virtual environment! Please readthe comments in the Vagrantfile as well as documentation on`vagrantup.com` for more information on using Vagrant. 编辑Vagrantfile文件： 1234567891011121314151617181920212223242526272829303132333435➜ centos vim Vagrantfile# 编辑 Vagrantfile 文件,添加以下内容### start # -*- mode: ruby -*-# vi: set ft=ruby :Vagrant.require_version "&gt;=1.6.0"boxes = [ &#123; :name =&gt; "docker-host", :eth1 =&gt; "192.168.100.100", :mem =&gt; "1024", :cpu =&gt; "1" &#125;]Vagrant.configure("2") do |config| config.vm.box = "centos" boxes.each do |opts| config.vm.define opts[:name] do |config| config.vm.hostname = opts[:name] config.vm.provider "virtualbox" do |v| v.customize ["modifyvm", :id, "--memory", opts[:mem]] v.customize ["modifyvm", :id, "--cpus", opts[:cpu]] end config.vm.network :private_network,ip: opts[:eth1] end end config.vm.synced_folder "~/Share", "/home/vagrant/labs" config.vm.provision "shell", privileged: true, path: "./setup.sh"end### end 在当前目录下创建 setup.sh脚本文件，此举是为了安装 docker 环境： 12345678910111213#/bin/sh# install some toolssudo yum install -y git vim gcc glibc-static telnet bridge-utils net-tools# install dockercurl -fsSL get.docker.com -o get-docker.shsh get-docker.sh# start docker servicesudo systemctl start dockerrm -rf get-docker.sh 配置完成后开始启动本地环境： 1➜ centos vagrant up # 过程省略 大概要等个两三分钟的样子 通过 SSH 进入到刚才启动成功的机器中： 12345➜ centos vagrant ssh[vagrant@docker-host ~]$ cat /etc/centos-release # 查看 centos 的版本CentOS Linux release 7.3.1611 (Core)[vagrant@docker-host ~]$ docker -v # 查看 docker 的版本Docker version 18.05.0-ce, build f150324 docker 相关配置，此举是为了能够让vagrant用户有权限对 docker 进行操作： 123456789[vagrant@docker-host labs]$ sudo systemctl start docker # 启动 docker[vagrant@docker-host labs]$ sudo systemctl stop docker # 停止 docker[vagrant@docker-host labs]$ sudo groupadd docker # 创建 docker 组[vagrant@docker-host labs]$ sudo gpasswd -a vagrant docker # 将用户添加到docker组中# 此时停止 docker 退出 shell 然后再重新登录 [vagrant@docker-host ~]$ systemctl start docker #此处需要认证一下 密码为: vagrant[vagrant@docker-host ~]$ systemctl status docker # 查看 docker 的运行状态 docker hello-world: 12[vagrant@docker-host ~]$ docker pull hello-world[vagrant@docker-host ~]$ docker run hello-world 出现Hello from Docker!则说明 docker 环境没问题。 对了 root用户的密码也是vagrant。 Vagran - 安装插件：快照插件：使用Vagrant的快照功能可以很方便快速的创建当前虚拟机的一个临时备份状态，在进行重要操作时可以先创建一个快照以便在操作失误后快速恢复。 1、安装插件: 1234vagrant plugin install vagrant-vbox-snapshotInstalling the 'vagrant-vbox-snapshot' plugin. This can take a few minutes...Fetching: vagrant-vbox-snapshot-0.0.10.gem (100%)Installed the plugin 'vagrant-vbox-snapshot (0.0.10)'! 2、使用插件： 12345678910创建一个快照vagrant snapshot take [vm-name] # 拍摄快照vagrant snapshot list # 查看当前的快照列表vagrant snapshot go [vm-name] &lt;SNAPSHOT_NAME&gt; # 转到指定快照vagrant snapshot delete [vm-name] &lt;SNAPSHOT_NAME&gt; #删除快照(警告:一个非常慢的操作)vagrant snapshot back [vm-name] # 返回到当前快照 Done.]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Docker</tag>
        <tag>Vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 搭建 Consul 集群]]></title>
    <url>%2F2018%2F04%2F03%2Fcentos-consul%2F</url>
    <content type="text"><![CDATA[环境准备：ssh shell工具： 远程连接三个CentOS示例： 部署集群 配置好各个实例之间的网络访问，以及ssh免密登录。 下载&amp;上传：1、下载 Consul:Download Consul - Consul by HashiCorp 2、上传至虚拟机：123➜ Desktop scp consul_1.1.0_linux_amd64.zip root@192.168.1.11:/opt➜ Desktop scp consul_1.1.0_linux_amd64.zip root@192.168.1.12:/opt➜ Desktop scp consul_1.1.0_linux_amd64.zip root@192.168.1.13:/opt 解压&amp;拷贝在其他几台机器上重复此命步骤：123456789101112[root@centos-1 ~]# yum install unzip -y [root@centos-1 ~]# cd /opt[root@centos-1 opt]# ls consul_1.1.0_linux_amd64.zip [root@centos-1 opt]# unzip consul_1.1.0_linux_amd64.zip Archive: consul_1.1.0_linux_amd64.zip inflating: consul [root@centos-1 opt]# ls consul consul_1.1.0_linux_amd64.zip [root@centos-1 opt]# mv consul /usr/bin/ [root@centos-1 bin]# cd /usr/bin/ &amp;&amp; ls consul consul 启动12[root@centos-1 ~]# consul agent -server -data-dir=/tmp/consul -node=server-1 \-bind=192.168.1.11 -bootstrap-expect 3 -client=0.0.0.0 -ui &amp; 12[root@centos-2 ~]# consul agent -server -data-dir=/tmp/consul -node=server-2 \-bind=192.168.1.12 -join=192.168.1.11 -client=0.0.0.0 -ui &amp; 12[root@centos-3 ~]# consul agent -server -data-dir=/tmp/consul -node=server-3 \-bind=192.168.1.13 -join=192.168.1.11 -client=0.0.0.0 -ui &amp; 选项详解： 选项 说明 consul anent: 该命令会启动一个consulAnent -server 表示该 agent是一个 serverAgent,不添加这个选项则表示是一个 clientAgent -data-dir 表示相关数据存储的目录位置，在 serverAgent上该命令所指示的目录下会存储一些集群的状态信息 -node 指定该 agent 节点的名称，该名称在集群众必须是唯一的 -bind 指定 agent 的 Ip -bootstrap-expect 该命令通知 consul 准备加入集群的节点个数 -client 0.0.0.0 -ui 启动 consulUI，如不添加该指令，则 UI 只能在当前机器上访问 -dc 指定该 agent 加入到哪一个数据中心，默认为 dc1 join 将该节点加入集群中 验证验证集群是否搭建成功，执行consul members，在任意的一台机器上：12345[root@centos-1 ~]# consul membersNode Address Status Type Build Protocol DC Segmentserver-1 192.168.1.11:8301 alive server 1.1.0 2 dc1 &lt;all&gt;server-2 192.168.1.12:8301 alive server 1.1.0 2 dc1 &lt;all&gt;server-3 192.168.1.13:8301 alive server 1.1.0 2 dc1 &lt;all&gt;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>MicroService</tag>
        <tag>Cluster</tag>
        <tag>CentOS</tag>
        <tag>Linux</tag>
        <tag>Consul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『ElasticSearch』- Introduction & QuickStart]]></title>
    <url>%2F2018%2F03%2F25%2Felasticsearch-introduction%2F</url>
    <content type="text"><![CDATA[简介:Elasticsearch是一个高度可扩展的开源全文搜索和分析引擎。它允许您快速、实时地存储、搜索和分析大量数据。它通常被用作支持具有复杂搜索特性和需求的应用的底层引擎/技术。 官网：https://www.elastic.co/ 文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html 版本:截止目前的最新版是 elasticsearch-6.2.4。 安装:下载地址：https://www.elastic.co/downloads在官网的下载页面有提供安装方式： 下载并解压缩Elasticsearch。(ES也提供了apt、yum、msi等安装方式，具体参考官网) 运行./bin/elasticsearch在Linux,Mac上或bin\elasticsearch.bat在Windows上。 运行curl http://localhost:9200/或在浏览器访问http://localhost:9200 CLI参数： Option Description -E 配置设置 -V, –version 打印ES版本信息 -d, –daemonize 以守护进程运行ES -h, –help 查看帮助 -p, –pidfile 在指定的路径上在开始时创建一个PID文件 -q, –quiet 关闭控制台中的标准输出/错误流日志 -s, –silent 显示最小输出 -v, –verbose 显示冗长输出 单实例安装:123➜ ~ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.4.tar.gz➜ ~ tar -xzf elasticsearch-6.2.4.tar.gz➜ ~ cd elasticsearch-6.2.4/ ES可以从命令行启动，如下所示： 1➜ elasticsearch ./bin/elasticsearch 集群安装:创建三个文件夹，依次将elasticsearch-6.2.4.tar.gz解压到三个文件夹中：1234567891011121314➜ ~ mkdir &#123;es-master,es-slave1,es-slave2&#125;➜ ~ tar -vxf elasticsearch-6.2.4.tar.gz -C ~/elasticsearch/es-master➜ ~ tar -vxf elasticsearch-6.2.4.tar.gz -C ~/elasticsearch/es-slave1➜ ~ tar -vxf elasticsearch-6.2.4.tar.gz -C ~/elasticsearch/es-slave2➜ ~ cd elasticsearch # 其它如法炮制➜ elasticsearch cd es-slave1➜ es-slave1 mv elasticsearch-6.2.4/* .➜ es-slave1 lsLICENSE.txt bin lib pluginsNOTICE.txt config logsREADME.textile elasticsearch-6.2.4 modules➜ es-slave1 rm -rf elasticsearch-6.2.4 修改es-master/config/elasticsearch.yml文件, 在结尾追加以下内容: 12345678910➜ es-master vim es-master/config/elasticsearch.yml# 追加以下内容http.cors.enabled: truehttp.cors.allow-origin: "*"cluster.name: Yangnode.name: masternode.master: truenetwork.host: 127.0.0.1 修改es-slave1/config/elasticsearch.yml文件，在结尾追加以下内容: 12345678910➜ es-slave1 vim es-slave1/config/elasticsearch.yml# 追加以下内容cluster.name: Yangnode.name: slave1network.host: 127.0.0.1http.port: 9201discovery.zen.ping.unicast.hosts: ["127.0.0.1"] 修改es-slave2/config/elasticsearch.yml文件，在结尾追加以下内容: 12345678910➜ es-slave2 vim config/elasticsearch.yml# 追加以下内容cluster.name: Yangnode.name: slave2network.host: 127.0.0.1http.port: 9202discovery.zen.ping.unicast.hosts: ["127.0.0.1"] 接下来分别按照下面步骤验证是否安装成功。 验证安装:默认情况下，Elasticsearch在前台运行，会将其日志打印到Console输出，并可通过按停止Ctrl-C。 需要ES在后台运行，可以再启动时候加上-d参数: 1➜ ~ ./bin/elasticsearch -d 查看是否正常运行可以访问http://localhost:9200，或者在控制台查看： 12345678910111213141516➜ ~ curl 'http://localhost:9200/?pretty'&#123; "name" : "mF61KCm", "cluster_name" : "elasticsearch", "cluster_uuid" : "MmELAlGuQVGLgLDjE4bZ2Q", "version" : &#123; "number" : "6.2.4", "build_hash" : "ccec39f", "build_date" : "2018-04-12T20:37:28.497551Z", "build_snapshot" : false, "lucene_version" : "7.2.1", "minimum_wire_compatibility_version" : "5.6.0", "minimum_index_compatibility_version" : "5.0.0" &#125;, "tagline" : "You Know, for Search"&#125; 如果输出以上内容 则说明安装成功。 插件安装:elasticsearch-head：下载地址：https://github.com/mobz/elasticsearch-head 安装步骤： 1234➜ ~ git clone git://github.com/mobz/elasticsearch-head.git➜ ~ cd elasticsearch-head➜ ~ npm install➜ ~ npm run start 启动成功之后访问：http://localhost:9100 kibana:下载地址：https://www.elastic.co/downloads/kibana 安装步骤： 123➜ ~ tar -zxvf kibana-6.2.4-darwin-x86_64.tar.gz -C elasticsearch/➜ ~ cd elasticsearch &amp;&amp; mv kibana-6.2.4-darwin-x86_64 kibana➜ kibana ./bin/kibana # 启动Kibana 启动成功之后 访问:http://localhost:5601。 官方的安装步骤上讲在启动前，要修改./config/kibana.yml文件中的elasticsearch.url，但是elasticsearch.url的默认值是http://localhost:9200,所以此处不做修改。 值得注意的是，kibana在下载的时候，一定要选择与自己当前系统相对应的版本，不然…… 集群管理：集群健康状态：可以再kibana中使用GET /_cat/health?v来查看集群的健康状态: 12345GET /_cat/health?v# 返回结果:epoch timestamp cluster status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent1527521915 23:38:35 Yang green 3 3 0 0 0 0 0 0 - 100.0% 集群的健康状态status有三种状态： green：每个索引的primary shard和replica shard都是active状态的yellow：每个索引的primary shard都是active状态的，但是部分replica shard不是active状态，处于不可用的状态red：不是所有索引的primary shard都是active状态的，部分索引有数据丢失了 API操作： API 说明 GET /_cat/health?v 检查集群健康状态 GET /_cat/indices?v 查看集群中有哪些索引 GET _cluster/state 检查集群状态信息 GET /_cat/master?v 查看master的节点ID，绑定IP地址，节点名称 GET /_cat/nodes?v 输出当前集群的拓扑结构 官方文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/cat.html 索引操作:创建索引:12345678PUT /test_index?pretty# 返回结果:&#123; "acknowledged": true, "shards_acknowledged": true, "index": "test_index"&#125; 查看索引:12345GET /_cat/indices?v# 返回结果:health status index uuid pri rep docs.count docs.deleted store.size pri.store.sizegreen open test_index oDZBadoQQAuxMVb7ekUl5g 5 1 0 0 2.2kb 1.1kb 删除索引:123456DELETE /test_index?pretty# 返回结果:&#123; "acknowledged": true&#125; CRUD:新增文档：新增文档使用PUTAPI来操作。 语法：PUT /index/type/id 123456789101112131415161718192021222324PUT /shop/product/1&#123; "name":"Thinking in Java", "desc":"Java Conding API Book", "price":120, "from":"Machinery Industry Press", "tags":["Java","Coding"] &#125;# 返回结果:&#123; "_index": "shop", "_type": "product", "_id": "1", "_version": 1, "result": "created", "_shards": &#123; "total": 2, "successful": 2, "failed": 0 &#125;, "_seq_no": 0, "_primary_term": 1&#125; 替换文档:替换文档同样可以使用PUTAPI来操作，注意每次完成后返回结果的_version会发生变化。 语法：PUT /index/type/id 123456789101112131415161718192021222324PUT /shop/product/1&#123; "name":"Thinking in Java", "desc":"Java Conding API Book", "price":119, "from":"Machinery Industry Press", "tags":["Java","Coding"] &#125;# 返回结果:&#123; "_index": "shop", "_type": "product", "_id": "1", "_version": 2, # 由1变为2 "result": "updated", "_shards": &#123; "total": 2, "successful": 2, "failed": 0 &#125;, "_seq_no": 5, "_primary_term": 1&#125; 修改文档：修改文档使用POSTAPI来操作。 语法：POST /index/type/id 12345678910111213141516171819202122POST /shop/product/1/_update&#123; "doc": &#123; "price":108 &#125;&#125;# 返回结果:&#123; "_index": "shop", "_type": "product", "_id": "1", "_version": 2, "result": "updated", "_shards": &#123; "total": 2, "successful": 2, "failed": 0 &#125;, "_seq_no": 8, "_primary_term": 1&#125; 检索文档：检索文档使用GETAPI来操作。 语法：GET /index/type/id 1234567891011121314151617181920GET /shop/product/1# 返回结果:&#123; "_index": "shop", "_type": "product", "_id": "1", "_version": 2, "found": true, "_source": &#123; "name": "Thinking in Java", "desc": "Java Conding API Book", "price": 119, "from": "Machinery Industry Press", "tags": [ "Java", "Coding" ] &#125;&#125; 删除文档：删除文档使用 DELETEAPI来操作： 语法：DELETE /index/type/id 1234567891011121314151617DELETE /shop/product/1# 返回结果:&#123; "_index": "shop", "_type": "product", "_id": "1", "_version": 3, "result": "deleted", "_shards": &#123; "total": 2, "successful": 2, "failed": 0 &#125;, "_seq_no": 6, "_primary_term": 1&#125; es会自动建立index和type，不需要提前创建，而且es默认会对document每个field都建立倒排索引，让其可以被搜索。]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 安装 Jenkins]]></title>
    <url>%2F2018%2F03%2F13%2Fcentos-jenkins%2F</url>
    <content type="text"><![CDATA[Jenkins 简介Jenkins 是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。 Jenkins 安装安装基础环境在安装Jenkins之前，首先我们需要准备 Java 环境，使用下面命令来安装 Java： 1[root@localhost ~]# yum -y install java-1.8.0-openjdk-devel 为了使用 Jenkins 仓库，我们要执行以下命令：12[root@localhost ~]# sudo wget -O /etc/yum.repos.d/jenkins.repo \ https://pkg.jenkins.io/redhat-stable/jenkins.repo[root@localhost ~]# sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key 如果您以前从 Jenkins 导入过 key，那么 rpm --import 将失败，因为您已经有一个 key。请忽略，继续下面步骤。 安装Jenkins接着我们可以使用 yum 安装 Jenkins： 1[root@localhost ~]# yum -y install jenkins 启动 Jenkins启动启动 Jenkins 并设置为开机启动： 12[root@localhost ~]# systemctl start jenkins.service[root@localhost ~]# chkconfig jenkins on 测试访问Jenkins 默认运行在 8080端口。 稍等片刻，打开 http://192.168.1.10:8080 测试访问。 进入 Jenkins管理员密码登入 Jenkins 需要输入管理员密码，按照提示，我们使用以下命令查看初始密码： 1cat /var/lib/jenkins/secrets/initialAdminPassword 复制密码，填入，进入 Jenkins。 定制 Jenkins我们选择默认的 install suggested plugins 来安装插件。 创建用户请填入相应信息创建用户，然后即可登入 Jenkins中。 Done.]]></content>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker - Introduction & QuickStart]]></title>
    <url>%2F2018%2F03%2F11%2Fdocker-introduction%2F</url>
    <content type="text"><![CDATA[Docker - 概述Docker包括了一个命令行程序、一个后台守护进程、以及一组远程服务。它解决了常见的软件问题，并且简化了安装、运行、发布和删除程序。这一切的实现是通过使用一项 UNIX 技术，称之为容器。 容器与虚拟机:容器:容器是应用程序层的一个抽象，将代码和依赖关系打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为孤立进程运行。容器占用的空间少于虚拟机（容器图像的大小通常为几十MB），并且几乎立即启动。 虚拟机:虚拟机（VM）是将一台服务器变成多台服务器的物理硬件的抽象。管理程序允许多台虚拟机在单台机器上运行。每个VM都包含一个操作系统的完整副本，一个或多个应用程序，必需的二进制文件和库 - 占用数十GB。 VM也可能启动缓慢。 Docker - 版本Docker有两个版本：Community Edition（CE）社区版和Enterprise Edition（EE）企业版。 社区版适合希望开始使用Docker并尝试使用基于容器的应用程序的开发人员和小型团队。 Docker CE有两个更新通道，稳定和优势： 稳定给你每一个季度的可靠的更新 Edge每个月都会为您提供新功能 企业版（EE）专为企业级开发人员和IT团队而设计，他们在大规模生产中构建，发布和运行关键业务应用程序。 Reference：https://docs.docker.com/engine/installation/ Docker - 特点 Docker能够通过容器提供更小的操作系统占用空间，从而缩小开发规模。 有了容器，跨不同部门的团队（如开发人员，质量保证人员和操作人员）可以更轻松地跨应用程序进行无缝工作。 您可以在任何物理和虚拟机，甚至是云上的任何位置部署Docker容器。 由于Docker容器非常轻便，所以它们非常容易扩展。 Docker - 组件Docker有以下组件： Docker for Mac - 它允许在Mac OS上运行Docker容器。 Docker for Linux - 它允许在Linux操作系统上运行Docker容器。 Docker for Windows - 它允许在Windows操作系统上运行Docker容器。 Docker Engine - 用于构建Docker镜像和创建Docker容器。 Docker Hub - 这是用来托管各种Docker镜像的注册表。 Docker Compose - 用于定义使用多个Docker容器的应用程序。 Docker - 应用场景Docker提供了轻量级的虚拟化，几乎没有其他任何额外开销。其次，相比于虚拟机，我们可以在同一台机器上创建更多数量的容器。Docker 另外一个特点是启动和停止都能在几秒钟完成。 简化配置：同一个Docker的配置可以在不同的环境中使用，这样降低了硬件要求和应用环境之间耦合度。 代码管理：Docker给应用提供了一个从开发到上线均一致的环境，让代码的流水线变得简单不少。 隔离应用：有很多种原因会让你选择在一个机器上运行不同的应用，这时候隔离应用会非常有用 整合服务器：通过虚拟机来整合多个应用，Docker隔离应用的能力使得Docker可以整合多个服务器以降低成本 调试能力：Docker 提供了许多的工具，这些工具不一定针对容器，却适用于容器 多租户环境：Docker 在多租户的环境中可以避免关键应用的重写 快速部署：传统的部署模式是安装-&gt;配置-&gt;运行，Docker的部署模式是：复制-&gt;运行 Docker - 安装配置由于 Docker 的局限性，Docker 只能运行在64位的系统中。 1[root@localhost ~]# getconf LONG_BIT CentOS安装Docker :系统要求:要安装Docker CE，您需要维护版本的CentOS 7。不支持或测试归档版本。 必须启用centos-extras存储库。此存储库默认情况下处于启用状态，但如果您已禁用该存储库，则需要重新启用该存储库。 卸载旧版本:老版本的Docker被称为docker或docker-engine。如果安装了这些，请卸载它们以及相关的依赖项。 12345678910[root@localhost ~]# $ sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine 如果yum报告说没有安装这些软件包，那也没关系。 /var/lib/docker/包括图像，容器，卷和网络的内容将被保留。Docker CE包现在被称为docker-ce。 安装Docker CE:yum 安装:安装所需的包：123[root@localhost ~]# sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 添加yum库：123[root@localhost ~]# sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo 安装最新版docker-ce:1[root@localhost ~]# yum install docker-ce 查看版本：12[root@localhost ~]# docker -v Docker version 18.03.1-ce, build 9ee9f40 shell安装：在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS系统上可以使用这套脚本安装： 12[root@localhost ~]# curl -fsSL get.docker.com -o get-docker.sh[root@localhost ~]# sh get-docker.sh --mirror Aliyun 或者使用 wget： 1[root@localhost ~]# wget -qO- https://get.docker.com/ | sh 执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 edge 版本安装在系统中。 其他安装方式请参考官网所提供的文档: Reference：https://docs.docker.com/engine/installation/linux/docker-ce/centos/#prerequisites 配置加速服务：因为国内访问 Docker Hub 较慢, 可以使用腾讯云提供的国内镜像源, 加速访问 Docker Hub 123[root@localhost ~]# echo "OPTIONS='--registry-mirror=https://mirror.ccs.tencentyun.com'" &gt;&gt; /etc/sysconfig/docker[root@localhost ~]# systemctl daemon-reload[root@localhost ~]# service docker restart Docker - Hello World在安装好 Docker 之后，可以再命令行终端中输入: 1[root@localhost ~]# docker run hello-world 之后，Docker被激活，开始下载各种组件，并最终打印出Hello from Docker!，在这个过程成 Docker依照流程做了如下事情： docker runDocker 在本机寻找镜像Docker在 DockerHub 上寻找该镜像是否安装？Docker下载该镜像DockerHub是是否存在？是在本机中安装此镜像Docker 创建了一个新的容器并启动改该程序容器运行起来了 当第二次执行docker run hello-world的时候，Docker 会检查是否安装了hello-world 这个镜像，如果已经安装，Docker 会创建一个新的容器并启动该程序。 Docker - 简单操作： 指令 参数 docker build 通过dockerfile生成镜像 docker images 查看当前本地有哪些docker镜像 docker pull 下载镜像 docker run 通过docker镜像生成docker容器(docker help run 查看run命令) docker ps 查看正在up运行中的docker镜像，docker ps -a 查看所有的 docker exec 进入容器 docker attach 进入容器 docker rm 删除容器，-f 强制删除，up状态的也可以删除 docker rmi 删除images，通过image的id来指定删除谁 docker start 启动一个容器 docker stop 停止提一个容器 docker tag 给镜像打标签（docker tag imageid name:tag） docker status 在宿主机查看docker使用cpu、内存、网络、io情况 docker logs 查看容器的日志 更多命令参看 https://docs.docker.com/engine/reference/commandline/docker/ 可以参考每一个镜像的文档https://hub.docker.com/ 参考资料:Docker Get Started：https://docs.docker.com/get-started/ 8 Ways to Use Docker in the Real World:http://blog.flux7.com/blogs/docker]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 安装 Git]]></title>
    <url>%2F2018%2F03%2F07%2Fcentos-git%2F</url>
    <content type="text"><![CDATA[Git简介Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 Git安装Git 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 安装依赖库和编译工具为了后续安装能正常进行，我们先来安装一些相关依赖库和编译工具 12[root@localhost ~]# yum install curl-devel expat-devel\ gettext-devel openssl-devel zlib-devel 安装编译工具 1[root@localhost ~]# yum install -y gcc perl-ExtUtils-MakeMaker 下载 git选一个目录，用来放下载下来的安装包，这里将安装包放在 /opt 目录里 1[root@localhost ~]# cd /opt/ 到官网找一个新版稳定的源码包下载到 /usr/local/src 文件夹里 1[root@localhost opt]# wget https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz 解压和编译解压下载的源码包 1[root@localhost opt]# tar -xvf git-2.10.0.tar.gz 解压后进入 git-2.10.0 文件夹 1[root@localhost opt]# cd git-2.10.0 执行编译 1[root@localhost git-2.10.0]# make all prefix=/usr/local/git 编译完成后, 安装到 /usr/local/git 目录下 1[root@localhost git-2.10.0]# make install prefix=/usr/local/git Git配置将 git 目录加入 PATH将原来的 PATH 指向目录修改为现在的目录 1[root@localhost ~]# echo 'export PATH=$PATH:/usr/local/git/bin' &gt;&gt; /etc/profile 生效环境变量 1[root@localhost ~]# source /etc/profile 此时我们能查看 git 版本号，说明我们已经安装成功了。 12[root@localhost ~]# git --versiongit version 1.8.3.1 创建 git 账号密码创建 git 账号为我们刚刚搭建好的 git 创建一个账号 1[root@localhost ~]# useradd -m git #自动建立用户的登入目录。 然后为这个账号设置密码1[root@localhost ~]# passwd git 在控制台输入创建密码后，输入您自定义的密码，并二次确认。 初始化仓库和配置权限创建 git 仓库并初始化我们创建 /data/repo 目录用于存放 git 仓库 1[root@localhost ~]# mkdir -p /data/repo 创建好后，初始化这个仓库 12[root@localhost ~]# cd /data/repo/ &amp;&amp; git init --bare test.git 初始化空的 Git 版本库于 /data/repo/test.git/ 配置用户权限给 git 仓库目录设置用户和用户组并设置权限 1[root@localhost repo]# chown -R git:git /data/repo/ 1[root@localhost repo]# chmod 755 . 编辑 /etc/passwd 文件，将最后一行关于 git 的登录 shell 配置改为 git-shell 的目录123[root@localhost ~]# vim /etc/passwd # /etc/passwd： 加入以下内容 git:x:500:500::/home/git:/usr/local/git/bin/git-shell 如果按照刚才的步骤执行, 这个位置应该是 /usr/local/git/bin/git-shell, 否则请通过 which git-shell 命令查看位置 安全目的, 限制 git 账号的 ssh 连接只能是登录 git-shell 使用搭建好的Git服务克隆 test repo 到本地 12➜ Desktop git clone git@192.168.1.10:/data/repo/test.gitfatal: destination path 'test' already exists and is not an empty directory. Done.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 安装 Redis]]></title>
    <url>%2F2018%2F03%2F02%2Fcentos-redis%2F</url>
    <content type="text"><![CDATA[环境说明: 名称 版本 CentOS CentOS Linux release 7.4.1708 (Core) VMware Fusion 专业版 10.1.1 (7520154) SSH Shell Version: 17.08 (612B58F) Redis redis-2.6.14.tar.gz 下载&amp;上传：12下载地址https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/redis/redis-2.6.14.tar.gz 123➜ Linux Soft scp redis-2.6.14.tar.gz root@192.168.1.10:/optroot@192.168.1.10's password:redis-2.6.14.tar.gz 100% 972KB 31.0MB/s 00:00 安装 GCC&amp;G++：1yum install gcc gcc-c++ -y 解压:1234[root@localhost ~]# cd /opt/ [root@localhost opt]# tar -xf redis-2.6.14.tar.gz -C /usr/local/ [root@localhost opt]# ls /usr/local/ bin etc games include lib lib64 libexec redis-2.6.14 sbin share src 编译安装：123[root@localhost opt]# cd /usr/local/redis-2.6.14/ [root@localhost redis-2.6.14]# make &amp;&amp; make install[root@localhost redis-2.6.14]# make test 生产环境配置：123456789101112131415161718[root@localhost redis-2.6.14]# cp utils/redis_init_script /etc/init.d/[root@localhost redis-2.6.14]# cd /etc/init.d/ [root@localhost init.d]# mv redis_init_script redis_6379 [root@localhost init.d]# mkdir /etc/redis [root@localhost init.d]# mkdir -p /var/redis/6379 [root@localhost init.d]# cd /usr/local/redis-2.6.14/ [root@localhost redis-2.6.14]# cp redis.conf /etc/redis/ [root@localhost redis-2.6.14]# cd /etc/redis/ [root@localhost redis]# vim redis.conf # 修改 redis.conf中的以下四项daemonize yes #让redis以daemon进程运行pidfile /var/run/redis_6379.pid #设置redis的pid文件位置port 6379 #设置redis的监听端口号dir /var/redis/6379 #设置持久化文件的存储位置[root@localhost redis]# vim redis.conf [root@localhost redis]# mv redis.conf 6379.conf 启动和停止:/etc/init.d/redis_6379 这个脚本有两个参数start和stop分别来控制redis的启动和停止:12345[root@localhost redis]# /etc/init.d/redis_6379 start Starting Redis server... [root@localhost redis]# /etc/init.d/redis_6379 stop Stopping ... Redis stopped 随系统启动:12345678# 修改 redis_6379文件，在最开始加入以下内容(前两行为注释):[root@localhost init.d]# vim redis_6379 # chkconfig: 2345 90 10 # description: Redis is a persistent key-value database chkconfig redis_6379 on [root@localhost init.d]# chkconfig redis_6379 on redis-cli的使用:redis-cli ，进入本机 redis-cli 界面 redis-cli SHUTDOWN，连接本机的6379端口停止redis进程 redis-cli -h 127.0.0.1 -p 6379, 远程连需要接指定要连接的ip和端口号 redis-cli -h 127.0.0.1 -p 6379 SHUTDOWN,远程关闭 redis 服务 redis-cli PING，ping redis的端口，看是否正常 redis-cli，进入交互式命令行 其他常见问题:可视化链接：连接前需要关闭防火墙:1systemctl stop firewalld &amp;&amp; systemctl disable firewalld 启动脚本执行：如果出现启动脚本执行没有权限，可以使用chmod给予权限: 1chmod 777 redis_6379]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 安装 Nginx]]></title>
    <url>%2F2018%2F02%2F25%2Fcentos-nginx%2F</url>
    <content type="text"><![CDATA[在 CentOS 中使用 yum 直接来安装 Nginx的话会出现如下错误，原因是Nginx这个软件不是 yum源中自带的，所以需要手动来配置添加 Nginx 的 yum 源。 12345678[root@centos-linux ~]# yum install nginx 已加载插件：fastestmirror Loading mirror speeds from cached hostfile * base: ftp.sjtu.edu.cn * extras: ftp.sjtu.edu.cn * updates: ftp.sjtu.edu.cn 没有可用软件包 nginx。 错误：无须任何处理 添加 yum源:1[root@centos-linux ~]# rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 安装 Nginx:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758yum install nginx 已加载插件：fastestmirror nginx | 2.9 kB 00:00:00 nginx/x86_64/primary_db | 34 kB 00:00:02 Loading mirror speeds from cached hostfile * base: ftp.sjtu.edu.cn * extras: ftp.sjtu.edu.cn * updates: ftp.sjtu.edu.cn 正在解决依赖关系 --&gt; 正在检查事务 ---&gt; 软件包 nginx.x86_64.1.1.14.0-1.el7_4.ngx 将被 安装 --&gt; 解决依赖关系完成 依赖关系解决 ========================================================================================================================= Package 架构 版本 源 大小 =========================================================================================================================正在安装: nginx x86_64 1:1.14.0-1.el7_4.ngx nginx 750 k 事务概要=========================================================================================================================安装 1 软件包总下载量：750 k安装大小：2.6 MIs this ok [y/d/N]: y6Is this ok [y/d/N]: yDownloading packages:nginx-1.14.0-1.el7_4.ngx.x86_64.rpm | 750 kB 00:00:41 Running transaction checkRunning transaction testTransaction test succeededRunning transaction警告：RPM 数据库已被非 yum 程序修改。 正在安装 : 1:nginx-1.14.0-1.el7_4.ngx.x86_64 1/1 ----------------------------------------------------------------------Thanks for using nginx!Please find the official documentation for nginx here:* http://nginx.org/en/docs/Please subscribe to nginx-announce mailing list to getthe most important news about nginx:* http://nginx.org/en/support.htmlCommercial subscriptions for nginx are available on:* http://nginx.com/products/---------------------------------------------------------------------- 验证中 : 1:nginx-1.14.0-1.el7_4.ngx.x86_64 1/1 已安装: nginx.x86_64 1:1.14.0-1.el7_4.ngx 完毕！ 查看Nginx的软件包信息:12345678910111213141516171819202122232425262728293031323334[root@centos-linux ~]# rpm -ql nginx/etc/logrotate.d/nginx/etc/nginx/etc/nginx/conf.d/etc/nginx/conf.d/default.conf/etc/nginx/fastcgi_params/etc/nginx/koi-utf/etc/nginx/koi-win/etc/nginx/mime.types/etc/nginx/modules/etc/nginx/nginx.conf/etc/nginx/scgi_params/etc/nginx/uwsgi_params/etc/nginx/win-utf/etc/sysconfig/nginx/etc/sysconfig/nginx-debug/usr/lib/systemd/system/nginx-debug.service/usr/lib/systemd/system/nginx.service/usr/lib64/nginx/usr/lib64/nginx/modules/usr/libexec/initscripts/legacy-actions/nginx/usr/libexec/initscripts/legacy-actions/nginx/check-reload/usr/libexec/initscripts/legacy-actions/nginx/upgrade/usr/sbin/nginx/usr/sbin/nginx-debug/usr/share/doc/nginx-1.14.0/usr/share/doc/nginx-1.14.0/COPYRIGHT/usr/share/man/man8/nginx.8.gz/usr/share/nginx/usr/share/nginx/html/usr/share/nginx/html/50x.html/usr/share/nginx/html/index.html/var/cache/nginx/var/log/nginx Nginx 的简单操作:关闭防火墙:1systemctl stop firewalld.service 查看 Nginx版本：1nginx -v 启动 Nginx服务：1systemctl start nginx 停止 Nginx服务：1systemctl stop nginx 重启 Nginx 服务：1systemctl restart nginx 查看 Nginx 服务状态：12345678910111213[root@centos-linux html]# systemctl status nginx● nginx.service - nginx - high performance web server Loaded: loaded (/usr/lib/systemd/system/nginx.service; disabled; vendor preset: disabled) Active: active (running) since 一 2018-05-14 07:04:11 CST; 7min ago Docs: http://nginx.org/en/docs/ Process: 1928 ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf (code=exited, status=0/SUCCESS) Main PID: 1929 (nginx) CGroup: /system.slice/nginx.service ├─1929 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf └─1930 nginx: worker process5月 14 07:04:10 centos-linux systemd[1]: Starting nginx - high performance web server...5月 14 07:04:11 centos-linux systemd[1]: Started nginx - high performance web server.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 安装OpenJDK1.8 & OracleJDK1.8]]></title>
    <url>%2F2018%2F01%2F21%2Fcentos-jdk%2F</url>
    <content type="text"><![CDATA[安装OpenJDK1.8 ：检查当前机器是否有自带的JDK:123rpm -qa |grep javarpm -qa |grep jdkrpm -qa |grep gcj 如果没有 则跳至安装步骤，有的话 进行卸载:1rpm -qa | grep java | xargs rpm -e --nodeps 更新yum源:1yum update -y 搜索yum中的软件包:1yum list java-1.8* 安装OpenJDK:1yum install java-1.8.0-openjdk* -y 验证是否安装成功:12345java -version返回信息如下，则说明安装成功：openjdk version &quot;1.8.0_161&quot;OpenJDK Runtime Environment (build 1.8.0_161-b14)OpenJDK 64-Bit Server VM (build 25.161-b14, mixed mode) 其它常见问题：如果出现command not found命令找不到的话，则说明环境除了问题，此时需要找到OpenJDK的安装位置，将其配置到/etc/profile文件中：1234export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.161-3.b14.el6_9.x86_64export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=$CLASSPATH:.:$&#123;JAVA_HOME&#125;/lib:$&#123;JAVA_HOME&#125;/jre/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$&#123;JAVA_HOME&#125;/jre/bin:$PATH 配置完成之后，重新加载一下该文件：1source /etc/profile 安装OracleJDK1.8 ：下载 OracleJDK1.8 &amp; 上传:12下载地址：http://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-linux-x64.tar.gz 123➜ Linux Soft scp jdk-8u171-linux-x64.tar.gz root@192.168.1.10:/optroot@192.168.1.10's password:jdk-8u171-linux-x64.tar.gz 解压至/usr/:12345678910111213141516[root@centos-linux ~]# cd /opt/ [root@centos-linux opt]# du -sm jdk-8u171-linux-x64.tar.gz 183 jdk-8u171-linux-x64.tar.gz [root@centos-linux opt]# tar -xf jdk-8u171-linux-x64.tar.gz [root@centos-linux opt]# mv jdk jdk1.8.0_171/ jdk-8u171-linux-x64.tar.gz [root@centos-linux opt]# mv jdk1.8.0_171 jdk jdk1.8.0_171/ jdk-8u171-linux-x64.tar.gz [root@centos-linux opt]# mv jdk1.8.0_171 jdk1.8 [root@centos-linux opt]# mv jdk1.8/ /usr/[root@centos-linux opt]# cd /usr/[root@centos-linux usr]# lsbin etc games include jdk1.8 lib lib64 libexec local sbin share src tmp[root@centos-linux usr]# cd jdk1.8/ [root@centos-linux jdk1.8]# pwd/usr/jdk1.8 配置环境变量:1234567891011[root@centos-linux ~]# vim /etc/profile # 在/etc/profile文件中大约第54行添加如下内容# Java Envexport JAVA_HOME=/usr/jdk1.8export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=$CLASSPATH:.:$&#123;JAVA_HOME&#125;/lib:$&#123;JAVA_HOME&#125;/jre/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$&#123;JAVA_HOME&#125;/jre/bin:$PATH [root@centos-linux ~]# source /etc/profile 验证是否安装成功:1234[root@centos-linux ~]# java -version java version "1.8.0_171" Java(TM) SE Runtime Environment (build 1.8.0_171-b11) Java HotSpot(TM) 64-Bit Server VM (build 25.171-b11, mixed mode)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去掉CentOS中取消滴滴滴的声音]]></title>
    <url>%2F2018%2F01%2F08%2Fcentos-inputrc%2F</url>
    <content type="text"><![CDATA[CentOS7 中去掉烦人的滴滴滴的声音在CentOS中，我们常用Tab键进行命令补全，但是系统总是提示滴滴声，让人很烦躁。 即使把音频设备关掉，或者虚拟机的音频设备也关掉，还是有这个声音。 如果不喜欢这个声音，可以通过修改配置去掉它。用vim编辑” /etc/inputrc“ 文件，在”vim“的命令模式下，用键盘方向键进行定位， 找到“#set bell-style none”，用X 删除语句前方的#号，就可以了。“:wq”进行文件保存，并对系统进行重启以后，既可以去掉这个烦扰的声音了。 代码示例：123# do not bell on tab-completionset bell-style nonereboot Done.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac中设置Sublime快速在终端中使用命令打开项目]]></title>
    <url>%2F2017%2F12%2F21%2Fsublime%2F</url>
    <content type="text"><![CDATA[工作中用Atom比较多，比较喜欢Atom可以直接在终端中直接输入atom .就能直接打开项目的功能，于是搜索得知sublime text也有这样的功能，下面就简单的配置了一下： 12sudo ln -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl \/usr/local/bin/subl # 创建软链 Done.]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Sublime Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端页面基础CSS布局+Reset原有样式]]></title>
    <url>%2F2017%2F12%2F05%2Fmobile-css%2F</url>
    <content type="text"><![CDATA[移动端页面基础CSS布局+Reset原有样式代码如下: 12345678910111213141516171819202122232425262728293031/*reset css*/*,::before,::after&#123; margin: 0; padding: 0; /*清除移动端的默认的 点击高亮效果*/ -webkit-tap-highlight-color: transparent; /* 设置 所有的box-sizing 移动端所有盒子以边框开始计算宽度 使用百分比布局*/ -webkit-box-sizing: border-box; box-sizing: border-box;&#125;body&#123; /*sans-serif: 设备默认字体*/ font-family:"Microsoft Sans Serif",sans-serif; font-size: 14px; color: #333;&#125;a&#123; color: #333;&#125;a:hover&#123; text-decoration: none;&#125;input&#123; border:none; outline: none; /*清除移动默认的表单样式*/ -webkit-appearance: none;&#125;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Mobile</tag>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot - 使用Spring Data JDBC]]></title>
    <url>%2F2017%2F11%2F24%2Fspringboot-springdata-jdbc%2F</url>
    <content type="text"><![CDATA[简介：Spring Data JDBC Extensions是Spring Data项目的一部分。Spring Framework中的JDBC支持非常广泛，涵盖了最常用的功能。此扩展项目为使用高级Oracle数据库功能提供了额外的支持。 配置:pom.xml：1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.29&lt;/version&gt;&lt;/dependency&gt; application.yml:123456789spring: datasource: platform: mysql name: world_x type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost/world_x?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false password: root username: root 数据源配置：springdata-jdbc默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源； 数据源的相关配置都在DataSourceConfiguration里面: 1org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration SpringBoot支持以下三种数据源: 123org.apache.tomcat.jdbc.pool.DataSourceHikariDataSourceBasicDataSource 自定义数据源:1234567891011121314/** * Generic DataSource configuration. */@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = "spring.datasource.type")static class Generic &#123; @Bean public DataSource dataSource(DataSourceProperties properties) &#123; //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); &#125;&#125; 自动配置原理：源码路径：`org.springframework.boot.autoconfigure.jdbc; 源码片段： 12345678910111213141516171819202122232425262728package org.springframework.boot.autoconfigure.jdbc;@Configuration@ConditionalOnClass(&#123; DataSource.class, JdbcTemplate.class &#125;)@ConditionalOnSingleCandidate(DataSource.class)@AutoConfigureAfter(DataSourceAutoConfiguration.class)public class JdbcTemplateAutoConfiguration &#123; private final DataSource dataSource; public JdbcTemplateAutoConfiguration(DataSource dataSource) &#123; this.dataSource = dataSource; &#125; @Bean @Primary @ConditionalOnMissingBean(JdbcOperations.class) public JdbcTemplate jdbcTemplate() &#123; return new JdbcTemplate(this.dataSource); &#125; @Bean @Primary @ConditionalOnMissingBean(NamedParameterJdbcOperations.class) public NamedParameterJdbcTemplate namedParameterJdbcTemplate() &#123; return new NamedParameterJdbcTemplate(this.dataSource); &#125;&#125; JdbcTemplateAutoConfiguration使用@AutoConfigureAfter注解导入DataSourceAutoConfiguration。 开发：JDBC模板：Spring的JDBC框架承担了资源管理和异常处理的工作，从而简化了JDBC的代码，让我们只需要遍写从数据库读写数据的必须代码。Spring为JDBC提供了三个模板类供选择： JdbcTemplate: 最基本的SpringJDBC模板，这个模板支持最简单的JDBC数据库访问功能以及基于索引参数的查询。 NamedParameterJdbcTemplate: 使用该模板类执行查询时可以将值以命名参数的形式绑定到SQL中，而不是使用简单的索引参数。 SimpleJdbcTemplate: 该模板类利用Java5的一些特性来简化JDBC模板的使用。 从Spring3.1开始，SimpleJdbcTemplate已经被废弃了，特性被转入到JdbcTemplate中，NamedParameterJdbcTemplate只有在需要使用到命名参数的时候才需要使用到这个模板类，对于绝大多数的JDBC操作来讲，JdbcTemplate 就是最好的选择。 JDBCTemplate：JdbcTemplate主要提供以下五类方法： execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句； update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句； query方法及queryForXXX方法：用于执行查询相关语句； call方法：用于执行存储过程、函数相关语句。 batchUpdate方法：用于执行批处理相关语句； 注意：这个项目好像被废弃了，Spring官网好像也没有提供文档。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
        <tag>Spring</tag>
        <tag>Spring Data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot - 使用Swagger2构建Rest服务]]></title>
    <url>%2F2017%2F10%2F29%2Fspringboot-restservice%2F</url>
    <content type="text"><![CDATA[简介：Swagger：Swagger（Swagger 2）是用于描述和记录REST API的规范。它指定了REST Web服务的格式，包括URL，资源，方法等。Swagger将从应用程序代码生成文档并处理渲染部分。 Springfox提供了两个依赖关系来生成API Doc和Swagger UI。如果不希望将Swagger UI集成到您的API级别中，则无需添加Swagger UI依赖项。 Restful：Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 Restful使用HTTP,URI,XML,JSON,HTML等广泛流行的标准和协议;轻量级,跨平台,跨语言的架构设计; URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 配置：Swagger2：要在项目中使用Swagger2，则需要添加以下依赖： 1234567891011 &lt;!--Swagger 相关依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 还需要在SpringBoot的启动类上添加注解： 12345678@EnableSwagger2@SpringBootApplicationpublic class SpringbootRestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootRestApplication.class, args); &#125;&#125; 开发：pom.xml:1234567891011121314151617181920212223242526272829303132333435363738&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.jayway.jsonpath&lt;/groupId&gt; &lt;artifactId&gt;json-path&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--Swagger 相关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; greeting:12345@Datapublic class Greeting &#123; private final long id; private final String content;&#125; GreetingController:12345678910111213141516171819202122@Api(value = "GreetingController",tags = "Controller")@RestControllerpublic class GreetingController &#123; private static final String template = "Hello, %s!"; private final AtomicLong counter = new AtomicLong(); @ApiOperation(value = "测试Rest",notes = "Rest") @ApiImplicitParams(&#123; @ApiImplicitParam(paramType ="query",name ="name",dataType = "String",required = true,value = "Rest",defaultValue = "Rest") &#125;) @ApiResponses(&#123; @ApiResponse(code = 400,message = "请求参数填写错误"), @ApiResponse(code = 404,message = "请求路径错误") &#125;) @RequestMapping("/greeting") public Greeting greeting(@RequestParam(value="name", defaultValue="Rest") String name) &#123; return new Greeting(counter.incrementAndGet(), String.format(template, name)); &#125;&#125; Swagger注解的使用： @Api()用于类； 表示标识这个类是swagger的资源 @ApiOperation()用于方法； 表示一个http请求的操作 @ApiParam()用于方法，参数，字段说明； 表示对参数的添加元数据（说明或是否必填等） @ApiModel()用于类 表示对类进行说明，用于参数用实体类接收 @ApiModelProperty()用于方法，字段 表示对model属性的说明或者数据操作更改 @ApiIgnore()用于类，方法，方法参数 表示这个方法或者类被忽略 @ApiImplicitParam() 用于方法 表示单独的请求参数 @ApiImplicitParams() 用于方法，包含多个 @ApiImplicitParam]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
        <tag>Spring</tag>
        <tag>Swagger</tag>
        <tag>SpringFox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『Node.js - Express』 - QuickStart]]></title>
    <url>%2F2017%2F10%2F28%2Fcentos-express%2F</url>
    <content type="text"><![CDATA[安装 NodeJS安装 NodeJS在终端中，使用下面的命令安装 NodeJS： 12curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -yum -y install nodejs curl –silent –location https://rpm.nodesource.com/setup_8.x | sudo bash -yum -y install nodejs 安装完成后，可使用下面的命令测试安装结果：node -v 安装 Express创建工作目录使用下面的命令在服务器创建一个工作目录： 1mkdir -p /data/release/hello 然后进入此工作目录： 1cd /data/release/hello 初始化项目通过 npm init 命令为你的应用创建一个 package.json 文件。 需要了解 package.json 是如何起作用的，请参考 Specifics of npm’s package.json handling。 npm init此命令将要求你输入几个参数，例如此应用的名称和版本。 除 entry point: (index.js) 参数外，其他参数你可以直接按 “回车” 键接受默认设置即可。对于 entry point: (index.js) 参数，键入 app.js或者你所希望的名称，这是当前应用的入口文件；如果你希望采用默认的 index.js 文件名，只需按 “回车” 键即可。 安装 Express接下来安装 Express 并将其保存到依赖列表中： 1npm install express --save 如果只是临时安装 Express，不想将它添加到依赖列表中，只需略去 --save 参数即可 npm install express。 Hello World创建 app.js在 hello 目录中，创建 app.js，然后将下列代码复制进去： 12345678910var express = require('express');var app = express();app.get('/', function (req, res) &#123; res.send('Hello World!');&#125;);var server = app.listen(3000, function () &#123; console.log('Example app listening on port 3000!');&#125;); 完成后，使用 Ctrl + S 保存文件。 上面的代码启动一个服务并监听从 3000 端口进入的所有连接请求。他将对所有 (/) URL 或 路由 返回 “Hello World!” 字符串。对于其他所有路径全部返回 404 Not Found** 。 启动应用通过如下命令启动此应用：node app.js然后在浏览器中打开 http://119.29.130.84:3000 并查看输出结果。（如果访问不成功，可能是机器安全组禁用了 3000 端口所致，你可以前往控制台修改安全组配置。）该步骤完成后，可使用 Ctrl + C 终止运行。 Express 应用生成器安装 Express 应用生成器通过应用生成器工具 express 可以快速创建一个应用的骨架。通过如下命令安装： 1npm install express-generator -g -h 选项可以列出所有可用的命令行选项：express -h,将得到输出： 123456789101112Usage: express [options] [dir]Options: --version output the version number -e, --ejs add ejs engine support --pug add pug engine support --hbs add handlebars engine support -H, --hogan add hogan.js engine support -v, --view &lt;engine&gt; add view &lt;engine&gt; support (dust|ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade) -c, --css &lt;engine&gt; add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css) --git add .gitignore -f, --force force on non-empty directory -h, --help output usage information 创建项目进入工作目录：cd /data/release执行如下命令，在当前工作目录下创建一个命名为 myapp的应用：express myapp 完成后。生成的应用程序具有以下目录结构： 1234567891011121314151617181920# tree myapp/myapp/|-- app.js|-- bin| `-- www|-- package.json|-- public| |-- images| |-- javascripts| `-- stylesheets| `-- style.css|-- routes| |-- index.js| `-- users.js`-- views |-- error.jade |-- index.jade `-- layout.jade7 directories, 9 files 启动应用进入该应用目录：cd myapp然后安装所有依赖包：npm install，安装所需的依赖包。 然后启动这个应用： （MacOS 或 Linux 平台）：DEBUG=myapp npm start (Windows 平台输入)：set DEBUG=myapp &amp; npm start 然后在浏览器中打开 http://localhost:3000 网址就可以看到这个应用了。（该步骤完成后，可使用 Ctrl + C 终止运行。） 基本路由Express 路由简介路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问。每一个路由都可以有一个或者多个处理器函数，当匹配到路由时，这些函数将被执行。 路由的定义由如下结构组成： app.METHOD(PATH, HANDLER) 其中： app 是一个 express 实例； METHOD 是某个 HTTP 请求方式 中的一个 PATH 是服务器端的路径； HANDLER 是当路由匹配到时需要执行的函数 一个简单的 Express 路由修改 hello 项目 返回开始创建的 hello 项目：cd /data/release/hello 编辑 app.js，参考修改如下： 1234567891011121314151617181920212223242526var express = require('express');var app = express();// 对网站首页的访问返回 "Hello World!" 字样app.get('/', function (req, res) &#123; res.send('Hello World!');&#125;);// 网站首页接受 POST 请求app.post('/', function (req, res) &#123; res.send('Got a POST request');&#125;);// /user 节点接受 PUT 请求app.put('/user', function (req, res) &#123; res.send('Got a PUT request at /user');&#125;);// /user 节点接受 DELETE 请求app.delete('/user', function (req, res) &#123; res.send('Got a DELETE request at /user');&#125;);var server = app.listen(3000, function () &#123; console.log('Example app listening on port 3000!');&#125;); 启动应用node app.js。 （该步骤完成后，可使用 Ctrl + C 终止运行。）测试你可以使用 curl 命令或 Postman 等工具进行测试。如在本地终端执行： curl -X POST http://localhost:3000 curl -X PUT http://localhost:3000/user curl -X DELETE http://localhost:3000/user 静态文件利用 Express 托管静态文件通过 Express 内置的 express.static 可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等。创建静态目录创建 public 目录：mkdir -p /data/release/hello/public**在 public 目录下，创建 hello.html，然后复制下列代码到 hello.html 中： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 修改应用编辑 app.js，参考修改如下： 12345678var express = require('express');var app = express();app.use(express.static('public'));var server = app.listen(3000, function () &#123; console.log('Example app listening on port 3000!');&#125;); 我们在 app.js 中将静态资源文件所在的目录作为参数传递给 express.static 中间件，这样就可以提供静态资源文件的访问了。启动应用node app.js在浏览器中打开 http://localhost:3000/hello.html网址就可以看到这个文件了。你还可以将本地的文件通过拖拽至左边目录树的 public 目录上传文件来测试。假设在 public 目录放置了图片、CSS 和 JavaScript 文件，你就可以从浏览器中访问： http://localhost:3000/images/kitten.jpghttp://localhost:3000/css/style.csshttp://localhost:3000/js/app.jshttp://localhost:3000/images/bg.pnghttp://localhost:3000/hello.html static 中间件更多用法 多个目录如果你的静态资源存放在多个目录下面，你可以多次调用 express.static 中间件：·· 12app.use(express.static('public'));app.use(express.static('files')); 访问静态资源文件时，express.static 中间件会根据目录添加的顺序查找所需的文件。指定路径如果你希望所有通过 express.static 访问的文件都存放在一个“虚拟（virtual）”目录（即目录根本不存在）下面，可以通过为静态资源目录指定一个挂载路径的方式来实现，如下所示： 12345678var express = require('express');var app = express();app.use('/static', express.static('public'));var server = app.listen(3000, function () &#123; console.log('Example app listening on port 3000!');&#125;); 参考修改如下：app.js启动应用：node app.js现在，你就可以通过带有 “/static” 前缀的地址来访问 public 目录下面的文件了。 如：http://localhost:3000/static/hello.html]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『NoSQL - MongoDB』CRUD]]></title>
    <url>%2F2017%2F10%2F23%2Fmongodb-crud%2F</url>
    <content type="text"><![CDATA[前言本文从讲解了 MongoDB 的数据导入导出，以及 CRUD 操作。 数据下载: JSON示例数据:(美国马萨诸塞州邮政代码-&gt;点击下载)。 12345678910&#123; "_id" : "01001", #序号 "city" : "AGAWAM", #城市 "loc" : [ #坐标 -72.622739, 42.070206 ], "pop" : 15338, #标记 "state" : "MA" #州缩写&#125; 其他 JSON 数据下载:http://jsonstudio.com/resources/ MongoDB - 导入数据:简介:mongoimport工具从由其他第三方导出工具创建或可能的[扩展JSON]，CSV或TSV导出导入内容`mongoexport。 mongoimport是以系统命令行运行，而不是MongoShell。 操作：json 导入：示例代码： 1mongoimport --db jsonar --collection zips --file /Users/Desktop/zips.json –db：数据库名称 –collection：集合名称 –file：文件路径 csv导入：示例代码： 1mongoimport --db users --collection contacts --type csv --headerline --file /opt/backups/contacts.csv –type: 文件类型 注意事项:mongoimport支持UTF-8编码的数据文件。使用其他编码会产生错误。 Reference：https://docs.mongodb.com/manual/reference/program/mongoimport/index.html MongoDB - 导出数据:简介：mongoexport 是一个实用程序，可以生成一个JSON或CSV导出存储在MongoDB实例中的数据。 mongoimport是以系统命令行运行，而不是MongoShell。 操作:json导出:1mongoexport --db jsonar --collection zips --out ~/Desktop/zips.json csv导出:1mongoexport --db jsonar --collection zips --out ~/Desktop/zips.csv –out 参数指定了导出的文件类型以及文件路径，更多导出方式请参考官方文档。 Reference：https://docs.mongodb.com/manual/reference/program/mongoexport/index.html MongoDB - 插入文档:在向 MongoDB 数据库中执行插入操作的时候，如果集合(collection)不存在，插入操作会自动创建一个集合(当然，MongoDB 也提供了db.createCollection(&quot;emp&quot;);方法来创建集合)，存储于集合中的每一个文档都需要一个唯一的_id字段作为 primary_key。如果一个插入文档操作遗漏了_id 字段，MongoDB驱动会自动为_id字段生成一个 [ObjectId]，这种情况同样适用于带有参数的 [upsert: true]的 update 操作。 MongoDB主要提供了以下三个方法向集合插入文档: db.collection.insertOne() db.collection.insertMany() db.collection.insert() insertOne:db.collection.insertOne()将单个文档插入到集合中。 示例代码： 123db.inventory.insertOne(... &#123; item: "canvas", qty: 100, tags: ["cotton"], size: &#123; h: 28, w: 35.5, uom: "cm" &#125; &#125;... ) 运行结果: 1234&#123; "acknowledged" : true, "insertedId" : ObjectId("59eee499cbb5fc46080e6d87")&#125; insertOne() 返回一个结果文档，该结果文档中列举了插入文档的_id 字段值为ObjectId(&quot;59eee499cbb5fc46080e6d87&quot;)。 insertMany:db.collection.insertMany()可以将多个文档插入到集合中。 示例代码： 12345db.inventory.insertMany([... &#123; item: "journal", qty: 25, tags: ["blank", "red"], size: &#123; h: 14, w: 21, uom: "cm" &#125; &#125;,... &#123; item: "mat", qty: 85, tags: ["gray"], size: &#123; h: 27.9, w: 35.5, uom: "cm" &#125; &#125;,... &#123; item: "mousepad", qty: 25, tags: ["gel", "blue"], size: &#123; h: 19, w: 22.85, uom: "cm" &#125; &#125;... ]) 运行结果: 12345678&#123; "acknowledged" : true, "insertedIds" : [ ObjectId("59eeeb7dcbb5fc46080e6d89"), ObjectId("59eeeb7dcbb5fc46080e6d8a"), ObjectId("59eeeb7dcbb5fc46080e6d8b") ]&#125; insertMany() 返回包含新插入的文档_id字段值的文档。 insert:db.collection.insert() 将单个文档或多个文档插入到集合中。 插入单个文档:示例代码: 1db.products.insert( &#123; item: "card", qty: 15 &#125; ) 运行结果: 1WriteResult(&#123; "nInserted" : 1 &#125;) 插入多个文档：示例代码： 1234567db.products.insert( [ &#123; _id: 11, item: "pencil", qty: 50, type: "no.2" &#125;, &#123; item: "pen", qty: 20 &#125;, &#123; item: "eraser", qty: 25 &#125; ]) 运行结果： 12345678910BulkWriteResult(&#123; "writeErrors" : [ ], "writeConcernErrors" : [ ], "nInserted" : 3, "nUpserted" : 0, "nMatched" : 0, "nModified" : 0, "nRemoved" : 0, "upserted" : [ ]&#125;) MongoDB - 读取文档:MongoDB 提供了 db.collection.find() 方法从集合中读取文档。此方法返回一个游标，要访问文档，需要迭代游标。但是，在MongoShell中，如果返回的游标未使用var关键字分配给变量，那么光标自动迭代最多20次，打印到结果中的前20个文档。(可以使用 DBQuery.shellBatchSize 来改变迭代次数的默认值 20。) 要查询集合中的所有文档，需要将空文档作为查询过滤器参数传递给find方法。 基础查询:查询 zips 集合中的全部数据，示例代码: 1db.zips.find(&#123;&#125;); 运行结果： 12345&#123; "_id" : "01001", "city" : "AGAWAM", "loc" : [ -72.622739, 42.070206 ], "pop" : 15338, "state" : "MA" &#125;&#123; "_id" : "01002", "city" : "CUSHMAN", "loc" : [ -72.51565, 42.377017 ], "pop" : 36963, "state" : "MA" &#125;&#123; "_id" : "01005", "city" : "BARRE", "loc" : [ -72.108354, 42.409698 ], "pop" : 4546, "state" : "MA" &#125;&#123; "_id" : "01007", "city" : "BELCHERTOWN", "loc" : [ -72.410953, 42.275103 ], "pop" : 10579, "state" : "MA" &#125;&#123; "_id" : "01008", "city" : "BLANDFORD", "loc" : [ -72.936114, 42.182949 ], "pop" : 1240, "state" : "MA" &#125; 如果觉得返回结果太乱，可以使用.pretty()来格式化显示。 查询时也可以指定不需要显示的字段，示例代码： 1db.zips.find(&#123;&#125;,&#123;"loc":0&#125;) 运行结果: 1234567891011121314151617181920212223/* 1 */&#123; "_id" : "01001", "city" : "AGAWAM", "pop" : 15338, "state" : "MA"&#125;/* 2 */&#123; "_id" : "01002", "city" : "CUSHMAN", "pop" : 36963, "state" : "MA"&#125;/* 3 */&#123; "_id" : "01005", "city" : "BARRE", "pop" : 4546, "state" : "MA"&#125; 对于设置的显示字段严格来讲就称为数据的投影操作，如果不需要显示的字段设置“0”，而需要显示的字段设置“1”。 查询时也可以指定相等条件，语法db.集合名称.find({查询条件} [,{设置显示的字段}]。 示例代码： 1db.inventory.find( &#123; city: "SPRINGFIELD" &#125; ) 运行结果: 1234567891011121314151617181920212223242526272829303132333435/* 1 */&#123; "_id" : "01103", "city" : "SPRINGFIELD", "loc" : [ -72.588735, 42.1029 ], "pop" : 2323, "state" : "MA"&#125;/* 2 */&#123; "_id" : "01104", "city" : "SPRINGFIELD", "loc" : [ -72.577769, 42.128848 ], "pop" : 22115, "state" : "MA"&#125;/* 3 */&#123; "_id" : "01105", "city" : "SPRINGFIELD", "loc" : [ -72.578312, 42.099931 ], "pop" : 14970, "state" : "MA"&#125; 关系运算:在MongoDB里面支持的关系查询操作：大于（$gt）、小于（$lt）、大于等于（$gte）、小于等于（$lte）、不等于（$ne）、等于（key:value、$eq）。 查询pop大于20000的数据: $gt:1db.zips.find(&#123;pop:&#123;$gt:20000&#125;&#125;) $lt:查询pop小于1000的数据 : 1db.zips.find(&#123;pop:&#123;$lt:1000&#125;&#125;) $gte:查询pop 大于等于90000的数据： 1db.zips.find(&#123;pop:&#123;$gte:90000&#125;&#125;) $lte:查询 pop 小于等于10的数据： 1db.zips.find(&#123;pop:&#123;$lte:10&#125;&#125;) $ne:查询 pop 不等于100的数据: 1db.zips.find(&#123;pop:&#123;$ne:100&#125;&#125;) $eq:查询 pop 等于100的数据: 1db.zips.find(&#123;pop:&#123;$eq:100&#125;&#125;) 逻辑运算:逻辑运算主要就是三种类型：与（$and）、或（$or）、非（$not、$nor）。 $and:查询 pop为等于10000和city 存在的数据(显式$and查询): 1db.zips.find(&#123;$and:[&#123;pop:&#123;$ne:10000&#125;&#125;,&#123;city:&#123;$exists:true&#125;&#125;]&#125;) 查询pop值再10000 - 20000之间的数据(隐式$and查询)： 1db.zips.find(&#123;pop:&#123;$gte:10000,$lte:20000&#125;&#125;) $or:查询city 为SPRINGFIELD或者pop 大于10000的数据： 1db.zips.find(&#123;$or:[&#123;city:"SPRINGFIELD"&#125;,&#123;pop:&#123;$gte:10000&#125;&#125;]&#125;) $nor:查询city 不为SPRINGFIELD或者 pop 小于10000的数据(进行或的取反操作): 1db.zips.find(&#123;$nor:[&#123;city:"SPRINGFIELD"&#125;,&#123;pop:&#123;$gte:10000&#125;&#125;]&#125;) 求模运算:$mod:求模运算使用“$mod”来完成，语法“{$mod : [数字,余数]}”。 1db.zips.find(&#123;pop:&#123;$mod:[100,10]&#125;&#125;) 范围查询:“$in”（在范围之中）、“$nin”（不在范围之中） $in:查询 city 为AGAWAM、CUSHMAN、SPRINGFIELD三个值的数据: 1db.zips.find(&#123;city:&#123;$in:["AGAWAM","CUSHMAN","SPRINGFIELD"]&#125;&#125;) $nin:查询 city 中不含AGAWAM、CUSHMAN、SPRINGFIELD三个值的数据: 1db.zips.find(&#123;city:&#123;$nin:["AGAWAM","CUSHMAN","SPRINGFIELD"]&#125;&#125;) 数组查询:MongoDB中，需要针对于数组数据查询操作，可以使用几个运算符：$all、$size、$slice、$elemMatch。 $all:查询loc 有42.070206的数据: 1db.zips.find(&#123;loc:&#123;$all:[42.070206]&#125;&#125;) 虽然“$all”计算可以用于数组上，但是也可以用于一个数据的匹配上。 查询loc 有-72.108354和42.409698的数据： 1db.zips.find(&#123;loc:&#123;$all:[-72.108354,42.409698]&#125;&#125;) $size:查询 loc中字段数量为2的数据： 1db.zips.find(&#123;loc:&#123;$size:2&#125;&#125;) $slice:查询 loc中city为SPRINGFIELD并且字段数量为2的数据： 1db.zips.find(&#123;city:"SPRINGFIELD"&#125;,&#123;loc:&#123;$slice:1&#125;&#125;) 查询 loc中city为SPRINGFIELD的数据数据跳过第一条数据返回两条数据： 1db.zips.find(&#123;city:"SPRINGFIELD"&#125;,&#123;loc:&#123;$slice:[1,2]&#125;&#125;) 下标查询:查询 loc中数组的第二个字段，值为42.070206的数据: 1db.zips.find(&#123;"loc.1":42.070206&#125;) 既然在集合里面现在保存的是数组信息，那么数组就可以利用索引操作，使用“key.index”的方式来定义索引。 条件过滤：$where:查询 pop 值小于10的数据: 1db.zips.find(&#123;$where:"this.pop &lt; 10"&#125;); 查询 pop 值小于10的数据和id大于10000的值: 1db.zips.find(&#123;"$and":[&#123;"$where":"this.pop &lt; 10"&#125;,&#123;"$where":"this._id &gt; 10000"&#125;]&#125;) 正则匹配:在 MongoDB 中，如果想模糊查询，那就要使用正则表达式来匹配，而且正则表达式使用的是语言Perl兼容的正则表达式的形式。如果要想实现正则使用，则按照如下的定义格式： ·基础语法：{key : 正则标记}； ·完整语法：{key : {“$regex” : 正则标记 , “$options” : 选项}}。 指令 释义 语法 i 忽略字母大小写 m 在每行的开始或结尾匹配具有多行值的字符串(多行查找) x 空白字符串除了被转义的或在字符类中意外的完全被忽略 需要$ regex与$ options语法 s 匹配所有的字符（圆点、“.”），包括换行内容。 需要$ regex与$ options语法 查询 state中以 K 开头的数据(^)： 1db.zips.find(&#123;state:/^K/&#125;) 查询 state中包含 k 的数据(不区分大小写)： 12db.zips.find(&#123;state:/k/i&#125;)db.zips.find(&#123;state:&#123;$regex:/K/i&#125;&#125;) 两种写法均可实现。 数据排序:MongoDB中数据的排序操作使用“sort()”函数，在进行排序的时候可以有两个顺序：升序（1）、降序（-1）。 查询 pop 数据进行升序排序： 1db.zips.find(&#123;&#125;).sort(&#123;pop:1&#125;) 查询 id 数据进行降序排序: 1db.zips.find(&#123;&#125;).sort(&#123;_id:-1&#125;) 数据分页: skip(n)：表示跨过多少数据行； limit(n)：取出的数据行的个数限制。 查询从0开始每页显示10条数据根据 id升序排序： 123db.zips.find(&#123;&#125;).skip(0).limit(10).sort(&#123;&quot;_id&quot;:1&#125;)db.zips.find(&#123;&#125;).skip(10).limit(10).sort(&#123;&quot;_id&quot;:1&#125;) 其他查询：$exists:查询 pop 的值存在且不含1000-5000之间的数据: 1db.zips.find( &#123; pop: &#123; $exists: true, $nin: [ 1000, 5000 ] &#125; &#125; ) MongoDB - 更新文档:在MongoDB中，对于数据的更新操作提供了两类函数：save()、update()。 方法名称 使用介绍 db.collection.updateOne() 即使可能有多个文档通过过滤条件匹配到，但是也最多也只更新一个文档。 db.collection.updateMany() 更新所有通过过滤条件匹配到的文档 db.collection.replaceOne() 即使可能有多个文档通过过滤条件匹配到，但是也最多也只替换一个文档。 db.collection.update() 即使可能有多个文档通过过滤条件匹配到，但是也最多也只更新或者替换一个文档。 默认情况下db.collection.update()只更新一个文档。要更新多个文档，请使用 multi 选项。 修改器:$set：$set用来指定一个键的值 $unset: $unset用来将键完全删除 $inc:用于，增加和减少：1、键不存在时创建一个键2、增加已有键的值对于分析数据、因果关系、投票或者其他变化数值的地方，使用这个非常方便。 save:save() 方法通过传入的文档来替换已有文档. 示例代码： 12345678910db.zips.save(&#123; "_id" : "01001", "city" : "AGAWAM", "loc" : [ -72.622739, 42.070206 ], "pop" : 15338, "state" : "ZHN"&#125;) 运行结果: 1WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;) update:语法: 12345678910db.collection.update( &lt;query&gt;, &lt;update&gt;, &#123; upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt;, collation: &lt;document&gt; &#125;) upsert：布尔值可选。如果设置为true，则在没有文档与查询条件匹配时创建新文档。默认值为false，在找不到匹配项时不插入新文档。 示例代码： 1db.zips.update(&#123; _id: 01001&#125;,&#123;"city":"ShenZhen","state":"ZHN"&#125;,&#123;upsert: true&#125;) 运行结果: 1WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;) updateOne:语法： 123456789db.collection.updateOne( &lt;filter&gt;, &lt;update&gt;, &#123; upsert: &lt;boolean&gt;, writeConcern: &lt;document&gt;, collation: &lt;document&gt; &#125;) 示例代码: 1db.zips.updateOne(&#123;"_id":"01002"&#125;,&#123;$set:&#123;state:"CHN"&#125;&#125;) 运行结果: 1&#123; "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 &#125; updateMany:语法: 123456789db.collection.updateMany( &lt;filter&gt;, &lt;update&gt;, &#123; upsert: &lt;boolean&gt;, writeConcern: &lt;document&gt;, collation: &lt;document&gt; &#125;) 参数说明: 参数 类型 详解 filter document 更新的选择条件，与find()方法中的查询选择器使用方式相同，可以 指定一个空文档{}来更新集合中的所有文档。 update document 使用更新操作符，如$ set，$ unset或$ rename。 使用update（）模式的更改参数的值：value引发错误。 upsert boolean 可选参数。当为true时，updateMany() 如果没有文档与过滤器匹配，则创建新文档。 更新与过滤器匹配的文档。 为了避免多个提前插入，请确保过滤器字段被唯一索引。 默认为false。 writeConcern document 可选参数。描述MongoDB对独立mongod或复制集合或分片集群的写操作所请求的确认级别，省略使用默认的写入关注。 collation document 可选参数。 指定要用于操作的排序规则。 排序规则允许用户指定用于字符串比较的特定于语言的规则，例如字母和重音符号的规则。 示例代码: 1db.zips.updateMany(&#123; "state" : "CHN" &#125;,&#123; $set: &#123; pop: "1000"&#125;&#125;,&#123;upsert:true&#125;); 运行结果: 1&#123;"acknowledged" : true, "matchedCount" : 1.0, "modifiedCount" : 0.0&#125; replaceOne:语法： 123456789db.collection.replaceOne( &lt;filter&gt;, &lt;replacement&gt;, &#123; upsert: &lt;boolean&gt;, writeConcern: &lt;document&gt;, collation: &lt;document&gt; &#125;) 示例代码： 1db.zips.replaceOne(&#123; "state" : "CHN" &#125;,&#123; "pop" : 0, "state" : "CHINA"&#125;); 运行结果: 1&#123;"acknowledged" : true,"matchedCount" : 1.0,"modifiedCount" : 1.0&#125; MongoDB - 删除文档:MongoDB提供以下方法来删除集合的文档： 方法 说明 db.collection.deleteOne() 最多删除与指定过滤器匹配的单个文档，即使多个文档可能与指定的过滤器匹配。 db.collection.deleteMany() 删除与指定过滤器匹配的所有文档。 db.collection.remove() 删除单个文档或与指定过滤器匹配的所有文档。 deleteOne：语法： 1234567db.collection.deleteOne( &lt;filter&gt;, &#123; writeConcern: &lt;document&gt;, collation: &lt;document&gt; &#125;) 选项说明: filter：类型为 document；使用查询运算符指定删除条件，指定一个空文档{}删除集合中返回的第一个文档。 writeConcern：类型为document；可选参数；描述MongoDB对独立mongod或复制集合或分片集群的写操作所请求的确认级别，省略使用默认的写入关注。 collation：类型为document；可选参数；指定要用于操作的排序规则。 排序规则允许用户指定用于字符串比较的特定于语言的规则，例如字母和重音符号的规则。 示例代码: 1db.zips.deleteOne(&#123;state:"CHINA"&#125;,&#123;&#125;) 运行结果： 1&#123;"acknowledged" : true,"deletedCount" : 1.0&#125; deleteMany:语法： 1234567db.collection.deleteMany( &lt;filter&gt;, &#123; writeConcern: &lt;document&gt;, collation: &lt;document&gt; &#125;) 删除所有符合 state:&quot;MA&quot;的数据： 1db.zips.deleteMany(&#123;state:"MA"&#125;,&#123;&#125;) 运行结果: 1&#123;"acknowledged" : true,"deletedCount" : 472.0&#125; 删除所有符合state中以R开头的数据(不区分大小写)： 1db.zips.deleteMany(&#123;state:/^R/i&#125;,&#123;&#125;) 运行结果: 1&#123;"acknowledged" : true,"deletedCount" : 70.0&#125; remove：romeve函数有两个选项： 删除条件：满足条件的数据被删除； 是否只删除一个数据，如果设置为true或者是1表示只删除一个。 语法: 1234db.collection.remove( &lt;query&gt;, &lt;justOne&gt;) 选项说明： query:类型为document；使用查询运算符指定删除条件，需要清空集合，可以指定为{}。 justOne:类型为document；可选参数；要将删除限制为只有一个文档，请设置为true。省略使用默认值false并删除符合删除条件的所有文档。 删除 pop 小于2000的数据: 1db.zips.remove(&#123;pop:&#123;$lt:2000&#125;&#125;) 运行结果： 1Removed 12436 record(s) in 180ms 删除 city 为MASON的数据，只删除一个: 1db.zips.remove(&#123;city:"MASON"&#125;,&#123;justOne:true&#125;) 运行结果: 1Removed 1 record(s) in 1ms 删除_id 中带有9的数据： 1db.zips.remove(&#123;_id:/9/&#125;) 运行结果: 1Removed 5255 record(s) in 91ms 清空集合zips中的所有内容: 1db.zips.remove(&#123;&#125;) 运行结果: 1Removed 11235 record(s) in 136ms 删除zips 集合: 1db.zips.drop() 运行结果: 1true 参考资料：查询运算符：https://docs.mongodb.com/manual/reference/operator/query/ MongoDB-CRUD：https://docs.mongodb.com/manual/crud/ MongoDB-writeConcern：https://docs.mongodb.com/manual/reference/write-concern/]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『NoSQL - MongoDB』Mongo Shell]]></title>
    <url>%2F2017%2F10%2F18%2Fmongodb-shell%2F</url>
    <content type="text"><![CDATA[前言本文从介绍了MongoShell 的配置、脚本、数据类型和其他指令。 MongoShell - 简介MongoShell是一个互动的JavaScript接口的MongoDB，可以使用MongoShell来查询和更新数据以及执行管理操作。 MongoShell是MongoDB发行版的一个组件， 安装并启动MongoDB后，将MongoShell连接到正在运行的MongoDB实例，MongoDB手册中的大多数示例使用 MongoShell，然而，许多驱动程序也提供了与MongoDB类似的接口。 启动MongoShell：在启动MongoShell之前请确保MongoDB 实例在运行，在Terminal 中键入Mongo则可以直接启动。 示例代码： 1234567891011➜ ~ mongoMongoDB shell version v3.4.3connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.3Server has startup warnings:2017-10-19T10:41:29.922+0800 I CONTROL [initandlisten]2017-10-19T10:41:29.923+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2017-10-19T10:41:29.923+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted.2017-10-19T10:41:29.923+0800 I CONTROL [initandlisten]&gt; db.version()3.4.3 选项/参数:当没有任何参数运行mongo时，mongo shell将尝试连接到端口27017上的localhost接口上运行的MongoDB实例。 链接选项:如果需要链接非27017端口或者远程实例，则可以使用以下语法来链接: 1mongo --username &lt;user&gt; --password &lt;pass&gt; --host &lt;host&gt; --port 28015 或者简写为: 1mongo -u &lt;user&gt; -p &lt;pass&gt; --host &lt;host&gt; --port 28015 .mongorc.js文件:当启动的时候，mongo检查用户HOME目录下的一个JavaScript文件.mongorc.js，如果找到mongo在首次显示提示信息前解析.mongorc.js的内容。如果你使用shell执行一个JavaScript文件或计算表达式，要么通过在命令行使用–eval选项或者指定一个.js文件给mongo，mongo会在完成JavaScript的处理后读取.mongorc.js文件。你可以使用–norc选项来阻止加载.mongorc.js。 使用MongoShell:测试数据:(这个 employee 对象是包含 3 个员工记录的数组) 1234567891011121314151617 &#123; "employees":[ &#123; "firstName":"Bill", "lastName":"Gates" &#125;, &#123; "firstName":"George", "lastName":"Bush" &#125;, &#123; "firstName":"Thomas", "lastName":"Carter" &#125; ]&#125; 显示当前正在使用的数据库： 12&gt; dbtest 查看所有数据库: 123456&gt; show dbsadmin 0.000GBlocal 0.000GB&gt; show databasesadmin 0.000GBlocal 0.000GB 使用show dbs或者show databases可以达到同样的效果。 切换到另一个数据库: 12&gt; use mydbswitched to db mydb 可以切换到一个不存在数据库，当创建集合时，这个数据库会被自动创建。 插入一条数据:12345&gt; db.emp.insertOne(&#123;x : 1&#125;);&#123; "acknowledged" : true, "insertedId" : ObjectId("59e87617052057c4236c259a")&#125; 其中 db指的是当前的数据库，emp 指的是要插入的集合的名称。 查看当前数据库中所有集合： 12&gt; show collectionsemp 查看集合中的数据: 12&gt; db.emp.find()&#123; "_id" : ObjectId("59e87617052057c4236c259a"), "x" : 1 &#125; 格式化输出结果:要格式化打印结果，可以将.pretty()添加到操作中，如下所示： 12345&gt; db.emp.find().pretty()&#123; "_id": ObjectId("59e87617052057c4236c259a"), "x": 1&#125; 此外，可以在 mongo shell中使用下面的显式打印方法： print() 无格式打印 print(tojson()) 用 JSON 格式打印，等效于 printjson() printjson() 用 JSON 格式打印，等效于 print(tojson()) shell 中的多行操作：如果你的代码行以左括号 (&#39;(&#39;)，左大括号 (&#39;{&#39;)或左中括号 (&#39;[&#39;) 结束，那么随后的一行将以省略号 (&quot;...&quot;) 开始，直到你输入对应的右括号 (&#39;)&#39;)，右大括号 (&#39;}&#39;)或右中括号 (&#39;]&#39;) 。 mongoshell在执行代码以前将一直等待右括号，右大括号或右中括号，如下例所示： 1234&gt; if ( x &gt; 0 ) &#123;... count++;... print (x);... &#125; 也可以通过按下两次回车键来结束这次输入: 1234&gt; if (x &gt; 0......&gt; 退出 shell 操作:在MongoShell中输入quit()或者按下 Ctrl+C的组合键方式来结束 shell。 MongoShell - 配置自定义提示符：可以通过在 MongoShell中设置变量 prompt 的值来修改提示符的内容。prompt 变量可以存储字符串以及JavaScript代码。 如果 prompt 为返回字符串的函数， mongo 则会在每个提示符中展示动态信息。 显示当前Shell的操作数：显示当前MongoShell 的操作数量，示例代码： 1234cmdCount = 1;prompt = function() &#123; return (cmdCount++) + "&gt; ";&#125; 配置好之后，提示符会变成这样: 1231&gt;2&gt;3&gt; 显示数据库和主机名:示例代码: 12345host = db.serverStatus().host;prompt = function() &#123; return db+"@"+host+"$ ";&#125; 提示符将会变成如下样式： 1test@HostName$ 显示Mongo服务的启动时间以及文档数:示例代码： 123prompt = function() &#123; return "Uptime:"+db.serverStatus().uptime+" Documents:"+db.stats().objects+" &gt; ";&#125; 提示符将会变成如下样式： 1Uptime:90104 Documents:0 &gt; 以上关于 prompt的相关配置均可以在 MongoShell中直接输入配置，也可以将其写入再.mongorc.js文件中。 使用外部编辑器：可以通过在启动 MongoShell之前设置 EDITOR环境变量来在MongoShell中使用自己的编辑器。 12➜ ~ export EDITOR=vim➜ ~ mongo 进入MongoShell 之后，可以输入edit 使用之前定义的 vim 编辑器来编辑代码。 示例代码： 定义函数: 1function myFunc () &#123; &#125; 使用指定的编辑器来编辑函数： 1edit myFunc 此命令可以打开 Vim 编辑会话。当编辑完成之后，保存并退出编辑会话。 调用函数: 直接在 shell 中输入函数名可以查看函数体，输入函数名() 可以调用函数。 修改批处理大小：db.collection.find()方法是从集合中检索文档的JavaScript方法。db.collection.find()方法返回一个游标到结果;然而，在mongo shell中，如果返回的游标未使用var关键字分配给变量，则光标自动迭代最多20次，以打印到与查询匹配的前20个文档。 mongo shell将提示键入它再次迭代20次。 可以设置 DBQuery.shellBatchSize 属性来修改默认的 20 篇文档数。 示例代码: 1DBQuery.shellBatchSize = 10; 改为10。 MongoShell - 脚本我们可以在操作MongoDB中的数据或执行管理操作的JavaScript中为mongo shell编写脚本。 打开新链接：在MongoShell或者 JavaScript文件中，可以使用 Mongo() 构造函数来实例化数据库连接： 123new Mongo()new Mongo(&lt;host&gt;)new Mongo(&lt;host:port&gt;) 考虑下面的示例，实例化一个到本机默认端口上运行的MongoDB实例的新连接，并且使用 getDB()方法将全局的 db 变量设置为 myDatabase: 12conn = new Mongo();db = conn.getDB(&quot;mydb&quot;); 如果连接到一个需要读取控制的MongoDB实例，你可以使用 db.auth()方法进行授权。 此外，你可以使用 connect() 方法连接到MongoDB实例。下面的示例 连接到运行在 localhost 非默认端口 27020 上的MongoDB实例，并且设置了全局的 db 变量： 1db = connect(&quot;localhost:27020/mydb&quot;); 交互式 shell 和mongo 脚本的区别: 要使用db全局变量，请使用getDB()方法或connect()方法。可以将数据库引用分配给非db以外的变量。 默认情况下，在mongo shell中的写入操作使用写入的{w：1}。如果执行批量操作，请使用Bulk()方法。 不能在JavaScript文件中使用任何shell 指令，因为它们不是有效的JavaScript,下文附对照表。 交互模式下，mongo打印包含所有游标内容的操作结果。在脚本中，可以使用JavaScript的 print()函数或返回格式化的JSON的mongo specific printjson()函数。 下表将最常见的mongo shell助手映射到JavaScript等效项: Shell 指令 JavaScript 操作方式 show dbs , show databases db.adminCommand(‘listDatabases’) use db = db.getSiblingDB(‘‘) show collections db.getCollectionNames() show users db.getUsers() show roles db.getRoles({showBuiltinRoles: true}) show log db.adminCommand({ ‘getLog’ : ‘‘ }) show logs db.adminCommand({ ‘getLog’ : ‘*’ }) it cursor = db.collection.find()if ( cursor.hasNext() ){ cursor.next();} –evel选项：使用–eval选项来将mongo传递给一个JavaScript代码片段。 123456➜ ~ mongo mydb --eval "printjson(db.getCollectionNames())" MongoDB shell version v3.4.3connecting to: mongodb://127.0.0.1:27017/mydbMongoDB server version: 3.4.3[ "emp", "stores" ] 执行 JavaScript 文件：MongoShell 可以 指定一个 .js 文件， mongo 将会直接运行JavaScript。 1mongo localhost:27017/test myjsfile.js 该操作在连接到localhost 接口 27017 端口 mongod 实例上 test database 的:program:mongo shell 中执行 myjsfile.js 脚本。 可以在MongoShell中使用 load() 函数运行 .js文件，如下所示： 1load(&quot;demo.js&quot;) 该函数导入并运行了 demo.js 文件。 load() 方法可接受相对路径和绝对路径。如果 mongo shell 当前的工作目录位于 /data/db， 而文件demo.js 位于 /data/db/scripts 目录，那么下面两种在 mongo 中的调用将会是同样的效果。 12load(&quot;scripts/myjstest.js&quot;)load(&quot;/data/db/scripts/demo.js&quot;) MongoShell - 数据类型MongoDB BSON提供了除 JSON之外其它数据类型的支持。 Drivers提供了对这些数据类型在主机语言的本地化支持，MongoShell 也提供了一些帮助类来支持这些数据类型在 mongo JavaScript shell 中的使用。 检查类型：如果想要确定字段类型，MongoShell提供了 instanceof 和 typeof 操作符。 instanceof:instanceof 返回一个布尔值来验证一个值是否为某些类型的实例。 typeof:typeof 返回一个字段的类型。 数据类型:日期类型:MongoShell 提供了多种方法返回日期，要么通过字符串要么通过 Date 对象。 Date() 方法返回当前日期为一个字符串。 new Date() 构造函数返回一个使用 ISODate() 包装返回的 Date 对象。 ISODate() 构造函数返回一个使用 ISODate() 包装返回的 Date 对象。 内部来看， ref:document-bson-type-date 对象被存储为一个表示距离 Unix 纪元（1970年1月1日）毫秒数的64位整数，这就意味着一个可表示的日期范围：从距离过去到将来的29亿年。 返回string:如果想要返回日期为一个字符串，使用 Date() 方法。 示例代码: 123451&gt; var mydate = Date(); # 创建日期类型的变量2&gt; mydate # 查看变量的值Mon Oct 23 2017 14:30:47 GMT+0800 (CST)3&gt; typeof(mydate) # 获取查看变量的类型string 返回Date:MongoShell使用ISODate帮助程序包装Date类型的对象。但是，对象仍然是Date类型。 123456789101&gt; var myDate = new Date();2&gt; var myISODate = new ISODate();3&gt; myDateISODate("2017-10-23T06:59:56.039Z")4&gt; myISODateISODate("2017-10-23T07:00:09.831Z")5&gt; myDate instanceof Date # 验证类型true6&gt; myISODate instanceof Date # 验证类型true ObjectId:MongoShell围绕ObjectId数据类型提供ObjectId()包装器类。 示例代码: 121&gt; new ObjectId(); # 生成一个 ObjectIdObjectId("59ed998b6d3acf0e7aac525c") NumberLong:默认情况下，MongoShell将所有数字视为浮点值(floating-point values)。MongoShell提供NumberLong()包装器来处理64位整数。 示例代码： 12311&gt; NumberLong("2090845886852") # NumberLong()包装器接受long作为字符串：NumberLong("2090845886852") NumberInt:NumberInt() 构造函数来显式指定 32位整数。 NumberDecimal:NumberDecimal()构造函数限制指定 128位 基于十进制的浮点值，能够以精确的精度仿效十进制近似值。 这个功能专为处理 monetary data 的应用而设计，例如金融、税务以及科学计算等。 MongoShell - 其他命令历史命令:可以使用向上和向下箭头键检索MongoShell中发出的以前的命令。命令历史存储在~/.dbshell文件中。 示例代码: 1cat ~/.dbshell 常用命令: 命令 说明 help 查看帮助 db.help() 查看数据库的操作帮助 db..help() 显示集合的操作文档(集合可以是不存在的) show dbs 显示当前服务器上所有数据库的列表 use 切换数据库到 &lt;db&gt;(数据库可以是不存在的) show collections 显示当前数据库的所有集合的列表 show users 显示当前数据库的用户列表 show roles 显示用于当前数据库的用户定义和内置的所有角色的列表。 show profile 显示最近的五个操作命令 show databases 显示所有可用数据库列表。 load() 加载执行JavaScript脚本文件 命令行启动选项:MongoShell 启动时可以使用一些选项。 选项 说明 –help 显示命令行选项 –nodb 启动MongoShell而不连接到数据库 –shell 与 js 文件一起使用 参考资料:MongoDB 中文社区: http://www.mongoing.com/docs/mongo.html MongoDB 官网文档: https://docs.mongodb.com/manual/mongo/ MongoShell引用方法: https://docs.mongodb.com/manual/reference/method/]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『NoSQL - MongoDB』Introduction & QuickStart]]></title>
    <url>%2F2017%2F10%2F17%2Fmongodb-quickstart%2F</url>
    <content type="text"><![CDATA[前言本文从MongoDB 的简介、特点、优点、趋势、等几个方面来介绍了MongoDB。 MongoDB - 简介MongoDB（来自于英文单词“Humongous”）是可以应用于各种规模的企业、各个行业以及各类应用程序的开源数据库。MongoDB是专为可扩展性，高性能和高可用性而设计的数据库。它可以从单服务器部署扩展到大型、复杂的多数据中心架构。利用内存计算的优势，MongoDB能够提供高性能的数据读写操作。 MongoDB的本地复制和自动故障转移功能使您的应用程序具有很高可靠性和操作灵活性。 MongoDB - 概念在mongodb中基本的概念是文档、集合、数据库。 SQL术语/概念 MongoDB术语/概念 解释/说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table joins 表连接,MongoDB不支持 primary key primary key 主键,MongoDB自动将_id字段设置为主键 MongoDB - 特点临时(Ad hoc)查询:MongoDB支持字段，范围查询，正则表达式搜索。查询可以返回特定的文档字段，并且还包括用户定义的JavaScript函数。查询也可以配置为返回给定大小的结果的随机抽样。 索引:MongoDB文档中的字段可以使用主索引和辅助索引进行索引。 复制:MongoDB提供高可用性与副本集。副本集由两个或多个数据副本组成。每个副本集成员可以在任何时候以主副本的角色起作用。默认情况下，所有写入和读取都在主副本上完成。辅助副本使用内置复制维护主数据的副本。当主副本失败时，副本集会自动进行选举过程，以确定哪个辅助应该成为主要副本。辅助功能可以选择性地提供读取操作，但是数据默认情况下才最终保持一致。 负载均衡:MongoDB使用分片水平缩放。用户选择一个分片键，它确定集合中的数据将如何分发。数据被分割为范围（基于分片键）并分布在多个分片上。（碎片是一个或多个奴隶的主人）。或者，碎片密钥可以被散列以映射到分片 - 实现均匀的数据分发。 MongoDB可以在多台服务器上运行，平衡负载或复制数据，以防止硬件故障时系统启动并运行。 文件存储:MongoDB可以用作具有负载平衡和数据复制功能的文件系统，通过多台机器存储文件。 此功能被称为网格文件系统，包含在MongoDB的驱动程序。MongoDB向开发人员公开了文件操作和内容的功能。GridFS用于Nginx 和lighttpd的插件。GridFS将文件划分为部分或块，并将这些块中的每一个作为单独的文档存储。 聚合:MapReduce可用于批量处理数据和聚合操作。 聚合框架使用户能够获得使用SQL。聚合框架包括可以从多个文档加入文档的$ lookup运算符，以及诸如标准偏差的统计运算符。 服务器端JavaScript执行:JavaScript可用于查询，聚合功能（如MapReduce），并直接发送到要执行的数据库。 覆盖的集合:MongoDB支持固定大小的集合，称为封顶集合。这种类型的集合维护插入顺序，一旦达到指定的大小，就像一个循环队列。 MongoDB - 优点MongoDB优于RDBMS: 模式少 MongoDB是一个文档数据库，其中一个集合持有不同的文档。文档的数量，内容和大小可能因文档而异。 单个对象的结构是清楚的。 没有复杂的连接。 深度查询能力。MongoDB支持使用几乎与SQL一样强大的基于文档的查询语言对文档进行动态查询。 MongoDB易于扩展。 将应用程序对象转换/映射到不需要的数据库对象。 使用内部存储器存储（加窗）工作集，实现数据更快的访问。 为什么要使用MongoDB？ 面向文档的存储 数据以JSON样式文档的形式存储。 任何属性的索引 复制和高可用性 自动分片 丰富的查询 快速就地更新 MongoDB的专业支持 MongoDB的应用场景？ 大数据 内容管理和交付 移动和社会基础设施 用户数据管理 数据中心 MongoDB - 趋势搜索指数：百度指数：http://index.baidu.com/?tpl=trend&amp;word=mongodb 谷歌趋势：https://trends.google.com/trends/explore?date=today%205-y&amp;q=MongoDB 分别对比了五年内的搜索结果，整体呈上升趋势，近一年内趋于平缓。 流行程度：数据来源于 DB-Engines，DB-Engines是一个收集和呈现数据库管理系统（DBMS）的网站。 DB-Engines目前市场上数据库的人气排名列表，列表每月更新一次。 MongoDB 综合排名第四位，文档类数据库排名第一位。 DB-Engines：https://db-engines.com/en/ranking DB-Engines的排名主要根据5个因素来进行：Google以及Bing搜索引擎的关键字搜索数量、Google Trends的搜索数量、Indeed网站中的职位搜索量、LinkedIn中提到关键字的个人资料数以及Stackoverflow上相关的问题和关注者数量。 MongoDB - 安装安装:MongoDB 官网提分别供了基于 Linux、OS X、Windows 系统上的安装教程。 在 OS X系统中，官方建议使用 Homebrew 来安装，步骤如下： 更新 HomeBrew： 1brew update 安装 MongoDB： 1brew install mongodb 其他安装操作： 安装具有TLS / SSL支持的MongoDB二进制文件: 1brew install mongodb --with-openssl 安装用于测试和开发的最新版本： 1brew install mongodb --devel 参考资料：http://www.mongoing.com/docs/installation.html 配置：安装完成 MoongoDB 之后，需要在当前用户的根目录下为 MongoDB 数据库添加环境变量，由于采用了 HomeBrew来安装的 MongoDB，对 Homebrew 不熟悉的人可能不清楚安装在哪里了，这时可以使用 brew info 来查看。 示例代码: (省略部分内容) 123456789101112131415# 查看 MongoDB 的安装信息➜ ~ brew info mongodbmongodb: stable 3.4.9 (bottled), devel 3.5.11==&gt; Dependencies ……==&gt; Requirements ……==&gt; Options ……--with-boost ……--with-sasl ……--without-openssl ……--devel ……==&gt; CaveatsTo have launchd start mongodb now and restart at login: brew services start mongodbOr, if you don't want/need a background service you can just run: mongod --config /usr/local/etc/mongod.conf 123456# 配置MongoDB环境变量➜ ~ vim .bash_profileexport PATH=/usr/local/Cellar/mongodb/3.4.3/bin:$&#123;PATH&#125;➜ ~ source .bash_profile MongoDB的默认数据目录为/data/db，如需要修改，可以在 MongoDB 的配置文件中修改dbPath选项。 路径如下： 1➜ ~ cat /usr/local/etc/mongod.conf MongoDB - 启动安装配置完成之后，打开 terminal，输入mongod,直至出现I NETWORK [thread1] waiting for connections on port 27017字样则算启动成功，然后再打开另一终端窗口，输入 mongo，则可以直接进入 MongoShell 界面。 学习资料 MongoDB University： MongoDB 官方课程:https://university.mongodb.com/courses/catalog Github: MongoDB 代码托管:https://github.com/mongodb/mongo TutorialsPoint: MongoDB 教程文档:http://www.tutorialspoint.com/mongodb/ 云栖社区(AliYun): 阿里云云栖社区MonbgoDB 资料汇总:http://t.cn/RO3HQgI MongoDB YouTube:MongoDB在Youtube 订阅频道:https://www.youtube.com/user/MongoDB MongoDB Tutorial for Beginners： MongoDB 初学者教程: MongoDB Tutorial for Beginners(UP主:The Net Ninja) 参考资料DB-Engines: https://db-engines.com MongoDB Manual: https://docs.mongodb.com/manual/]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用 Now.sh来免费部署你的项目？]]></title>
    <url>%2F2017%2F09%2F10%2Fnowsh-note%2F</url>
    <content type="text"><![CDATA[前言 ZEIT：Our Mission，Make Cloud Computing as Easy and Accessible as Mobile computing. ZEIT是美国 (域名Ip指向美国华盛顿州西雅图市)一家提供云部署服务的公司，旗下的 Now.sh提供了Realtime global deployments(全球化实时部署)服务。 Now.sh 提供了免费的OSS 服务，配置如下： 名称 配置 带宽 1GB* 日志 100MB* 部署 ∞ 并发实例 3 域 - † MAX文件大小/存储空间 1MB / 1GB 自动增长支持 不支持 团队协作人数 支持 图例： *超出此限额时，您需支付“按需”的价格。服务不中断，不会造成停机。 †对于某些开源项目，我们赞助了自定义域的支持。请联系我们，以确定您是否适用。 ‡在免费计划中，您的代码将是公开的和开源的，可通过所有部署的路径URL提供。/_src Reference：https://zeit.co/pricing Now.sh - 简介：now allows you to take your JavaScript (Node.js) or Docker powered websites, applications and services to the cloud with ease, speed and reliability. In practical terms, any directory that contains a package.json or Dockerfile can be transported to the cloud with one command: now. Every time you deploy a project, now will provide you with a new, unique URL (even before the upload has finished). These URLs will look like this (my-app is your automatically determined application name): my-app-erkgfjtrna.now.sh. When it’s time to take your deployment to production, you simply pick an appropriate alias (a custom domain). Reference：https://zeit.co/now#whats-now Now.sh - 安装：基于客户端进行安装：客户端下载地址：https://zeit.co/download 安装过程就不一一赘述了，因为我也没安装过。我觉得使用homebrew或npm之类的工具安装使用会更方便一些。 基于 npm 进行安装：示例代码： 123456789101112➜ npm install -g now/usr/local/bin/now -&gt; /usr/local/lib/node_modules/now/download/dist/now&gt; now@8.2.2 postinstall /usr/local/lib/node_modules/now&gt; node download/install.js&gt; For the source code, check out: https://github.com/zeit/now-cli&gt; Downloading now CLI 8.2.2 [====================] 100%+ now@8.2.2added 1 package in 15.18s 如果你还不会使用 npm (Node Package Manager)，请翻阅之前发布的 npm使用教程。 Reference:https://www.npmjs.com/package/now Now.sh - CLI:以下是所有可用命令的完整列表，以及您可以使用的命令和您每天工作时应记住的命令： Syntax Description now deploy [path] 使用此命令时，当前目录中的文件将被上传到now.sh，并将创建一个新的部署。之后，您将立即收到其网址，以便与全球其他人分享。 now ls\list [app] 显示所有部署的列表。如果被定义，它将仅列出该命名空间下的部署。 now rm\remove [id] 从now.sh平台中删除部署。该参数可以是您之前的部署的URL或主机名。 now ln\alias [id] [url] 在现有部署上配置别名或自定义域名。 now domains [name] 允许您直接从命令行管理域名。 now certs [cmd] 默认情况下，now.sh将自动为您的部署配置证书。使用此子命令，您可以看到他们何时到期。 now secrets [name] 如果您需要将敏感信息存储在只能由其中运行的代码访问的部署上。这可以通过使用它来实现，它允许您以安全的方式存储应用程序所需的功能（如API令牌或密码） now dns [name] 列出使用zeit.world为域创建的所有DNS记录。该列表不包括由名称服务器自动生成的记录（如默认记录，为记录自动创建的记录等）。SOA``A / AAAA``ALIAS now open 运行此子命令将在默认浏览器的当前目录中打开项目的最新部署（别名此时无效） now billing\cc 轻松添加或删除帐户中的信用卡，并调整结算方式。 now upgrade\downgrade [plan] 从命令行界面切换您的计划。即使命令运行后，我们也不要求您使用Web界面。整个过程直接发生在你的终端上。 now help 显示终端中的子命令和选项列表 now login 登录你的 ZEIT账户 Reference：https://zeit.co/docs/features/now-cli Now.sh - 使用：要使用 Now.sh就必须要再 https://zeit.co 注册一个账户，只需要输入你的邮箱就好了，然后在本地进行认证，认证过程中需要输入你注册时所用的邮箱，然后打开邮箱点击链接进行认证。 示例代码： 123456➜ ~ now login&gt; We sent an email to youremail@gmail.com. Please follow the steps provided inside it and make sure the security code matches Silly Water Buffalo.✔ Email confirmed✔ Fetched your personal details&gt; Ready! Authentication token and personal details saved in "~/.now" 邮件内容： 12345678Hi!Login attempt from Shenzhen, ChinaVerify that the provided security code matches Confident African Civetbefore proceeding. Then please follow this link to verify your email address. Now.sh - 部署： Now.sh is free for open-source projects and static deployments. It supports Dockerfile, package.json and static sites out of the box. All builds are reproducible and executed in the cloud. 译：Now.sh对于开源项目和静态部署是免费的。它支持Dockerfile，package.json和静态网站开箱即用。所有的构建都是可重现的，并在云中执行。 现在你可以使用now命令来部署任何 web应用程序，现在 Now.sh 支持三种类型的部署： Static - 静态网页应用 Node.js - Node.js 应用 Docker - Docker应用(适用于所有其他应用) Static 部署：通过静态部署，可以将本地资源部署到 Now.sh 上，需要部署请访问应用程序目录并运行此命令： 1➜ yourproject/ now 如果你的静态 web 项目中包含index.html文件，则项目可正常显示，否则只会显示文件和文件夹(用来做 ftp 服务器也不错)。 For all static deployments, you will be charged only for the bandwidth. You do not pay for computing resources and storage. 对于所有静态部署，您将仅为带宽收费。您不支付计算资源和存储空间。 Node.js 部署:如果您的应用程序目录中有一个package.json文件，那么Now.sh会认为有效的Node.js部署。这是一个简单的Node.js部署在微服务的帮助下。 Node.js 应用必须要用以下两个文件才能被 Now.sh 识别。 index.js示例代码： 123module.exports = () =&gt; (&#123; date: new Date&#125;) package.json示例代码： 12345678910&#123; "name": "get-started-node", "version": "0.1.0", "dependencies": &#123; "micro": "latest" &#125;, "scripts": &#123; "start": "micro" &#125;&#125; 然后要部署此应用程序，请访问应用程序根目录并运行此命令： 1➜ yourproject/ now Docker 部署：如果您的应用程序目录包含一个Docker文件，那么现在考虑一个有效的Docker部署。它将基于Dockerfile构建一个docker映像，并基于此启动容器。 要部署一个简单的Go HTTP服务器，创建一个目录并添加这两个文件： hello.go示例代码： 1234567891011121314151617package mainimport ( "io" "net/http")func main() &#123; http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) &#123; io.WriteString(w, "Hello world!") &#125;) err := http.ListenAndServe(":8000", nil) if err != nil &#123; panic(err) &#125;&#125; Dockerfile示例代码： 12345FROM golang:alpineADD . /go/src/zeit/helloRUN go install zeit/helloCMD ["/go/bin/hello"]EXPOSE 8000 部署总结：项目在部署完成之后，我们会得到一个链接，可以通过这个链接来访问部署的项目。 123456789101112➜ Index now&gt; Deploying ~/WorkDir/Index under usrename&gt; Warning! Skipping file /Users/Uname/WorkDir/Index/img/background.jpg (size exceeded 1MB)&gt; Warning! 1 of the files exceeded the limit for your plan.&gt; Please run `now upgrade` to upgrade.&gt; Ready! https://index-xxxxxxxxx.now.sh (copied to clipboard) [2s]&gt; You (Username) are on the OSS plan. Your code and logs will be made public.&gt; NOTE: You can use `now --public` to skip this prompt&gt; Synced 3 files (877.42KB) [41s]&gt; Initializing…&gt; Deployment complete! 每次更新部署后， url 都会生成一个新的，但是老的 url 都还是可以用的。如果最终网站要产品化，可以很容易的绑定自己的域名。 Reference： https://zeit.co/docs/getting-started/deployment Now.sh - 域名：当我们部署完应用程序的时，Now.sh 会为我们生成一个唯一部署URL，如果我们修改项目后进行多次部署，Now.sh 会生成多个 URL 为我们的项目，使用这些特定的 URL 可以访问不同版本的应用，但是这些URL 不容易记住，每次部署新版本都会更新地址，因此我们需要一个固定的域名。我们将使用now alias命令将域名映射到应用的其中一个部署URL。 需要说明的是，自定义域仅适用于付费计划。如果您要为自己的应用使用自定义域，则需要升级您的帐户。具体价格请参考：https://zeit.co/pricing 使用now alias命令的四种不同的方法是： 使用now.sh提供的域名 使用now.sh管理的自定义域名 使用自定义域，由now管理的DNS 使用带有CNAME的自定义域名 使用now.sh提供的域名这种方法是使用域名的最简单方法。要立即使用now.sh 后缀获取域名，只需运行以下命令即可，示例代码 ： 1$ now alias https://my-web-app-avvuiuuwto.now.sh my-web-app 现在可以使用https://my-web-app.now.sh来访问部署的项目。 ###使用now.sh管理的自定义域 如果您想为自己的应用使用自定义域，最简单的方法是使用now为您的应用购买域名。 只需运行以下alias命令，示例代码： 1$ now alias https://my-web-app-avvuiuuwto.now.sh my-web-app.com 在这里，我们正在尝试将my-web-app.com域名分配给上述部署URL。如果域名可用，您可以在不离开终端的情况下确认并购买。 确认后，现在将处理您的所有技术细节，并允许您的用户使用https://my-web-app.com访问您的应用程序。 在这个过程中，now.sh将为我们的域名设置一个域加密SSL证书。 使用自定义域，由Now管理的DNS如果您已经有域名，这是您最好的选择。使用此方法，现在将处理您的域名的所有DNS管理。 首先，您需要将域名的域名服务器指向我们的全球DNS服务。这是怎么做到的: 访问您的域名提供商，并找到可以添加自定义nameserver的地方。 从此列表中选择两个或多个nameservers。 将now.sh 提供的nameserver设置为您的自定义域名的nameserver。 这里呢需要将我们购买的域名的解析权交给 now 来做，本网站域名再 godaddy购买，然后将其解析权交给 Dnspod ，使用管理起来更方便，跟 now.sh 原理一致。 例如，假设您的域名是my-custom-domain.com,设置name后，只需运行以下alias命令： 1$ now alias https://my-web-app-avvuiuuwto.now.sh my-custom-domain.com 然后，您可以使用https://my-custom-domain.com访问您的应用程序。 您也可以使用my-custom-domain.com的子域，如下所示： 1$ now alias https://my-web-app-avvuiuuwto.now.sh ui.my-custom-domain.com 在这个过程中，now.sh将为我们的域名设置一个域加密SSL证书。 Reference：Godaddy注册的域名如何使用DNSPod？ Reference：now.sh 提供的 Nameservers 使用带有CNAME的自定义域名如果您正在管理您的域名的DNS设置，您可以使用此选项。 例如，假设您有一个名为my-app.work的域名，并且您已经有一个DNS设置。要映射应用程序的一个部署URL的 ui.my-app.work 域名，请访问您的DNS提供程序，并为ui.my-app.work添加指向alias.zeit.co的CNAME记录。之后，运行以下命令： 1$ now alias https://my-web-app-avvuiuuwto.now.sh ui.my-app.work 现在您可以使用https://ui.my-app.work访问您的应用程序。 Reference：https://zeit.co/docs/getting-started/assign-a-domain-name Now.sh - 日志：日志很重要，因为它可以让您看到应用程序中发生的情况，尤其是在发生异常时。now可以保存所有部署的日志，并允许您搜索它们，让我们来看看如何访问日志： 通过CLI：通过现在的CLI访问日志很简单，调用这个命令： 1$ now logs [deployment-url] 您还可以使用应用的域名来搜索日志： 1$ now logs my-web-app.com 有关now日志的更多信息，请运行help命令： 1$ now logs --help 这是一个预先查看 now的日志命令，让您检查最后10个HTTP GET请求: 1$ now logs -a -q "GET" -n 10 my-web-app.com 通过Dashboard：您还可以通过您的Web信息板访问和搜索日志，网址为https://zeit.co/dashboard。 单击信息中心内的任何部署URL，然后开始搜索日志。 Reference：https://zeit.co/docs/getting-started/logs Now.sh - 注意事项：使用 Now.sh来部署应用的优势： 自带的 https 真正的一键部署，不用自己管理服务器，将 severless 进行到底 不翻墙，访问速度很棒 其他注意事项： 为了节省资源，应用一段时间不用就会被 frozen （冻结），但是只要我们去敲链接去访问，就会自动 unfrozen ，只不过初次访问速度会受影响。 在 Now.sh提供的免费服务中，您的代码将是公开的和开源的，如果介意可升级账户或放弃使用。 参考资料： ZEIT-官网 ZEIT-Github ZEIT-Twitter Github Now-CLI NpmJS Now Asynchronous HTTP microservices]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Now.sh</tag>
        <tag>Deployments</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『构建工具-Gradle』相关内容整理]]></title>
    <url>%2F2017%2F09%2F02%2Fgradle-node%2F</url>
    <content type="text"><![CDATA[Gradle - 简介：Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。 当前其支持的语言限于Java、Groovy和Scala，计划未来将支持更多的语言。Gradle，这是一个构建系统(工具)，我们认为这是Java（JVM）世界中构建技术的巨大飞跃。 Gradle提供了： 一个非常灵活的通用构建工具，如Ant。 一种可切换的，像 maven 一样的基于约定约定优于配置的构建框架 强大的多工程构建支持 强大的依赖管理(基于 ApacheIvy) 对已有的 maven 和 ivy 仓库的全面支持 支持传递性依赖管理，而不需要远程仓库或者 pom.xml 或者 ivy 配置文件 ant 式的任务和构建是 gradle 的第一公民 基于 groovy，其 build 脚本使用 groovy dsl 编写 具有广泛的领域模型支持你的构建 Reference：https://docs.gradle.org/4.1/userguide/introduction.html Gradle - 概述：基于声明的构建和基于约定的构建Gradle的核心是基于Groovy的丰富的可扩展的域特定语言（DSL）。Gradle通过提供可以根据需要进行组合的声明性语言元素将声明式构建推送到一个新的层次。这些元素还为Java，Groovy，OSGi，Web和Scala项目提供了逐个常规的支持。更重要的是，这种声明性语言是可扩展的。添加您自己的新语言元素或增强现有的元素，从而提供简洁，可维护和易于理解的构建。 为以依赖为基础的编程方式提供语言支持声明性语言优点在于通用任务图，你可以将其充分利用在构建中. 它提供了最大限度的灵活性，以让 Gradle 适应你的特殊需求。 构建结构化Gradle 的灵活和丰富性最终能够支持在你的构建中应用通用的设计模式。 例如，它可以很容易地将你的构建拆分为多个可重用的模块，最后再进行组装，但不要强制地进行模块的拆分。 不要把原本在一起的东西强行分开（比如在你的项目结构里），从而避免让你的构建变成一场噩梦。 最后，你可以创建一个结构良好，易于维护，易于理解的构建。 深度 APIGradle 允许你在构建执行的整个生命周期，对它的核心配置及执行行为进行监视并自定义。 Gradle 的扩展Gradle 有非常良好的扩展性。 从简单的单项目构建，到庞大的多项目构建，它都能显著地提升你的效率。 这才是真正的结构化构建。通过最先进的增量构建功能，它可以解决许多大型企业所面临的性能瓶颈问题。 多项目构建Gradle 对多项目构建的支持非常出色。项目依赖是首先需要考虑的问题。 我们允许你在多项目构建当中对项目依赖关系进行建模，因为它们才是你真正的问题域。 Gradle 遵守你的布局。 Gradle 提供了局部构建的功能。 如果你在构建一个单独的子项目，Gradle 也会帮你构建它所依赖的所有子项目。 你也可以选择重新构建依赖于特定子项目的子项目。 这种增量构建将使得在大型构建任务中省下大量时间。 多种方式管理依赖不同的团队喜欢用不同的方式来管理他们的外部依赖。 从 Maven 和 Ivy 的远程仓库的传递依赖管理，到本地文件系统的 jar 包或目录，Gradle 对所有的管理策略都提供了方便的支持。 Gradle 是第一个构建集成工具Ant tasks 是最重要的。而更有趣的是，Ant projects 也是最重要的。 Gradle 对任意的 Ant 项目提供了深度导入，并在运行时将 Ant 目标(target)转换为原生的 Gradle 任务(task)。 你可以从 Gradle 上依赖它们(Ant targets)，增强它们，甚至在你的 build.xml 上定义对 Gradle tasks 的依赖。Gradle 为属性、路径等等提供了同样的整合。 Gradle 完全支持用于发布或检索依赖的 Maven 或 Ivy 仓库。 Gradle 同样提供了一个转换器，用于将一个 Maven pom.xml 文件转换为一个 Gradle 脚本。Maven 项目的运行时导入的功能将很快会有。 易于移植Gradle 能适应你已有的任何结构。因此，你总可以在你构建项目的同一个分支当中开发你的 Gradle 构建脚本，并且它们能够并行进行。 我们通常建议编写测试，以保证生成的文件是一样的。 这种移植方式会尽可能的可靠和减少破坏性。这也是重构的最佳做法。 GroovyGradle 的构建脚本是采用 Groovy 写的，而不是用 XML。 但与其他方法不同，它并不只是展示了由一种动态语言编写的原始脚本的强大。 那样将导致维护构建变得很困难。 Gradle 的整体设计是面向被作为一门语言，而不是一个僵化的框架。 并且 Groovy 是我们允许你通过抽象的 Gradle 描述你个人的 story 的黏合剂。 Gradle 提供了一些标准通用的 story。这是我们相比其他声明性构建系统的主要特点。 我们的 Groovy 支持也不是简单的糖衣层，整个 Gradle 的 API 都是完全 groovy 化的。只有通过 Groovy才能去运用它并对它提高效率。 The Gradle wrapperGradle Wrapper 允许你在没有安装 Gradle 的机器上执行 Gradle 构建。 这一点是非常有用的。比如，对一些持续集成服务来说。 它对一个开源项目保持低门槛构建也是非常有用的。 Wrapper 对企业来说也很有用，它使得对客户端计算机零配置。 它强制使用指定的版本，以减少兼容支持问题。 自由和开源Gradle 是一个开源项目，并遵循 ASL 许可。 Reference：https://docs.gradle.org/4.1/userguide/overview.html Gradle - 安装：关于 Gradle 的安装官网上为我们提供了非常详细的过程，如果你使用的是 MacOS，那么建议使用 Homebrew 进行安装，简单快捷。 1234567891011121314➜ ~ brew install gradle # 安装Gradle➜ ~ gradle -v # 查看版本信息------------------------------------------------------------Gradle 4.1------------------------------------------------------------Build time: 2017-08-07 14:38:48 UTCRevision: 941559e020f6c357ebb08d5c67acdb858a3defc2Groovy: 2.4.11Ant: Apache Ant(TM) version 1.9.6 compiled on June 29 2015JVM: 1.8.0_121 (Oracle Corporation 25.121-b13)OS: Mac OS X 10.12.6 x86_64 配置Gradle的环境变量： 1GRADLE_HOME=/usr/local/gradle Reference：https://docs.gradle.org/4.1/userguide/installation.html Gradle - 构建基础：Projects &amp; tasks:projects 和 tasks是 Gradle 中最重要的两个概念。 任何一个 Gradle 构建都是由一个或多个 projects 组成。每个 project 包括许多可构建组成部分。 这完全取决于你要构建些什么。举个例子，每个 project 或许是一个 jar 包或者一个 web 应用，它也可以是一个由许多其他项目中产生的 jar 构成的 zip 压缩包。一个 project 不必描述它只能进行构建操作。它也可以部署你的应用或搭建你的环境。不要担心它像听上去的那样庞大。 Gradle 的 build-by-convention 可以让您来具体定义一个 project 到底该做什么。 每个 project 都由多个 tasks 组成。每个 task 都代表了构建执行过程中的一个原子性操作。如编译，打包，生成 javadoc，发布到某个仓库等操作。 build.gradle文件：示例代码： 12345task hello &#123; doLast &#123; println 'Hello world!' &#125;&#125; 在命令行里, 进入脚本所在的文件夹然后输入 gradle -q hello 来执行构建脚本，示例代码： 1gradle -q hello Hello world! 这里发生了什么? 这个构建脚本定义了一个独立的 task, 叫做 hello, 并且加入了一个 action. 当你运行 gradle hello, Gradle 执行叫做 hello 的 task, 也就是执行了你所提供的 action. 这个 action 是一个包含了一些 Groovy 代码的闭包(closure 这个概念不清楚的同学好好谷歌下). 如果你认为这些看上去和 Ant 的 targets 很相像, 好吧, 你是对的. Gradle tasks 和 Ant 的 targets 是对等的. 但是你将会会看到, Gradle tasks 更加强大. 我们使用一个不同于 Ant 的术语 task, 看上去比 target 更加能直白. 不幸的是这带来了一个术语冲突, 因为 Ant 称它的命令, 比如 javac 或者 copy, 叫 tasks. 所以当我们谈论 tasks, 是指 Gradle 的 tasks. 如果我们讨论 Ant 的 tasks (Ant 命令), 我们会直接称呼 ant task. -q. 代表 quite 模式. 它不会生成 Gradle 的日志信息 (log messages), 所以用户只能看到 tasks 的输出. 它使得的输出更加清晰. 你并不一定需要加入这个选项. Gradle - 构建项目：创建项目目录：示例代码： 12➜ ~ mkdir gradle-app➜ ~ cd gradle-app 使用 Gradle Wrapper构建：示例代码： 1234➜ gradle-app gradle wrapperBUILD SUCCESSFUL in 0s1 actionable task: 1 executed 以下是 Gradle Wrapper 生成的文件。 示例代码： 12345678910➜ gradle-app tree.├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew└── gradlew.bat2 directories, 4 files gradlew : 这是一个可执行文件，应用于运行gradle构建任务 gradlew.bat : 同上，运行再 windows/doc 平台。 gradle/wrapper/gradle-wrapper.properties ：gradle包装器配置文件 gradle-wrapper.properties：示例代码： 123456➜ gradle-app cat gradle/wrapper/gradle-wrapper.propertiesdistributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\://services.gradle.org/distributions/gradle-4.1-bin.zip 初始化你创建的项目：示例代码： 12345678910➜ gradle-app ./gradlew initDownloading https://services.gradle.org/distributions/gradle-4.1-bin.zip................................................................Unzipping /Users/UName/.gradle/wrapper/dists/gradle-4.1-bin/c3kp51zwwt108wc78u68yt7vs/gradle-4.1-bin.zip to /Users/UName/.gradle/wrapper/dists/gradle-4.1-bin/c3kp51zwwt108wc78u68yt7vsSet executable permissions for: /Users/UName/.gradle/wrapper/dists/gradle-4.1-bin/c3kp51zwwt108wc78u68yt7vs/gradle-4.1/bin/gradleBUILD SUCCESSFUL in 18s2 actionable tasks: 1 executed, 1 up-to-date 现在可以再次查看下项目： 123456789101112➜ gradle-app tree.├── build.gradle├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew├── gradlew.bat└── settings.gradle2 directories, 6 files 相较于之前，则多了build.gradle和settings.gradle两个文件。 build.gradle:123456789101112131415161718192021222324252627282930/* * 此构建文件是由Gradle'init'任务生成的。 * * 这个生成的文件包含一个注释掉的示例Java项目，让你开始。 * 有关更多详细信息，请参阅Gradle中的Java Quickstart一章 * 用户指南可在https://docs.gradle.org/4.1/userguide/tutorial_java_projects.html *//*// 应用 JAVA 插件来添加项目对 JAVA 的支持apply plugin: 'java'// 此处可以声明在何处找到项目的依赖关系repositories &#123; //项目空间引用远程仓库--- jcenter(),您可以在这里声明任何Maven / Ivy /文件库。 jcenter()&#125;// 声明生产和测试代码的依赖关系dependencies &#123; // 生产代码在编译时使用SLF4J logging API compile 'org.slf4j:slf4j-api:1.7.25' // 声明您希望在测试中使用的最喜欢的测试框架的依赖关系. // Gradache测试任务也支持TestNG. 只需要testCompile 依赖于 // testCompile 'org.testng:testng:6.8.1' ，和添加 // 'test.useTestNG()' 到你的构建脚本中。 testCompile 'junit:junit:4.12'&#125;*/ settings.gradle:123456789101112131415161718➜ gradle-app cat settings.gradle/* * 此设置文件是由Gradle'init'任务生成的。 * * 设置文件用于指定要在构建中包含哪些项目，在单个项目中构建此文件可以为空或甚至删除。 * * 在用户指南中可以找到有关在Gradle中配置多项目构建的详细信息 * https://docs.gradle.org/4.1/userguide/multi_project_builds.html *//*// 作为多项目构建的一部分 来声明项目使用'include'方法include 'shared'include 'api'include 'services:webservice'*/rootProject.name = 'gradle-app' 继续完善项目：整个项目的目录结构如下,与 Maven 工程目录结构无差别: 目录 说明 src/main/java JAVA 源码 src/main/resources 生产资源文件 src/test/java 测试源码 src/test/resources 测试资源文件 1234567891011121314151617181920212223242526➜ gradle-app tree.├── build.gradle├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradle-app.iml # 导入 IDEA 后生成的文件├── gradlew├── gradlew.bat├── settings.gradle└── src ├── main │ └── java │ └── ws │ └── object │ └── gradle │ └── App.java └── test └── java └── ws └── object └── gradle └── AppTest.java13 directories, 9 files App.java 123456789101112package ws.object.gradle;public class App&#123; public String getAppId() &#123; return "hello-world"; &#125; public static void main( String[] args ) &#123; System.out.println( "Hello World!" ); &#125;&#125; AppTest.java 123456789101112131415package ws.object.gradle;import junit.framework.TestCase;/** * Unit test for simple App. */public class AppTest extends TestCase &#123; public void testAppId() &#123; App app = new App(); assertEquals("App ID", "hello-world", app.getAppId()); &#125;&#125; 构建创建的项目：现在我们已经创建了App.java和AppTest.java，我们准备好构建项目。 这可以通过执行如下所示的构建任务来完成。示例代码： 1234➜ gradle-app ./gradlew buildBUILD SUCCESSFUL in 1s4 actionable tasks: 4 executed 让项目跑起来：使用内置的jar库运行应用程序，示例代码： 12➜ gradle-app java -cp build/libs/gradle-app.jar ws.object.gradle.AppHello World! 或者您可以使用内置的类文件夹运行，示例代码： 12➜ gradle-app java -cp build/classes/java/main/ ws.object.gradle.AppHello World! 参考资料：Gradle Official Website Gradle Wikipedia Gradle Github Building Java Projects with Gradle]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot - Actuator QuickStart]]></title>
    <url>%2F2017%2F08%2F22%2Fspringboot-actuator%2F</url>
    <content type="text"><![CDATA[Spring Boot - Actuator简介:Spring Boot Actuator模块提供了一个监控和管理生产环境的模块，可以使用http、jmx、ssh、telnet等拉管理和监控应用。审计（Auditing）、 健康（health）、数据采集（metrics gathering）会自动加入到应用里面。 Spring Boot - Actuator的特点:Spring Boot Actuator的关键特性是在应用程序里提供了众多的Web站点，通过他们可以来了解应用程序运行时的内部状况。Actuator为Spring Boot项目带来了许多有用的特性，包括： 管理端点 合理的异常处理以及默认的”/error”映射端点 获取应用信息的”/info”端点 当启用Spring Security时，会有一个审计事件框架 SpringBoot - Actuator 的端点：Spring Boot Actuator提供了13个 端点，有了它，你可以知道 Bean 在 Spring应用上下文里是如何组装在一起的，掌握应用程序可以获取的环境属性信息，获取运行时度量信息的快照…… HTTP方法 路径 描述 GET /aotoconfig 提供一份自动配置报告，记录哪些自动配置条件通过那些没通过 GET /configprops 描述配置属性(包含默认值)如何注入 Bean GET /beans 描述应用程序上下文里全部的 Bean，以及他们的关系 GET /dump 获取线程活动的快照 GET /env 获取全部环境属性 GET /env/{name} 根据名称来获取特定的环境属性值 GET /health 报告应用程序的健康指标，这些值由 HealthIndicator 的实现来提供 GET /info 获取应用程序的定制信息，这些信息由 info 开头的属性提供 GET /mappings 描述全部的 URL 路径，以及它们和控制器(包含 Actuator 端点)的映射关系 GET /metrics 报告各种应用程序度量信息，比如内存用量和 HTTP 请求次数 GET /metrics/{name} 根据名称来获取应用程序的度量信息 POST /shutdown 关闭应用程序，要求 endpoints，shutdown，enabled 设置为 True GET /trace 提供基本的 HTTP 请求跟踪信息(时间戳、HTTP 请求头等) SpringBoot - Actuator的使用：需要启动 Actuator 的端点，只需要在项目中引入Actuator的起步依赖即可。 在 Maven 中使用：示例代码： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 在 Gradle 中使用：示例代码： 1compile 'org.springframework.boot:spring-boot-starter-actuator']]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot - 配置文件详解]]></title>
    <url>%2F2017%2F08%2F15%2Fspringboot-configuration%2F</url>
    <content type="text"><![CDATA[在Spring Boot的配置文件中，有两种后缀的配置文件，分别是.properties文件和.yml文件。Spring Boot 提供了对应用进行自动化配置。相比以前 XML 的配置方式，很多显式方式申明是不需要的。大多数默认的配置足够实现开发功能，从而更快速开发。 Spring Boot - 配置文件类型:SpringBoot使用一个全局的配置文件，且配置文件名是固定的； *.properties属性文件；属于最常见的一种； *.yml是yaml格式的文件，yaml是一种非常简洁的标记语言。 .properties文件配置：示例代码： 1234blog.config.title=&quot;柒索&quot;blog.config.subtitle=&quot;一个头脑聪明，五肢发达的男人。&quot;blog.config.url=&quot;http://object.ws&quot;blog.config.number=4000 .yml文件配置：示例代码： 123456blog: config: title: 柒索 subtitle: 一个头脑聪明，五肢发达的男人。 url: http://object.ws number: $&#123;random.int&#125; 可以看出两种配置文件的写法yaml 文件的方式更简洁一些，所以推荐使用 yaml 文件来作为 Spring Boot 的配置文件。 Spring Boot - yml语法:基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 值的写法字面量：普通的值（数字，字符串，布尔） ​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi 对象、Map、K:V：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123blog: title: 柒索 age: 2 行内写法： 1info: &#123;url: object.ws,subtitle: .......&#125; 数组(List、Set):用- 值表示数组中的一个元素 1234tags: - java - go - node 行内写法 1pets: [cat,dog,pig] ##Spring Boot 配置文件注入: 注入示例代码：配置文件代码: 123456789101112blog: title: 柒索 age: 2 isdynamic: false createdate: 2016/01/01 tags: - java - go - node info: url: object.ws subtitle: 一个头脑聪明，五肢发达的男人 与之对应的JavaBean: 1234567891011121314151617181920/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "blog"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = "blog")public class Blog &#123; private String title; private Integer age; private Boolean isdynamic; private Date createdate; private Map&lt;String,Object&gt; tags; private List&lt;Object&gt; lists; private Info info; 我们可以导入配置文件处理器，以后编写配置就有提示了： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; @Value和@ConfigurationProperties对比 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 配置文件注入值数据校验123456789101112131415161718192021@Component@ConfigurationProperties(prefix = "blog")@Validatedpublic class Blog &#123; /** * &lt;bean class="Blog"&gt; * &lt;property name="title" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //title必须是邮箱格式 @Email private String title; private Integer age; private Boolean isdynamic; private Date createdate; private Map&lt;String,Object&gt; tags; private List&lt;Object&gt; lists; private Info info; Spring Boot - 配置文件占位符：在配置文件中使用随机数：Spring Boot的属性配置文件中可以通过${random}来产生int值、long值或者string字符串，来支持属性的随机值。 示例代码： 123456789blog: config: url: "http://object.ws" strval: $&#123;random.value&#125; # 产生随机字符串 number: $&#123;random.int&#125; # 产生随机Int类型数值 longnum: $&#123;random.long&#125; # 产生随机 Long类型数值 test1: $&#123;random.int[10]&#125; # 产生10以内的的随机数 test2: $&#123;random.int[10,30]&#125; # 产生10-30之间的随机数 refval: $&#123;blog.config.url&#125;and$&#123;blog.config.strval&#125; # 参数之间的互相引用 自定义配置项代码演示：Spring Boot 为我们提供了许多默认的配置项，但是在开发的过程中，总是会有一些业务需要我们自定义配置，如下代码演示如何使用自定义配置： 示例代码：application.yml 123456blog: config: title: "柒索" subtitle: "一个头脑聪明，五肢发达的男人" url: "http://object.ws" number: $&#123;random.int&#125; 示例代码：BlogController.java 123456789101112131415161718192021222324252627package ws.object.springboot.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class BlogController &#123; @Value("$&#123;blog.config.title&#125;") String Title; @Value("$&#123;blog.config.subtitle&#125;") String subTitle; @Value("$&#123;blog.config.url&#125;") String Url; @Value("$&#123;blog.config.number&#125;") int Number; @RequestMapping(value = "/blog") public String Blog()&#123; return " Title:"+Title+ " subTitle:"+subTitle+ " URL:"+Url+ " Number:"+Number; &#125;&#125; 之后在浏览器输入http://localhost:8080/blog 就能看到配置在 .yml 文件中的值已经显示在页面里了。 Spring Boot - 多环境配置：在现实的开发环境中，我们需要不同的配置环境，在不同环境下可以配置不同的参数文件，便于部署，提高效率减少出错率，常见配置格式为application-{profile}.properties，其中{profile}对应你的环境标识，比如：dev(开发环境)、test(测试环境)、vis(演示环境)、prod(生产环境)。 application-test.yml：测试环境 application-dev.yml：开发环境 application-prod.yml：生产环境 yml多文档块方式:1234567891011121314spring: profiles: active: prod #指定使用哪个环境server: port: 8081---server: port: 8083---server: port: 8084 激活指定配置:配置文件中指定：如何使用？我们只需要在application.yml文件中加上： 123spring: profiles: active: test 启动Spring Boot 应用是就会使用application-tst.yml配置文件 或者是属于application.yml中test代码块中的内容。 命令行指定：在通过命令行启动程序的时候，可以追加启动参数： 1java -jar spring-boot-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev 虚拟机参数：在IDEA中启动项目的时候在配置中加入虚拟机启动参数： 1-Dspring.profiles.active=dev Spring Boot - 文件加载位置和顺序：配置文件加载位置：springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件: file:./config/ file:./ classpath:/config/ classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； 我们还可以通过spring.config.location来改变默认的配置文件位置 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；java -jar spring-boot-config-0.0.1-SNAPSHOT.jar --spring.config.location=~/desktop/application.properties 配置文件加载顺序：把所有配置全都打在一个jar包里，显然不是最好的做法，更常见的做法是把配置文件放在jar包外面，可以在需要时，不动java代码的前提下修改配置，spring-boot会按以下顺序加载配置文件 application.properties或application.yml， 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置： 所有的配置都可以在命令行上进行指定 java -jar demo.jar --server.port=8087多配置项使用空格分开 来自java:comp/env的JNDI属性 Java系统属性（System.getProperties()） 操作系统环境变量 RandomValuePropertySource配置的random.*属性值 jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 jar包外部的application.properties或application.yml(不带spring.profile)配置文件 jar包内部的application.properties或application.yml(不带spring.profile)配置文件 @Configuration注解类上的@PropertySource 通过SpringApplication.setDefaultProperties指定的默认属性 参考官方文档-SpringBootConfig 总结： 先查找jar文件同级目录下的 ./config 子目录 有无配置文件 （外置) 再查找jar同级目录 有无配置文件（外置) 再查找config这个package下有无配置文件（内置) 最后才是查找classpath 下有无配置文件（内置) Spring Boot - 常见参数配置：Spring.io-Sring Boot常见配置属性列表 参考资料： 阮一峰-YAML 语言教程 Spring.io-Sring Boot常见配置属性列表]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot - Introduction & QuickStart]]></title>
    <url>%2F2017%2F08%2F10%2Fspringboot-quickstart%2F</url>
    <content type="text"><![CDATA[Spring Boot - 简介： Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. Spring.io Spring Boot - 核心特性： Spring Boot Starter：将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的依赖中。 自动配置：Spring Boot的自动配置特性利用了Spring 4对条件化配置的支持，合理的推测应用所需要的Bean并自动化配置它们。 命令行接口(CLI)：Spring Boot CLI 发挥了Groovy的优势，并结合自动配置进一步简化Spring应用程序的开发。 Actuator：Actuator为Spring Boot应用添加了一定的管理特性。 Spring Boot - QuickStart：使用Spring Initalizr构建Spring Boot项目:要想使用Spring Initalizr，最简单直接的办法就是打开 http://start.spring.io，使用Spring Initalizr的web界面来构建Spring Boot项目。打开Spring Initalizr的web界面后，根据自己需求选择合适的选项： 示例代码： Generate a Maven Project with Java and Spring Boot 1.5.6123Group: ws.object.springbootArtifact: SpringBootDependencies: Web JPA #可多选 如果在当前页面找不到你所需要的依赖，请点击 Switch to the full version ,打开后就能看到可用依赖的完整列表。 填写完成之后，点击Generate Project，Spring Initalizr就会为你生成一个名为SpringBoot.zip的文件，解压后项目结构如下： 123456789101112131415161718192021222324252627➜ unzip SpringBoot.zip➜ tree ./SpringBoot./SpringBoot├── mvnw├── mvnw.cmd├── pom.xml└── src ├── main │ ├── java │ │ └── ws │ │ └── object │ │ └── springboot │ │ └── SpringBoot │ │ └── Application.java │ └── resources │ ├── application.properties │ ├── static │ └── templates └── test └── java └── ws └── object └── springboot └── SpringBoot └── ApplicationTests.java16 directories, 6 files 如你所见，项目中基本没有代码，除了几个空目录之外，还包含了以下几样东西： pom.xml : Maven工程的主要配置文件。 Application.java ： 一个带有main()方法的类，用于引导启动应用程序。 ApplicationTests.java ：一个空的JUnit测试类，它加载了Spring Boot自动配置的Spring应用上下文。 application.properties ：一个空的properties配置文件，可以根据需要添加配置属性。 static目录 ： 放置Web应用程序的静态内容(js，css，images…)。 templates目录 ： 放置用于呈现模型数据的模板文件。 mvnw和mvnw.cmd文件：分别是Windows系统和类Unix系统下Maven的配置文件。 参考资料：Stack Overflow - What is the purpose of mvnw and mvnw.cmd files? 使用IntelliJ IDEA构建Spring Boot项目：打开 IntelliJ IDEA，到Welcome to IntelliJ IDEA 界面，选择 Create New Project，左侧列表栏找到Spring Initalizr，选择自己需要的Project SDk，还有Initalizr Service URL ，Next，填写相关信息： 名称 说明 示例 Group Maven工程组的标识 ws.object.springboot Artifact Maven工程的标识与项目名称一致 SpringBoot Type 项目的构建方式 Maven Project Packaging 打包方式 Jar Java Version Java的版本信息 1.8 Language 编程语言 Java Version 项目版本号 0.0.1-SNAPSHOT Name 项目名称 SpringBoot Description 项目简介 …… 当前页填写完成之后，点击Next，选择项目所需要的依赖，选择完成之后，进入到下一页选择项目的存放路径等信息，然后项目就构建完成了。 使用Spring Boot CLI构建Spring Boot项目：Spring Boot CLI中有一些命令，可以帮我们快速构建Spring Boot项目，示例代码： 12345678910111213141516171819202122232425262728293031➜ mkdir SpringBoot &amp;&amp; cd SpringBoot➜ SpringBoot spring initUsing service at https://start.spring.ioContent saved to 'demo.zip'➜ SpringBoot lsdemo.zip➜ SpringBoot unzip demo.zipArchive: demo.zip inflating: mvnw creating: .mvn/ creating: .mvn/wrapper/ creating: src/ creating: src/main/ creating: src/main/java/ creating: src/main/java/com/ creating: src/main/java/com/example/ creating: src/main/java/com/example/demo/ creating: src/main/resources/ creating: src/test/ creating: src/test/java/ creating: src/test/java/com/ creating: src/test/java/com/example/ creating: src/test/java/com/example/demo/ inflating: .gitignore inflating: .mvn/wrapper/maven-wrapper.jar inflating: .mvn/wrapper/maven-wrapper.properties inflating: mvnw.cmd inflating: pom.xml inflating: src/main/java/com/example/demo/DemoApplication.java inflating: src/main/resources/application.properties inflating: src/test/java/com/example/demo/DemoApplicationTests.java 解压完成之后，使用Tree命令查看一下目录结构： 1234567891011121314151617181920212223➜ SpringBoot tree ../SpringBoot../SpringBoot├── demo.zip├── mvnw├── mvnw.cmd├── pom.xml└── src ├── main │ ├── java │ │ └── com │ │ └── example │ │ └── demo │ │ └── DemoApplication.java │ └── resources │ └── application.properties └── test └── java └── com └── example └── demo └── DemoApplicationTests.java12 directories, 7 files 然后将构建好的项目导入到 IDEA或者 Eclipse中就好了。 Spring Boot - CLI：使用Homebrew安装Spring Boot CLI：示例代码： 123456789101112➜ ~ brew --version # 查看Homebrew版本信息Homebrew 1.3.1➜ ~ brew tap pivotal/tap # 安装Pivotal的tap==&gt; Tapping pivotal/tap ……➜ ~ brew install springboot # 安装Spring Boot==&gt; Installing springboot from pivotal/tap==&gt; Downloading ……➜ ~ spring --version # 查看版本Spring CLI v1.5.6.RELEASE pivotal/tap：Prvotal是Spring以及Spring Boot背后的公司，通过它的tap可以安装Spring Boot。tap是向Homebrew添加额外仓库的一种途径。 Spring Boot CLI:1$ spring init 这条命令会下载一个demo.zip文件，与之前使用spring init构建的项目一样的结构。 1$ spring init -dweb,jpa,security # 使用-d或--dependencies来指定依赖 与spring init命令一样，但是在pom.xml中添加了Spring Boot的Web，JPA，Security起步依赖。 1$ spring init -dweb,jpa,security --build gradle # --build 指定项目使用Grandle构建 使用Gradle来构建项目，默认情况下是使用Maven来构建的。 1$ spring init -dweb,jpa,security --build gradle -p war # -p或者-packaging 默认情况下，无论是Maven或Gradle构建项目成功之后都会产生一个可执行的JAR文件，如果你需要一个war文件，可以通过-p 参数来指定。 1$ spring init -dweb,jpa,security --build gradle ~/Project/SpringBoot 这里的最后一个参数可以指定你的demo.zip文件的解压目录。如果你希望CLI生成的项目解压到当前目录，可以使用 —extract或者-x参数。 1$ spring help 也可以使用 spring help来查看其他命令，并了解如何使用。 Spring Boot Maven Plugin:在pom.xml中配置插件：示例代码： 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 插件的指令详解：1➜ mvn spring-boot:help 显示spring-boot-maven-plugin的帮助信息。调用mvn spring-boot：help -Ddetail = true -Dgoal = &lt;goal-name&gt;显示参数细节。 1➜ mvn spring-boot:build-info 根据当前的内容生成一个build-info.properties文件,在你的Maven Project中。 1➜ mvn spring-boot:repackage 重新包装现有的JAR和WAR存档，以便可以从中执行命令行使用java -jar。使用layout = NONE也可以简单地使用使用嵌套依赖关系打包一个JAR（没有主类，因此不可执行）。 1➜ mvn spring-boot:run 运行基于Maven构建的Spring Boot应用程序。 1➜ mvn spring-boot:start 启动Spring Boot应用程序。通常使用这个命令在应用程序在测试之前启动的集成测试场景中。 1➜ mvn spring-boot:stop 停止由“start”目标开始的应用程序。通常测试套件完成后调用。 参考资料： Spring Boot-Spring.io Spring Boot-Github Spring Boot-Reference.pdf]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HighCharts - 学习笔记整理]]></title>
    <url>%2F2017%2F08%2F05%2Fhightcharts-note%2F</url>
    <content type="text"><![CDATA[HighCharts概述：HighCharts是用JavaScript编写的图表库，可以在Web应用中使用，开源，个人及非商可以任用。 HighCharts特点： 兼容性 - 支持所有主流浏览器和移动平台（android、iOS等）。 多设备 - 支持多种设备，如手持设备 iPhone/iPad、平板等。 免费使用 - 开源免费。 轻量 - highcharts.js 内核库大小只有 35KB 左右。 配置简单 - 使用 json 格式配置 动态 - 可以在图表生成后修改。 多维 - 支持多维图表 配置提示工具 - 鼠标移动到图表的某一点上有提示信息。 时间轴 - 可以精确到毫秒。 导出 - 表格可导出为 PDF/ PNG/ JPG / SVG 格式 输出 - 网页输出图表。 可变焦 - 选中图表部分放大，近距离观察图表； 外部数据 - 从服务器载入动态数据。 文字旋转 - 支持在任意方向的标签旋转。 HighCharts构成：界面构成：在Highcharts中，一个图表通常由图表区，标题，绘图区，坐标轴，图例，数据列等几个部分组成。 代码构成： 标题（Title）： 图表标题，包含标题和副标题（subTitle），其中副标题是非必须的。 坐标轴（Axis）： 坐标轴包含x轴（xAxis）和y轴（yAxis）。通常情况下，x轴显示在图表的底部，y轴显示在图表的左侧。多个数据列可以共同使用同一个坐标轴，为了对比或区分数据，Highcharts提供了多轴的支持。 数据列（Series）： 数据列即图表上一个或多个数据系列，比如曲线图中的一条曲线，柱状图中的一个柱形。 数据提示框（Tooltip）： 当鼠标悬停在某点上时，以框的形式提示该点的数据，比如该点的值、数据单位等。数据提示框内提示的信息完全可以通过格式化函数动态指定。 图例（Legend）： 图例是图表中用不同形状、颜色、文字等 标示不同数据列，通过点击标示可以显示或隐藏该数据列。 版权标签（Credits）： 显示在图表右下方的包含链接的文字，默认是Highcharts官网地址。通过指定credits.enabled=false即可不显示该信息。 导出功能（Exporting）： 通过引入 exporting.js即可增加图表导出为常见文件功能。 示线（PlotLines）： 可以在图表上增加一条标示线，比如平均值线，最高值线等。 示区（PlotBands）： 可以在图表添加不同颜色的区域带，标示出明显的范围区域。 HighCharts配置：HighCharts常用配置项: 配置项 说 明 chart 图表基本配置项 colors 全局颜色 credits 版权信息配置项 data 高级数据模块配置项 defs 定义SVG风格模式适配项 drilldown 下钻功能配置项 exporting 导出功能配置项 labels 标签配置项 legend 图例配置项 loading 加载动画配置项 navigation 导航配置项 noData 无数据模块配置项 pane 面板模块配置项 plotOptions 绘图区配置项 responsive 响应式适配配置项 series 数据列配置项 subtitle 副标题配置项 title 标题配置项 tooltip 提示框配置项 xAxis x轴配置项 yAxis y轴配置项 zAxis z轴配置项 HighCharts图表容器配置：1、通过 dom 调用 highcharts() 函数的方式123$(&quot;#container&quot;).highcharts(&#123; // Highcharts 配置 &#125;); 2、通过 chart.renderTo 来指定123456var charts = new Highcharts.Chart(&#123; // Highcharts 配置 chart : &#123; renderTo : &quot;container&quot; // 注意这里一定是 ID 选择器 &#125;&#125;); 3、通过构造函数123var charts = new Highcharts.Chart(&apos;container&apos;, &#123; // Highcharts 配置&#125;); Highcharts图表样式配置：图表样式属性包括 border、backgroundColor、margin、spacing、style等 边框：包括 borderColor、borderRadius、borderWidth 背景：包括 backgroundColor 外边距：包括 margin、marginTop、marginRight、marginBottom、marginLeft 内边距：包括 spacing、spacingTop、spacingRight、spacingBottom、spacingLeft 其他样式：其他属性例如字体等属性，实例代码 示例代码： 12345678chart: &#123; style: &#123; fontFamily: &quot;&quot;, fontSize: &apos;12px&apos;, fontWeight: &apos;bold&apos;, color: &apos;#006cee&apos; &#125;&#125; 另外还可以通过 chart.className来绑定 CSS 类并给定 CSS 样式。 ​ HIghcharts图表绘图配置：图表绘图区的可配置属性有： plotBackgroundColor ： 绘图区背景颜色 plotBackgroundImage ： 绘图区背景图片 plotBorderColor ： 绘图区边框颜色 plotBorderWidth ： 绘图区边框宽度 plotShadow ： 绘图投影 Highcharts图表常用事件： click ：图表点击事件，效果见 在线演示 load ：图表加载完后事件，效果见 在线演示 addSeries ：图表增加序列事件，效果见 在线演示 drilldown ：图表下钻事件，效果见 在线演示 drillup ： 图表上钻事件，效果见 在线演示 redraw ：图表重绘事件，效果见 在线演示 selection ： 图表范围选择事件，效果见 在线演示 beforePrint ： 图表打印前事件，效果见 在线演示 afterPrint ： 图表打印后事件,效果见 在线演示 Highcharts图表：直线图 - (line)：示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;折线图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1000px; height: 500px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var chart = new Highcharts.Chart('container', &#123; chart: &#123; type: 'line', //指定图表的类型，默认是折线图（line） style: &#123; fontFamily: "Microsoft YaHei", fontSize: '18px', fontWeight: 'bold' &#125; &#125; ,title: &#123; text: '不同城市的月平均气温', // 标题 x: -20 // 相对于水平对齐的偏移量，可以是负数，单位是px &#125;, subtitle: &#123; text: '数据来源: xxx.com', // 副标题 x: -20 //相对于水平对齐的偏移量，可以是负数，单位是px &#125;, xAxis: &#123; // x轴 categories: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'] &#125;, yAxis: &#123; //y轴 title: &#123; text: '温度 (°C)' &#125;, plotLines: [&#123; value: 0, width: 1, color: '#808080' &#125;] &#125;, tooltip: &#123; valueSuffix: '°C' &#125;, legend: &#123; // 图例配置项 layout: 'vertical', // horizontal" 或 "vertical align: 'right', // left，center 和 right verticalAlign: 'middle', // top，middle 和 bottom borderWidth: 0 &#125;, series: [&#123; name: '东京', data: [7.0, 6.9, 9.5, 14.5, 18.2, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6] &#125;, &#123; name: '纽约', data: [-0.2, 0.8, 5.7, 11.3, 17.0, 22.0, 24.8, 24.1, 20.1, 14.1, 8.6, 2.5] &#125;, &#123; name: '柏林', data: [-0.9, 0.6, 3.5, 8.4, 13.5, 17.0, 18.6, 17.9, 14.3, 9.0, 3.9, 1.0] &#125;, &#123; name: '伦敦', data: [3.9, 4.2, 5.7, 8.5, 11.9, 15.2, 17.0, 16.6, 14.2, 10.3, 6.6, 4.8] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 曲线图 - (spline)：示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;曲线图&lt;/title&gt;&lt;/head&gt;&lt;style&gt;#container&#123; width: 1200px; height: 600px; margin:0 auto;&#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart:&#123; // 图表类型 type:'spline' &#125;, title:&#123; // 标题 text:'城市平均气温-曲线图' &#125;, subtitle:&#123; //副标题 text:'东京，纽约，伦敦' &#125;, xAlias:&#123; // x轴 categories: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'] &#125;, yAlias:&#123; // y轴 title: &#123; enable:true, text: 'Temperature (\xB0C)' &#125;, plotLines: [&#123; value: 0, width: 1, color: '#808080' &#125;] &#125;, legend:&#123; layout: 'vertical', align: 'right', verticalAlign: 'middle', borderWidth: 0 &#125;, tooltip:&#123; valueSuffix: '\xB0C', crosshairs: true,//竖线 shared: true &#125;, plotOptions:&#123; spline: &#123; marker: &#123; radius: 4, lineColor: '#666666', lineWidth: 1 &#125; &#125; &#125;, series:[ &#123; name: 'Tokyo', data: [7.0, 6.9, 9.5, 14.5, 18.2, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6] &#125;, &#123; name: 'New York', data: [-0.2, 0.8, 5.7, 11.3, 17.0, 22.0, 24.8, 24.1, 20.1, 14.1, 8.6, 2.5] &#125;, &#123; name: 'London', data: [3.9, 4.2, 5.7, 8.5, 11.9, 15.2, 17.0, 16.6, 14.2, 10.3, 6.6, 4.8] &#125; ] &#125;);&lt;/script&gt;&lt;/html&gt; 面积图 - (area)：示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;面积图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container &#123; width: 1000px; height: 500px; margin: 0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var chat = new Highcharts.Chart('container', &#123; chart: &#123; type: 'area' &#125;, title: &#123; text: '面积图' &#125;, subtitle: &#123; text: '一个简单的面积图' &#125;, xAlias: &#123; //allowDecimals: true, title:&#123; text:'Y轴', categories: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月'] &#125; &#125;, tooltip: &#123; valueSuffix: '单位' &#125;, legend: &#123; layout: 'vertical', align: 'right', verticalAlign: 'middle', borderWidth: 0 &#125;, yAlias: &#123; title: &#123; text: 'Y轴' &#125;,plotLines: [&#123; value: 0, width: 1, color: '#808080' &#125;] &#125;, series: [ &#123; name: '列一', data: [13, 83, 56, 32, 89, 97, 143, 45, 67, 87, 98] &#125;, &#123; name: '列二', data: [13, 23, 61, 62, 15, 27, 83, 75, 47, 17, 28] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 曲线面积图 - (areaspline)：示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;曲线面积图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'areaspline' &#125;, title: &#123; text: '不同家庭一周水果消费情况' &#125;, legend: &#123; layout: 'vertical', align: 'left', verticalAlign: 'top', x: 150, y: 100, floating: true, borderWidth: 1, backgroundColor: (Highcharts.theme &amp;&amp; Highcharts.theme.legendBackgroundColor) || '#FFFFFF' &#125;, xAxis: &#123; categories: [ '周一', '周二', '周三', '周四', '周五', '周六', '周日' ], plotBands: [&#123; // visualize the weekend from: 4.5, to: 6.5, color: 'rgba(68, 170, 213, .2)' &#125;] &#125;, yAxis: &#123; title: &#123; text: '水果 单位' &#125; &#125;, tooltip: &#123; shared: true, valueSuffix: ' 单位' &#125;, credits: &#123; enabled: false &#125;, plotOptions: &#123; areaspline: &#123; fillOpacity: 0.5 &#125; &#125;, series: [&#123; name: '甲', data: [3, 4, 3, 5, 4, 10, 12] &#125;, &#123; name: '乙', data: [1, 3, 4, 3, 3, 5, 4] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 柱状图 - (column)：示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;柱状图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'column' &#125;, title: &#123; text: '堆叠柱形图' &#125;, xAxis: &#123; categories: ['苹果', '橘子', '梨', '葡萄', '香蕉'] &#125;, yAxis: &#123; min: 0, title: &#123; text: '水果消费总量' &#125;, stackLabels: &#123; enabled: true, style: &#123; fontWeight: 'bold', color: 'gray' &#125; &#125; &#125;, legend: &#123; align: 'right', x: -30, verticalAlign: 'top', y: 25, floating: true, backgroundColor: 'white', borderColor: '#CCC', borderWidth: 1, shadow: false &#125;, tooltip: &#123; formatter: function () &#123; return '&lt;b&gt;' + this.x + '&lt;/b&gt;&lt;br/&gt;' + this.series.name + ': ' + this.y + '&lt;br/&gt;' + '总量: ' + this.point.stackTotal; &#125; &#125;, plotOptions: &#123; column: &#123; stacking: 'normal', dataLabels: &#123; enabled: true, color: '#FFF', style: &#123; textShadow: '0 0 3px black' &#125; &#125; &#125; &#125;, series: [&#123; name: '甲', data: [5, 3, 4, 7, 2] &#125;, &#123; name: '乙', data: [2, 2, 3, 2, 1] &#125;, &#123; name: '丙', data: [3, 4, 4, 2, 5] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 条形图 - (bar)：示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;条形图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'bar' &#125;, title: &#123; text: '各洲不同时间的人口条形图' &#125;, subtitle: &#123; text: '数据来源: Wikipedia.org' &#125;, xAxis: &#123; categories: ['非洲', '美洲', '亚洲', '欧洲', '大洋洲'], title: &#123; text: null &#125; &#125;, yAxis: &#123; min: 0, title: &#123; text: '人口总量 (百万)', align: 'high' &#125;, labels: &#123; overflow: 'justify' &#125; &#125;, tooltip: &#123; valueSuffix: ' 百万' &#125;, plotOptions: &#123; bar: &#123; dataLabels: &#123; enabled: true, allowOverlap: true &#125; &#125; &#125;, legend: &#123; layout: 'vertical', align: 'right', verticalAlign: 'top', x: -40, y: 100, floating: true, borderWidth: 1, backgroundColor: '#FFFFFF', shadow: true &#125;, credits: &#123; enabled: false &#125;, series: [&#123; name: '1800 年', data: [107, 31, 635, 203, 2] &#125;, &#123; name: '1900 年', data: [133, 156, 947, 408, 6] &#125;, &#123; name: '2008 年', data: [973, 914, 4054, 732, 34] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 饼图 - (pie)：示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;饼图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; plotBackgroundColor: null, plotBorderWidth: null, plotShadow: false &#125;, title: &#123; text: '2014 某网站各浏览器浏览量占比' &#125;, tooltip: &#123; headerFormat: '&#123;series.name&#125;&lt;br&gt;', pointFormat: '&#123;point.name&#125;: &lt;b&gt;&#123;point.percentage:.1f&#125;%&lt;/b&gt;' &#125;, plotOptions: &#123; pie: &#123; allowPointSelect: true, cursor: 'pointer', dataLabels: &#123; enabled: true, format: '&lt;b&gt;&#123;point.name&#125;&lt;/b&gt;: &#123;point.percentage:.1f&#125; %', style: &#123; color:'black' &#125; &#125; &#125; &#125;, series: [&#123; type: 'pie', name: '浏览器访问量占比', data: [ ['Firefox', 45.0], ['IE', 26.8], &#123; name: 'Chrome', y: 12.8, sliced: true, selected: true &#125;, ['Safari', 8.5], ['Opera', 6.2], ['其他', 0.7] ] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 散点图 - (scatter)：示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;散点图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'scatter', zoomType: 'xy' &#125;, title: &#123; text: '507 人按性别划分的身高和体重分布图' &#125;, subtitle: &#123; text: '数据来源: Heinz 2003' &#125;, xAxis: &#123; title: &#123; enabled: true, text: '身高 (cm)' &#125;, startOnTick: true, endOnTick: true, showLastLabel: true &#125;, yAxis: &#123; title: &#123; text: '体重 (kg)' &#125; &#125;, legend: &#123; layout: 'vertical', align: 'left', verticalAlign: 'top', x: 100, y: 70, floating: true, backgroundColor: '#FFFFFF', borderWidth: 1 &#125;, plotOptions: &#123; scatter: &#123; marker: &#123; radius: 5, states: &#123; hover: &#123; enabled: true, lineColor: 'rgb(100,100,100)' &#125; &#125; &#125;, states: &#123; hover: &#123; marker: &#123; enabled: false &#125; &#125; &#125;, tooltip: &#123; headerFormat: '&lt;b&gt;&#123;series.name&#125;&lt;/b&gt;&lt;br&gt;', pointFormat: '&#123;point.x&#125; cm, &#123;point.y&#125; kg' &#125; &#125; &#125;, series: [&#123; name: '女', color: 'rgba(223, 83, 83, .5)', data: [[161.2, 51.6], [167.5, 59.0], [159.5, 49.2], [157.0, 63.0], [155.8, 53.6], [170.0, 59.0], [159.1, 47.6], [166.0, 69.8], [176.2, 66.8], [160.2, 75.2], [172.5, 55.2], [170.9, 54.2], [172.9, 62.5], [153.4, 42.0], [160.0, 50.0], [147.2, 49.8], [168.2, 49.2], [175.0, 73.2], [157.0, 47.8], [167.6, 68.8], [159.5, 50.6], [175.0, 82.5], [166.8, 57.2], [176.5, 87.8], [170.2, 72.8], [174.0, 54.5], [173.0, 59.8], [179.9, 67.3], [170.5, 67.8], [160.0, 47.0], [154.4, 46.2], [162.0, 55.0], [176.5, 83.0], [160.0, 54.4], [152.0, 45.8], [162.1, 53.6], [170.0, 73.2], [160.2, 52.1], [161.3, 67.9], [166.4, 56.6], [168.9, 62.3], [163.8, 58.5], [167.6, 54.5], [160.0, 50.2], [161.3, 60.3], [167.6, 58.3], [165.1, 56.2], [160.0, 50.2], [170.0, 72.9], [157.5, 59.8], [167.6, 61.0], [160.7, 69.1], [163.2, 55.9], [152.4, 46.5], [157.5, 54.3], [168.3, 54.8], [180.3, 60.7], [165.5, 60.0], [165.0, 62.0], [164.5, 60.3], [156.0, 52.7], [160.0, 74.3], [163.0, 62.0], [165.7, 73.1], [161.0, 80.0], [162.0, 54.7], [166.0, 53.2], [174.0, 75.7], [172.7, 61.1], [167.6, 55.7], [151.1, 48.7], [164.5, 52.3], [163.5, 50.0], [152.0, 59.3], [169.0, 62.5], [164.0, 55.7], [161.2, 54.8], [155.0, 45.9], [170.0, 70.6], [176.2, 67.2], [170.0, 69.4], [162.5, 58.2], [170.3, 64.8], [164.1, 71.6], [169.5, 52.8], [163.2, 59.8], [154.5, 49.0], [159.8, 50.0], [173.2, 69.2], [170.0, 55.9], [161.4, 63.4], [169.0, 58.2], [166.2, 58.6], [159.4, 45.7], [162.5, 52.2], [159.0, 48.6], [162.8, 57.8], [159.0, 55.6], [179.8, 66.8], [162.9, 59.4], [161.0, 53.6], [151.1, 73.2], [168.2, 53.4], [168.9, 69.0], [173.2, 58.4], [171.8, 56.2], [178.0, 70.6], [164.3, 59.8], [163.0, 72.0], [168.5, 65.2], [166.8, 56.6], [172.7, 105.2], [163.5, 51.8], [169.4, 63.4], [167.8, 59.0], [159.5, 47.6], [167.6, 63.0], [161.2, 55.2], [160.0, 45.0], [163.2, 54.0], [162.2, 50.2], [161.3, 60.2], [149.5, 44.8], [157.5, 58.8], [163.2, 56.4], [172.7, 62.0], [155.0, 49.2], [156.5, 67.2], [164.0, 53.8], [160.9, 54.4], [162.8, 58.0], [167.0, 59.8], [160.0, 54.8], [160.0, 43.2], [168.9, 60.5], [158.2, 46.4], [156.0, 64.4], [160.0, 48.8], [167.1, 62.2], [158.0, 55.5], [167.6, 57.8], [156.0, 54.6], [162.1, 59.2], [173.4, 52.7], [159.8, 53.2], [170.5, 64.5], [159.2, 51.8], [157.5, 56.0], [161.3, 63.6], [162.6, 63.2], [160.0, 59.5], [168.9, 56.8], [165.1, 64.1], [162.6, 50.0], [165.1, 72.3], [166.4, 55.0], [160.0, 55.9], [152.4, 60.4], [170.2, 69.1], [162.6, 84.5], [170.2, 55.9], [158.8, 55.5], [172.7, 69.5], [167.6, 76.4], [162.6, 61.4], [167.6, 65.9], [156.2, 58.6], [175.2, 66.8], [172.1, 56.6], [162.6, 58.6], [160.0, 55.9], [165.1, 59.1], [182.9, 81.8], [166.4, 70.7], [165.1, 56.8], [177.8, 60.0], [165.1, 58.2], [175.3, 72.7], [154.9, 54.1], [158.8, 49.1], [172.7, 75.9], [168.9, 55.0], [161.3, 57.3], [167.6, 55.0], [165.1, 65.5], [175.3, 65.5], [157.5, 48.6], [163.8, 58.6], [167.6, 63.6], [165.1, 55.2], [165.1, 62.7], [168.9, 56.6], [162.6, 53.9], [164.5, 63.2], [176.5, 73.6], [168.9, 62.0], [175.3, 63.6], [159.4, 53.2], [160.0, 53.4], [170.2, 55.0], [162.6, 70.5], [167.6, 54.5], [162.6, 54.5], [160.7, 55.9], [160.0, 59.0], [157.5, 63.6], [162.6, 54.5], [152.4, 47.3], [170.2, 67.7], [165.1, 80.9], [172.7, 70.5], [165.1, 60.9], [170.2, 63.6], [170.2, 54.5], [170.2, 59.1], [161.3, 70.5], [167.6, 52.7], [167.6, 62.7], [165.1, 86.3], [162.6, 66.4], [152.4, 67.3], [168.9, 63.0], [170.2, 73.6], [175.2, 62.3], [175.2, 57.7], [160.0, 55.4], [165.1, 104.1], [174.0, 55.5], [170.2, 77.3], [160.0, 80.5], [167.6, 64.5], [167.6, 72.3], [167.6, 61.4], [154.9, 58.2], [162.6, 81.8], [175.3, 63.6], [171.4, 53.4], [157.5, 54.5], [165.1, 53.6], [160.0, 60.0], [174.0, 73.6], [162.6, 61.4], [174.0, 55.5], [162.6, 63.6], [161.3, 60.9], [156.2, 60.0], [149.9, 46.8], [169.5, 57.3], [160.0, 64.1], [175.3, 63.6], [169.5, 67.3], [160.0, 75.5], [172.7, 68.2], [162.6, 61.4], [157.5, 76.8], [176.5, 71.8], [164.4, 55.5], [160.7, 48.6], [174.0, 66.4], [163.8, 67.3]] &#125;, &#123; name: '男', color: 'rgba(119, 152, 191, .5)', data: [[174.0, 65.6], [175.3, 71.8], [193.5, 80.7], [186.5, 72.6], [187.2, 78.8], [181.5, 74.8], [184.0, 86.4], [184.5, 78.4], [175.0, 62.0], [184.0, 81.6], [180.0, 76.6], [177.8, 83.6], [192.0, 90.0], [176.0, 74.6], [174.0, 71.0], [184.0, 79.6], [192.7, 93.8], [171.5, 70.0], [173.0, 72.4], [176.0, 85.9], [176.0, 78.8], [180.5, 77.8], [172.7, 66.2], [176.0, 86.4], [173.5, 81.8], [178.0, 89.6], [180.3, 82.8], [180.3, 76.4], [164.5, 63.2], [173.0, 60.9], [183.5, 74.8], [175.5, 70.0], [188.0, 72.4], [189.2, 84.1], [172.8, 69.1], [170.0, 59.5], [182.0, 67.2], [170.0, 61.3], [177.8, 68.6], [184.2, 80.1], [186.7, 87.8], [171.4, 84.7], [172.7, 73.4], [175.3, 72.1], [180.3, 82.6], [182.9, 88.7], [188.0, 84.1], [177.2, 94.1], [172.1, 74.9], [167.0, 59.1], [169.5, 75.6], [174.0, 86.2], [172.7, 75.3], [182.2, 87.1], [164.1, 55.2], [163.0, 57.0], [171.5, 61.4], [184.2, 76.8], [174.0, 86.8], [174.0, 72.2], [177.0, 71.6], [186.0, 84.8], [167.0, 68.2], [171.8, 66.1], [182.0, 72.0], [167.0, 64.6], [177.8, 74.8], [164.5, 70.0], [192.0, 101.6], [175.5, 63.2], [171.2, 79.1], [181.6, 78.9], [167.4, 67.7], [181.1, 66.0], [177.0, 68.2], [174.5, 63.9], [177.5, 72.0], [170.5, 56.8], [182.4, 74.5], [197.1, 90.9], [180.1, 93.0], [175.5, 80.9], [180.6, 72.7], [184.4, 68.0], [175.5, 70.9], [180.6, 72.5], [177.0, 72.5], [177.1, 83.4], [181.6, 75.5], [176.5, 73.0], [175.0, 70.2], [174.0, 73.4], [165.1, 70.5], [177.0, 68.9], [192.0, 102.3], [176.5, 68.4], [169.4, 65.9], [182.1, 75.7], [179.8, 84.5], [175.3, 87.7], [184.9, 86.4], [177.3, 73.2], [167.4, 53.9], [178.1, 72.0], [168.9, 55.5], [157.2, 58.4], [180.3, 83.2], [170.2, 72.7], [177.8, 64.1], [172.7, 72.3], [165.1, 65.0], [186.7, 86.4], [165.1, 65.0], [174.0, 88.6], [175.3, 84.1], [185.4, 66.8], [177.8, 75.5], [180.3, 93.2], [180.3, 82.7], [177.8, 58.0], [177.8, 79.5], [177.8, 78.6], [177.8, 71.8], [177.8, 116.4], [163.8, 72.2], [188.0, 83.6], [198.1, 85.5], [175.3, 90.9], [166.4, 85.9], [190.5, 89.1], [166.4, 75.0], [177.8, 77.7], [179.7, 86.4], [172.7, 90.9], [190.5, 73.6], [185.4, 76.4], [168.9, 69.1], [167.6, 84.5], [175.3, 64.5], [170.2, 69.1], [190.5, 108.6], [177.8, 86.4], [190.5, 80.9], [177.8, 87.7], [184.2, 94.5], [176.5, 80.2], [177.8, 72.0], [180.3, 71.4], [171.4, 72.7], [172.7, 84.1], [172.7, 76.8], [177.8, 63.6], [177.8, 80.9], [182.9, 80.9], [170.2, 85.5], [167.6, 68.6], [175.3, 67.7], [165.1, 66.4], [185.4, 102.3], [181.6, 70.5], [172.7, 95.9], [190.5, 84.1], [179.1, 87.3], [175.3, 71.8], [170.2, 65.9], [193.0, 95.9], [171.4, 91.4], [177.8, 81.8], [177.8, 96.8], [167.6, 69.1], [167.6, 82.7], [180.3, 75.5], [182.9, 79.5], [176.5, 73.6], [186.7, 91.8], [188.0, 84.1], [188.0, 85.9], [177.8, 81.8], [174.0, 82.5], [177.8, 80.5], [171.4, 70.0], [185.4, 81.8], [185.4, 84.1], [188.0, 90.5], [188.0, 91.4], [182.9, 89.1], [176.5, 85.0], [175.3, 69.1], [175.3, 73.6], [188.0, 80.5], [188.0, 82.7], [175.3, 86.4], [170.5, 67.7], [179.1, 92.7], [177.8, 93.6], [175.3, 70.9], [182.9, 75.0], [170.8, 93.2], [188.0, 93.2], [180.3, 77.7], [177.8, 61.4], [185.4, 94.1], [168.9, 75.0], [185.4, 83.6], [180.3, 85.5], [174.0, 73.9], [167.6, 66.8], [182.9, 87.3], [160.0, 72.3], [180.3, 88.6], [167.6, 75.5], [186.7, 101.4], [175.3, 91.1], [175.3, 67.3], [175.9, 77.7], [175.3, 81.8], [179.1, 75.5], [181.6, 84.5], [177.8, 76.6], [182.9, 85.0], [177.8, 102.5], [184.2, 77.3], [179.1, 71.8], [176.5, 87.9], [188.0, 94.3], [174.0, 70.9], [167.6, 64.5], [170.2, 77.3], [167.6, 72.3], [188.0, 87.3], [174.0, 80.0], [176.5, 82.3], [180.3, 73.6], [167.6, 74.1], [188.0, 85.9], [180.3, 73.2], [167.6, 76.3], [183.0, 65.9], [183.0, 90.9], [179.1, 89.1], [170.2, 62.3], [177.8, 82.7], [179.1, 79.1], [190.5, 98.2], [177.8, 84.1], [180.3, 83.2], [180.3, 83.2]] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 箱线图 - (boxplot)：示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;箱线图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://img.hcharts.cn/highcharts/highcharts-more.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'boxplot' &#125;, title: &#123; text: 'Highcharts 箱线图' &#125;, legend: &#123; enabled: false &#125;, xAxis: &#123; categories: ['1', '2', '3', '4', '5'], title: &#123; text: '' &#125; &#125;, yAxis: &#123; title: &#123; text: '观测值' &#125;, plotLines: [&#123; value: 932, color: 'red', width: 1, label: &#123; text: '理论模型: 932', align: 'center', style: &#123; color: 'gray' &#125; &#125; &#125;] &#125;, tooltip: &#123; pointFormat: '&lt;span style="color:&#123;point.color&#125;"&gt;\u25CF&lt;/span&gt; &lt;b&gt; &#123;series.name&#125;&lt;/b&gt;&lt;br/&gt;' + // eslint-disable-line no-dupe-keys '最大值: &#123;point.high&#125;&lt;br/&gt;' + 'Q2\t: &#123;point.q3&#125;&lt;br/&gt;' + '中位数: &#123;point.median&#125;&lt;br/&gt;' + 'Q1\t: &#123;point.q1&#125;&lt;br/&gt;' + '最小值: &#123;point.low&#125;&lt;br/&gt;' &#125;, series: [&#123; name: '观测值', data: [ [760, 801, 848, 895, 965], [733, 853, 939, 980, 1080], [714, 762, 817, 870, 918], [724, 802, 806, 871, 950], [834, 836, 864, 882, 910] ], tooltip: &#123; headerFormat: '&lt;em&gt;实验号码： &#123;point.key&#125;&lt;/em&gt;&lt;br/&gt;' &#125; &#125;, &#123; name: '异常值', color: Highcharts.getOptions().colors[0], type: 'scatter', data: [ // x, y positions where 0 is the first category [0, 644], [4, 718], [4, 951], [4, 969] ], marker: &#123; fillColor: 'white', lineWidth: 1, lineColor: Highcharts.getOptions().colors[0] &#125;, tooltip: &#123; pointFormat: 'Observation: &#123;point.y&#125;' &#125; &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 气泡图 - (bubble)：示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;气泡图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://img.hcharts.cn/highcharts/highcharts-more.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'bubble', zoomType: 'xy' &#125;, title: &#123; text: 'Highcharts 气泡图' &#125;, series: [&#123; name:'数据列 1', // 每个气泡包含三个值，x，y，z；其中 x，y用于定位，z 用于计算气泡大小 data: [[97, 36, 79], [94, 74, 60], [68, 76, 58], [64, 87, 56], [68, 27, 73], [74, 99, 42], [7, 93, 87], [51, 69, 40], [38, 23, 33], [57, 86, 31]] &#125;, &#123; name:'数据列 2', data: [[25, 10, 87], [2, 75, 59], [11, 54, 8], [86, 55, 93], [5, 3, 58], [90, 63, 44], [91, 33, 17], [97, 3, 56], [15, 67, 48], [54, 25, 81]] &#125;, &#123; name:'数据列 3', data: [[47, 47, 21], [20, 12, 4], [6, 76, 91], [38, 30, 60], [57, 98, 64], [61, 17, 80], [83, 60, 13], [67, 78, 75], [64, 12, 10], [30, 77, 82]] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 误差线图 - (errorbar)：示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;误差图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1200px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://img.hcharts.cn/highcharts/highcharts-more.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; zoomType: 'xy' &#125;, title: &#123; text: '误差图' &#125;, xAxis: [&#123; categories: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'] &#125;], yAxis: [&#123; // Primary yAxis labels: &#123; format: '&#123;value&#125; °C', style: &#123; color: Highcharts.getOptions().colors[1] &#125; &#125;, title: &#123; text: '温度', style: &#123; color: Highcharts.getOptions().colors[1] &#125; &#125; &#125;, &#123; // Secondary yAxis title: &#123; text: '降水', style: &#123; color: Highcharts.getOptions().colors[0] &#125; &#125;, labels: &#123; format: '&#123;value&#125; mm', style: &#123; color: Highcharts.getOptions().colors[0] &#125; &#125;, opposite: true &#125;], tooltip: &#123; shared: true &#125;, series: [&#123; name: '降水', type: 'column', yAxis: 1, data: [49.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4], tooltip: &#123; pointFormat: '&lt;span style="font-weight: bold; color: &#123;series.color&#125;"&gt;&#123;series.name&#125;&lt;/span&gt;: &lt;b&gt;&#123;point.y:.1f&#125; mm&lt;/b&gt; ' &#125; &#125;, &#123; name: '降雨误差', type: 'errorbar', yAxis: 1, data: [[48, 51], [68, 73], [92, 110], [128, 136], [140, 150], [171, 179], [135, 143], [142, 149], [204, 220], [189, 199], [95, 110], [52, 56]], tooltip: &#123; pointFormat: '(误差范围: &#123;point.low&#125;-&#123;point.high&#125; mm)&lt;br/&gt;' &#125; &#125;, &#123; name: '温度', type: 'spline', data: [7.0, 6.9, 9.5, 14.5, 18.2, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6], tooltip: &#123; pointFormat: '&lt;span style="font-weight: bold; color: &#123;series.color&#125;"&gt;&#123;series.name&#125;&lt;/span&gt;: &lt;b&gt;&#123;point.y:.1f&#125;°C&lt;/b&gt; ' &#125; &#125;, &#123; name: '温度误差', type: 'errorbar', data: [[6, 8], [5.9, 7.6], [9.4, 10.4], [14.1, 15.9], [18.0, 20.1], [21.0, 24.0], [23.2, 25.3], [26.1, 27.8], [23.2, 23.9], [18.0, 21.1], [12.9, 14.0], [7.6, 10.0]], tooltip: &#123; pointFormat: '(误差范围: &#123;point.low&#125;-&#123;point.high&#125;°C)&lt;br/&gt;' &#125; &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 漏斗图 - (funnel)：示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;漏斗图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; width: 1000px; height: 600px; margin:0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://img.hcharts.cn/highcharts/modules/funnel.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; type: 'funnel', marginRight: 100 &#125;, title: &#123; text: '销售漏斗', x: -50 &#125;, plotOptions: &#123; series: &#123; dataLabels: &#123; enabled: true, format: '&lt;b&gt;&#123;point.name&#125;&lt;/b&gt; (&#123;point.y:,.0f&#125;)', color: 'black', softConnector: true &#125;, neckWidth: '30%', neckHeight: '25%' //-- Other available options // height: pixels or percent // width: pixels or percent &#125; &#125;, legend: &#123; enabled: false &#125;, series: [&#123; name: '用户', data: [ ['访问网站', 15654], ['下载产品', 4064], ['询价', 1987], ['发送合同', 976], ['成交', 846] ] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 蜘蛛图：示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;蜘蛛图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; min-width: 400px; max-width: 600px; height: 400px; margin: 0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://img.hcharts.cn/highcharts/highcharts-more.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; polar: true, type: 'line' &#125;, title: &#123; text: '预算与支出', x: -80 &#125;, pane: &#123; size: '80%' &#125;, xAxis: &#123; categories: ['销售', '市场营销', '发展', '客户支持', '信息技术', '行政管理'], tickmarkPlacement: 'on', lineWidth: 0 &#125;, yAxis: &#123; gridLineInterpolation: 'polygon', lineWidth: 0, min: 0 &#125;, tooltip: &#123; shared: true, pointFormat: '&lt;span style="color:&#123;series.color&#125;"&gt;&#123;series.name&#125;: &lt;b&gt;$&#123;point.y:,.0f&#125;&lt;/b&gt;&lt;br/&gt;' &#125;, legend: &#123; align: 'right', verticalAlign: 'top', y: 70, layout: 'vertical' &#125;, series: [&#123; name: '预算拨款', data: [43000, 19000, 60000, 35000, 17000, 10000], pointPlacement: 'on' &#125;, &#123; name: '实际支出', data: [50000, 39000, 42000, 31000, 26000, 14000], pointPlacement: 'on' &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 极地图：示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;极地图&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #container&#123; min-width: 400px; max-width: 600px; height: 400px; margin: 0 auto; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="http://cdn.hcharts.cn/highcharts/highcharts.js"&gt;&lt;/script&gt;&lt;script src="https://img.hcharts.cn/highcharts/highcharts-more.js"&gt;&lt;/script&gt;&lt;script&gt; var charts =new Highcharts.Chart('container',&#123; chart: &#123; polar: true &#125;, title: &#123; text: '极地图' &#125;, pane: &#123; startAngle: 0, endAngle: 360 &#125;, xAxis: &#123; tickInterval: 45, min: 0, max: 360, labels: &#123; formatter: function () &#123; return this.value + '°'; &#125; &#125; &#125;, yAxis: &#123; min: 0 &#125;, plotOptions: &#123; series: &#123; pointStart: 0, pointInterval: 45 &#125;, column: &#123; pointPadding: 0, groupPadding: 0 &#125; &#125;, series: [&#123; type: 'column', name: '柱形', data: [8, 7, 6, 5, 4, 3, 2, 1], pointPlacement: 'between' &#125;, &#123; type: 'line', name: '线', data: [1, 2, 3, 4, 5, 6, 7, 8] &#125;, &#123; type: 'area', name: '面积', data: [1, 8, 2, 7, 3, 6, 4, 5] &#125;] &#125;);&lt;/script&gt;&lt;/html&gt; 参考资料： HighCharts官网 HighCharts中文网 HighCharts中文社区 HighCharts官网API]]></content>
      <categories>
        <category>Charts</category>
      </categories>
      <tags>
        <tag>HighCharts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『构建工具-Webpack』相关内容整理]]></title>
    <url>%2F2017%2F07%2F23%2Fwebpack-note%2F</url>
    <content type="text"><![CDATA[Webpack是什么？ webpack is a module bundler.Webpack是一个模块打包器。 webpack 是一个现代 JavaScript 应用程序的模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成少量的 bundle - 通常只有一个，由浏览器加载。 Webpack的特点： 代码拆分： Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。 Loader： Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成Javascript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。 智能解析： Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 js 文件。甚至在加载依赖的时候，允许使用动态表达式 require(“./templates/“ + name + “.jade”)。 插件系统： Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。 快速运行： Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。 Webpack与Gulp的区别？ gulp: gulp强调的是前端开发的工作流程，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程。 PS：Automate and enhance your workflow webpack: webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。 PS：webpack is a module bundle Webpack的核心概念：Web是高度可配置的，在开始前需要先理解四个核心概念：入口(entry)、输出(output)、loader、插件(plugins)。 entry: 在 webpack 中，我们使用 webpack 配置对象(webpack configuration object)中的 entry 属性来定义入口。看一个最简单的例子： 123module.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;&#125;; Output:将所有的资源(assets)归拢在一起后，还需要告诉 webpack 在哪里打包应用程序。webpack 的 output 属性描述了如何处理归拢在一起的代码(bundled code)。例子： 123456789const path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; &#125;&#125;; Loader: webpack loader 在文件被添加到依赖图中时，其转换为模块。例子： 12345678910111213141516const path = require(&apos;path&apos;);const config = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125; ] &#125;&#125;;module.exports = config; Plugins：想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 来创建它的一个实例。例子： 12345678910111213141516171819202122const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //installed via npmconst webpack = require(&apos;webpack&apos;); //to access built-in pluginsconst path = require(&apos;path&apos;);const config = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;) ]&#125;;module.exports = config; 参考资料:核心概念简介 Webpack的安装配置：前提条件:请安装和使用 Node.js 最新的长期支持版本(LTS - Long Term Support)，使用旧版本，你可能遇到各种问题，因为它们可能缺少 webpack 功能以及/或者缺少相关 package 包。 本地安装：最新版本的webpack是: Github-Webpack-Releases1npm install -g webpack --save-dev 安装完成之后，会在package.json中会添加如下信息： 123&quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^3.4.1&quot;&#125; 对于大多数项目，建议本地安装。这可以使我们在引入破坏式变更(breaking change)的依赖时，更容易分别升级项目。一般不推荐全局安装 webpack。这会将您项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中，可能会导致构建失败。 Webpack的简单使用:构建项目：新建一个index.js文件，在跟该文件中编写一个函数： 1234// index.js 文件function func(str) &#123; alert(str);&#125; 编写完成之后可以使用webpack命令了来打包index.js文件，如下所示： 12345678910语法: webpack [待打包文件] [打包完成文件名]例子: webpack index.js index.bundle.js➜ js webpack index.js index.bundle.jsHash: 72aeecc257bb3571dac7Version: webpack 3.4.1Time: 61ms Asset Size Chunks Chunk Namesindex.bundle.js 2.51 kB 0 [emitted] main [0] ./index.js 37 bytes &#123;0&#125; [built] 打包输出信息说明： Name Description Hash 文件的HASH值 Version webpack的版本 Time 打包所花费的时间 Asset 打包生成的文件 Size 生成文件的大小 Chunks 打包的分块 Chunk Names 打包的块名称 这样就完成了一次简单的打包操作，打包完成之后可以打开index.bundle.js查看一下，Webpack会自动给该文件中添加一些注释还会给一些模块进行编号。 参考资料：Webpack官网简单Demo Webpack的基本配置:按照如下目录结构进行构建一个项目： 1234567891011121314151617➜ ~ tree WebpackWebpack├── dist│ ├── css│ └── js├── node_modules├── package-lock.json├── package.json├── src│ ├── css│ │ └── style.css│ ├── index.html│ └── js│ └── index.js└── webpack.config.js7 directories, 6 files webpack.config.js编写webpack.config.js文件： 123456789101112131415161718const webpack = require(&apos;webpack&apos;);module.exports = &#123; entry:&apos;./src/js/index.js&apos;, output:&#123; path:&apos;/Users/Yang/Documents/Webstorm-Work/Webpack/dist/js&apos;, // 设置输出目录 filename:&apos;[name].bundle.js&apos; // 输出文件名 &#125;,module:&#123; loaders:[ test:/\.css$/,//支持正则 loader:&apos;style-loader!css-loader&apos; ] &#125;,resolve:&#123; //添加在此的后缀所对应的文件可以省略后缀 extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;, &apos;.css&apos;, &apos;.scss&apos;] &#125;,plugins:[ new webpack.BannerPlugin(&apos;This file is created by ly&apos;); // 插件设置 ]&#125; Webpack的Loader使用：loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 简单示例：可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loader： 12npm install --save-dev css-loader # CSS loadernpm install --save-dev ts-loader # TypeScript loader 然后指示 webpack 对每个 .css 使用 css-loader，以及对所有 .ts 文件使用 ts-loader： webpack.config.js 12345678module.exports = &#123; module: &#123; rules: [ &#123; test: /\.css$/, use: &apos;css-loader&apos; &#125;, &#123; test: /\.ts$/, use: &apos;ts-loader&apos; &#125; ] &#125;&#125;; 使用 Loader：在应用程序中，有三种使用 loader 的方式： 配置（推荐）：在 webpack.config.js 文件中指定 loader。 内联：在每个 import 语句中显式指定 loader。 CLI：在 shell 命令中指定它们。 配置[Configuration]:module.rules 允许你在 webpack 配置中指定多个 loader。 这是展示 loader 的一种简明方式，并且有助于使代码变得简洁。同时让你对各个 loader 有个全局概览： 12345678910111213141516module: &#123; rules: [ &#123; test: /\.css$/, use: [ &#123; loader: &apos;style-loader&apos; &#125;, &#123; loader: &apos;css-loader&apos;, options: &#123; modules: true &#125; &#125; ] &#125; ]&#125; 内联:可以在 import 语句或任何等效于 “import” 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。 1import Styles from &apos;style-loader!css-loader?modules!./styles.css&apos;; 通过前置所有规则及使用 !，可以对应覆盖到配置中的任意 loader。 选项可以传递查询参数，例如 ?key=value&amp;foo=bar，或者一个 JSON 对象，例如 ?{&quot;key&quot;:&quot;value&quot;,&quot;foo&quot;:&quot;bar&quot;}。 尽可能使用 module.rules，因为这样可以减少源码中的代码量，并且可以在出错时，更快地调试和定位 loader 中的问题。 CLI:你也可以通过 CLI 使用 loader： 1webpack --module-bind jade-loader --module-bind &apos;css=style-loader!css-loader&apos; 这会对 .jade 文件使用 jade-loader，对 .css 文件使用 style-loader 和 css-loader。 Loader 特性: loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照先后顺序进行编译。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。 loader 可以是同步的，也可以是异步的。 loader 运行在 Node.js 中，并且能够执行任何可能的操作。 loader 接收查询参数。用于对 loader 传递配置。 loader 也能够使用 options 对象进行配置。 除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。 插件(plugin)可以为 loader 带来更多特性。 loader 能够产生额外的任意文件。 loader 通过（loader）预处理函数，为 JavaScript 生态系统提供了更多能力。用户现在可以更加灵活地引入细粒度逻辑，例如压缩、打包、语言翻译和其他更多。 解析 Loader:loader 遵循标准的模块解析。多数情况下，loader 将从模块路径（通常将模块路径认为是 npm install, node_modules）解析。 loader 模块需要导出为一个函数，并且使用 Node.js 兼容的 JavaScript 编写。通常使用 npm 进行管理，但是也可以将自定义 loader 作为应用程序中的文件。按照约定，loader 通常被命名为 xxx-loader（例如 json-loader）。有关详细信息，请查看如何编写 loader？。 参考资料：Webpack-Loader详解 Webpack的CLI使用:Output：通过以下这些配置，你可以调整构建流程的某些输出参数。 常用参数说明： 参数 说明 输入类型 默认值 –output-chunk-filename 输出的附带 chunk 的文件名 string 含有[id] 的文件名，而不是 [name] 或者 [id] 作为前缀 –output-filename 打包文件的文件名 string [name].js –output-jsonp-function 加载 Chunk 时使用的 JSONP 函数名 string webpackJsonp –output-library 以库的形式导出入口文件 string –output-library-target 以库的形式导出入口文件时，输出的类型 string var –output-path 输出的路径（在公共路径的基础上） string 当前目录 –output-pathinfo 加入一些依赖信息的注解 boolean false –output-public-path 输出文件时使用的公共路径 string / –output-source-map-filename 生成的 SourceMap 的文件名 string [name].map or [outputFilename].map Debug：以下这些配置可以帮助你在 Webpack 编译过程中更好地 debug。 常用参数说明： 参数 说明 输入类型 默认值 –debug 把 loader 设置为 debug 模式 boolean false –devtool 为打包好的资源定义source map 的类 string - –progress 打印出编译进度的百分比值 boolean false Model：这些配置可以用于绑定 Webpack 允许的模块。 常用参数说明： 参数 说明 使用方法 –module-bind 为 loader 绑定一个扩展 –module-bind js=babel-loader –module-bind-post 为 post loader 绑定一个扩展 –module-bind-pre 为 pre loader 绑定一个扩展 Watch:这些配置可以用于观察依赖文件的变化，一旦有变化，则可以重新执行构建流程。 常用参数说明： 参数 说明 –watch, -w 观察文件系统的变化 –save, -s 在保存的时候重新编译，无论文件是否变化 –watch-aggregate-timeout 指定一个毫秒数，在这个时间内，文件若发送了多次变化，会被合并 –watch-poll 轮询观察文件变化的时间间隔（同时会打开轮询机制 –watch-stdin, –stdin 当 stdin 关闭时，退出进程 Optimize：在生产环境的构建时，这些配置可以用于调整的一些性能相关的配置。 常用参数说明： 参数 解释说明 使用的插件 –optimize-max-chunks 限制 chunk 的数量 LimitChunkCountPlugin –optimize-min-chunk-size 限制 chunk 的最小体积 MinChunkSizePlugin –optimize-minimize 压缩混淆 javascript，并且把 loader 设置为 minimizing UglifyJsPlugin &amp; LoaderOptionsPlugin Resolve：这些配置可以用于设置 webpack resolver 时使用的别名(alias)和扩展名(extension)。 常用参数说明： 参数 说明 示例 –resolve-alias 指定模块的别名 –resolve-alias jquery-plugin=jquery.plugin –resolve-extensions 指定需要被处理的文件的扩展名 –resolve-extensions .es6 .js .ts –resolve-loader-alias Minimize javascript and switches loaders to minimizing Display：以下选项用于配置 Webpack 在控制台输出的统计数据，以及这些数据的样式。 常用参数说明： 参数 说明 类型 –color, –colors 开启/关闭控制台的颜色 [默认值: (supports-color)] boolean –display-cached 在输出中显示缓存的模块 boolean –display-cached-assets 在输出中显示缓存的 assets boolean –display-chunks 在输出中显示 chunks boolean –display-depth 显示从入口起点到每个模块的距离 boolean –display-entrypoints 在输出中显示入口文件 boolean –display-error-details 显示详细的错误信息 boolean –display-exclude 在输出中显示被排除的文件 boolean –display-max-modules 设置输出中可见模块的最大数量 number –display-modules 在输出中显示所有模块，包括被排除的模块 boolean –display-optimization-bailout 作用域提升回退触发器(Scope hoisting fallback trigger)（从 webpack 3.0.0 开始） boolean –display-origins 在输出中显示最初的 chunk boolean –display-provided-exports 显示有关从模块导出的信息 boolean –display-reasons 显示模块包含在输出中的原因 boolean –display-used-exports 显示模块中被使用的接口（Tree Shaking） boolean –hide-modules 隐藏关于模块的信息 boolean –sort-assets-by 对 assets 列表以某种属性排序 string –sort-chunks-by 对 chunks 列表以某种属性排序 string –sort-modules-by 对模块列表以某种属性排序 string –verbose 显示更多信息 boolean –display 选择显示预设(verbose - 繁琐, detailed - 细节, normal - 正常, minimal - 最小, errors-only - 仅错误, none - 无; 从 webpack 3.0.0 开始) string Other： 参数 说明 用法 –bail 一旦发生错误，立即终止 –cache 开启缓存 [watch 时会默认打开] –cache=false –define 定义 bundle 中的任意自由变量，查看 shimming –define process.env.NODE_ENV=’development’ –hot 开启模块热替换 [使用 HotModuleReplacementPlugin] -hot=true –labeled-modules Enables 开启模块标签 [使用 LabeledModulesPlugin] -plugin 加载某个插件 –prefetch 预加载某个文件 –prefetch=./files.js –provide 在所有模块中将这些模块提供为自由变量，查看 shimming –provide jQuery=jquery –records-input-path 记录文件的路径（读取） –records-output-path 记录文件的路径（写入） –records-path 记录文件的路径 –target 目标的执行环境 –target=’node’ 参考资料：Webpack-CLI使用 参考资料: Webpack 1.x 官方文档 Webpack 2.x 官方文档 Webpack 中文网 Webpack 视频教程 Webpack-API]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『构建工具-Maven』相关内容整理]]></title>
    <url>%2F2017%2F07%2F04%2Fmaven-note%2F</url>
    <content type="text"><![CDATA[Maven-工具简介: Apache Maven是跨平台的项目管理工具，主要服务于基于Java平台的项目构建、依赖管理和项目信息管理。Maven可以自动化构建过程，从清理、编译、测试到生成报告，再到打包和部署。Maven最大化地消除了构建的重复，抽象了构建生命周期，并且为绝大部分的构建任务提供了已实现的插件，我们不再需要定义过程，甚至不需要再去实现这些过程中的一些任务。 最简单的例子就是测试，我们没必要告诉Maven去测试，更不需要告诉Maven如何运行测试，只需要遵循Maven的约定编写好测试用例当我们运行构建的时候，这些测试便会自动运行。 Maven-环境配置: Maven是一个基于Java的构建工具，所以在安装Maven之前必须配置好Java的相关环境。 检查JAVA环境是否正常: 1java -version 下载并解压Maven: 下载 123 Mac用户可以使用[Homebrew](https://brew.sh/)来安装Mavenbrew search maven # 搜索brew install maven # 安装 设置Maven环境变量: 12export M2_HOME=/Users/Hostname/Software/apache-maven-3.3.9export PATH=$PATH:$M2_HOME/bin 验证Maven是否安装成功: 1234567输入： mvn -v 或者 mvn -versionApache Maven 3.3.9 (bb52d8502b132ec38323dc5; 2015-11-11T00:41:47+08:00)Maven home: /Users/Hostname/Software/apache-maven-3.3.9Java version: 1.8.0_121, vendor: Oracle CorporationJava home: /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jreDefault locale: zh_CN, platform encoding: UTF-8OS name: &quot;mac os x&quot;, version: &quot;10.12.3&quot;, arch: &quot;x86_64&quot;, family: &quot;mac&quot; Maven-POM:什么是POM?POM 代表工程对象模型。它是使用 Maven 工作时的基本组建，是一个 xml 文件。它被放在工程根目录下，文件命名为 pom.xml。POM 包含了关于工程和各种配置细节的信息，Maven 使用这些信息构建工程。 * project dependencies * plugins * goals * build profiles * project version * developers * mailing list 在仓库中工程组（groupId），及其名称（artifactId）和版本这些属性是工程的唯一标识。 POM文件示例：&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;ws.object&lt;/groupId&gt; &lt;artifactId&gt;mvnPro&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;mvnPro&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 需要说明的是每个工程应该只有一个 POM 文件。 所有的 POM 文件需要 project 元素和三个必须的字段：groupId, artifactId,version。 在仓库中的工程标识为 groupId:artifactId:version POM.xml 的根元素是 project，它有三个主要的子节点： POM文件节点详解： 节点 描述 groupId 这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，一个银行组织 ws.object.mvn 拥有所有的和银行相关的项目。 artifactId 这是工程的标识。它通常是工程的名称。例如，消费者银行。groupId和artifactId 一起定义了 artifact 在仓库中的位置。 version 这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。例如:ws.object.mvn:consumer-banking:1.0 ws.object.mvn:consumer-banking:1.1. Maven-构建生命周期什么是构建?除了编写源代码，我们每天有相当一部分时间花在了编译、运行单元测试、生成文档、打包和部署等繁琐而不起眼的工作上，这就是构建（build）。 Maven的三套生命周期Maven有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，一般容易将Maven的生命周期看成一个整体，其实不然。这三套生命周期分别是： Clean Lifecycle 在进行真正的构建之前进行一些清理工作。 Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。 Site Lifecycle 生成项目报告，站点，发布站点。 我再次强调一下它们是相互独立的，你可以仅仅调用clean来清理工作目录，仅仅调用site来生成站点。当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。 每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行mvn clean ，这个的clean是Clean生命周期的一个阶段。Clean生命周期，也有clean阶段。Clean生命周期一共包含了三个阶段： pre-clean 执行一些需要在clean之前完成的工作 clean 移除所有上一次构建生成的文件 post-clean 执行一些需要在clean之后立刻完成的工作 Site生命周期的各个阶段： pre-site 执行一些需要在生成站点文档之前完成的工作 site 生成项目的站点文档 post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 site-deploy 将生成的站点文档部署到特定的服务器上 Default生命周期：Maven中最重要的Default生命周期,绝大部分工作都发生在这个生命周期中，下面列出一些常用的阶段： 生命周期阶段 描述 validate 检查工程配置是否正确，完成构建过程的所有必要信息是否能够获取到。 initialize 初始化构建状态，例如设置属性。 generate-sources 生成编译阶段需要包含的任何源码文件。 process-sources 处理源代码，例如，过滤任何值（filter any value）。 generate-resources 生成工程包中需要包含的资源文件。 process-resources 拷贝和处理资源文件到目的目录中，为打包阶段做准备。 compile 编译工程源码。 process-classes 处理编译生成的文件，例如 Java Class 字节码的加强和优化。 generate-test-sources 生成编译阶段需要包含的任何测试源代码。 process-test-sources 处理测试源代码，例如，过滤任何值（filter any values)。 test-compile 编译测试源代码到测试目的目录。 process-test-classes 处理测试代码文件编译后生成的文件。 test 使用适当的单元测试框架（例如JUnit）运行测试。 prepare-package 在真正打包之前，为准备打包执行任何必要的操作。 package 获取编译后的代码，并按照可发布的格式进行打包，例如 JAR、WAR或者EAR文件。 pre-integration-test 在集成测试执行之前，执行所需的操作。例如，设置所需的环境变量。 integration-test 处理和部署必须的工程包到集成测试能够运行的环境中。 post-integration-test 在集成测试被执行后执行必要的操作。例如，清理环境。 verify 运行检查操作来验证工程包是有效的，并满足质量要求。 install 安装工程包到本地仓库中，该仓库可以作为本地其他工程的依赖。 deploy 拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程。 Maven-仓库什么是 Maven 仓库？在 Maven 的术语中，仓库是一个位置（place），例如目录，可以存储所有的工程 jar 文件、library jar 文件、插件或任何其他的工程指定的文件。 Maven 仓库有三种类型： 本地（local） 中央（central） 远程（remote） 本地仓库:Maven 本地仓库是机器上的一个文件夹。它在你第一次运行任何 maven 命令的时候创建。 Maven 本地仓库保存你的工程的所有依赖（library jar、plugin jar 等）。当你运行一次 Maven 构建，Maven会自动下载所有依赖的 jar 文件到本地仓库中。它避免了每次构建时都引用存放在远程机器上的依赖文件。Maven 本地仓库默认被创建在 %USER_HOME% 目录下。要修改默认位置，在 %M2_HOME%\conf 目录中的 Maven 的 settings.xml 文件中定义另一个路径。 ​1234567&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; &lt;localRepository&gt;/Users/HostName/Public/MavenRepository&lt;/localRepository&gt;&lt;/settings&gt;​ 中央仓库:Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。中央仓库的关键概念： * 这个仓库由 Maven 社区管理。 * 不需要配置。 * 需要通过网络才能访问。 要浏览中央仓库的内容，maven 社区提供了一个 URL：http://search.maven.org/#browse。使用这个仓库，开发人员可以搜索所有可以获取的代码库。 远程仓库:如果 Maven 在中央仓库中也找不到依赖的库文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的jar 文件。举例说明，使用下面的 POM.xml，Maven 将从远程仓库中下载该 pom.xml 中声明的所依赖的（在中央仓库中获取不到的）文件。 ​123456789101112131415161718192021222324252627&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;ws.object&lt;/groupId&gt; &lt;artifactId&gt;mvnPro&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.companyname.common-lib&lt;/groupId&gt; &lt;artifactId&gt;common-lib&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependencies&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;companyname.lib1&lt;/id&gt; &lt;url&gt;http://download.companyname.org/maven2/lib1&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;companyname.lib2&lt;/id&gt; &lt;url&gt;http://download.companyname.org/maven2/lib2&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt;​ Maven 依赖搜索顺序: 当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库： 1. 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。 2. 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中已被将来引用。 3. 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。 4. 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库已被将来引用，否则 Maven将停止处理并抛出错误（无法找到依赖的文件）。 Maven-插件什么是 Maven 插件？Maven实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。Maven插件通常被用来： 创建 jar 文件 创建 war 文件 编译代码文件 代码单元测试 创建工程文档 创建工程报告 插件通常提供了一个目标的集合，并且可以使用下面的语法执行： 1mvn [plugin-name]:[goal-name] 例如，一个 Java 工程可以使用 maven-compiler-plugin 的 compile-goal 编译，使用以下命令： 1mvn compiler:compile 插件类型Maven 提供了下面两种类型的插件： 类型 描述 Build plugins 在构建时执行，并在 pom.xml 的元素中配置。 Reporting plugins 在网站生成过程中执行，并在 pom.xml 的元素中配置。 ###常用插件列表： 插件 描述 clean 构建之后清理目标文件。删除目标目录。 compiler 编译 Java 源文件。 surefile 运行 JUnit 单元测试。创建测试报告。 jar 从当前工程中构建 JAR 文件。 war 从当前工程中构建 WAR 文件。 javadoc 为工程生成 Javadoc。 antrun 从构建过程的任意一个阶段中运行一个 ant 任务的集合。 Maven-创建工程Maven 使用原型（archetype）插件创建工程。要创建一个简单的Java应用，我们将使用 maven-archetype-quickstart 插件。在下面的例子中，我们将创建一个基于 maven 的 java 应用工程。 12345mvn archetype:generate \-DgroupId=ws.object \-DartifactId=Example \-DarchetypeArtifactId=maven-archetype-quickstart \-DinteractiveMode=false 12345678910111213[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building Maven Stub Project (No POM) 1[INFO] ------------------------------------------------------------------------……------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 4.277 s[INFO] Finished at: 2017-07-13T14:10:19+08:00[INFO] Final Memory: 14M/214M[INFO] ------------------------------------------------------------------------ 出现 BUILD SUCCESS 即项目创建成功！ 模板 含义 mvn archetype:generate 固定格式 -DgroupId 组织标识（包名) -DartifactId 项目名称 -DinteractiveMode 是否使用交互模式 -DarchetypeArtifactId 指定ArchetypeId，maven-archetype-quickstart,创建一个Java Project；maven-archetype-webapp，创建一个Web Project Maven-工程模板(archetype)Maven 使用原型（Archetype）概念为用户提供了大量不同类型的工程模版（614 个）。Maven 使用下面的命令帮助用户快速创建 java 项目。 1mvn archetype:generate 什么是原型？ 原型是一个 Maven 插件，它的任务是根据模板创建一个项目结构。我们将使用 quickstart 原型插件创建一个简单的 java 应用程序。 Maven-web应用 创建 Web 应用建立一个简单的 Java web 应用，我们可以使用 maven-archetype-webapp 插件。首先我们打开terminal，输入以下的 mvn 命令。mvn archetype:generate \-DgroupId=ws.object.example \-DartifactId=example \-DarchetypeArtifactId=maven-archetype-webapp \-DinteractiveMode=falseMaven 将开始处理并且将创建完整的基于 Web 的 java 应用工程结构。 Maven-参考资料 Maven官网:http://maven.apache.org/ 官网介绍:http://maven.apache.org/what-is-maven.html Wikipedia:https://zh.wikipedia.org/wiki/Apache_Maven Maven教程:http://www.yiibai.com/maven/ Maven详解:http://www.cnblogs.com/hongwz/p/5456578.html 国外Maven教程:http://www.tutorialspoint.com/maven/index.htm 常用骨架简介:http://www.cnblogs.com/iusmile/archive/2012/11/14/2770118.html]()]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lombok - 使用注解让你的JavaBean变得更加简洁]]></title>
    <url>%2F2017%2F06%2F23%2Flombok-note%2F</url>
    <content type="text"><![CDATA[Lombok - 工具简介：Lombok是一个编译时注释预处理器，有助于在编译时注入一些代码。Lombok提供了一组在开发时处理的注释，以将代码注入到Java应用程序中，注入的代码在开发环境中立即可用。在详细介绍之前，可以去其官网看一下作者提供的视频，视频中阐述了Lombok 的简单用法。https://projectlombok.org/ Lombok - 安装过程：基于 Maven：示例代码： 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加好 Maven 依赖之后，就可以在代码中使用 Lombok 的注解来简化代码了。 基于IntelliJ IDEA：安装 Lombok IntelliJ plugin:Jetbrains IntelliJ IDEA Editor完全兼容 Lombok，要在 IDEA 中使用 Lombok，那就需要在IntelliJ IDEA 中安装 Lombok IntelliJ plugin 插件，以下为安装步骤： Go to File &gt; Settings &gt; Plugins Click on Browse repositories... Search for Lombok Plugin Click on Install plugin Restart IntelliJ IDEA 具体安装过程可参考官网或者插件 Github 主页。 在IntelliJ IDEA使用Lombok: Go to Refactor &gt; Lombok 在打开的 JavaBean 文件中按照需求添加相应的注解即可。 Lombok - 常用注解：你如果是使用IDEA的话，在当前文件上按command+F12，或者长按command在左侧找到Structure，就能够看到 lombok 为当前类生成的方法。 @Data ：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法 示例代码： 12345678import lombok.Data;@Datapublic class Person &#123; private String firstName; private String lastName; private String job;&#125; @Setter/@Getter：注解在属性或类上；为属性提供 Setter/Getter 方法 示例代码： 1234567891011import lombok.Getter;import lombok.Setter;// 只为 firstName 生成Getter、Setter 方法public class Person &#123; @Getter @Setter private String firstName; private String lastName; private String job;&#125; 123456789101112import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class Person &#123;// 为所有字段生成Getter、Setter 方法 private String firstName; private String lastName; private String job;&#125; @Log4j ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象 @Value：此注解集@equals()、@hashCode()、@toString()、@Getter()于一身。 示例代码： 123456789101112131415import lombok.Value;import lombok.experimental.NonFinal;@Valuepublic class Person &#123; /** 类本身以及类中所有的字段都是private final类型的，不会生成Setter方法。 * 可以通过显式指定某个注解覆盖掉默认的属性。 * 通过@NonFinal注解修饰的字段，不是final类型的。 */ String firstName; String lastName; @NonFinal String job;&#125; ​ @NoArgsConstructor/@AllArgsConstructor: 自动生成无参数构造函数/全参构造函数。 示例代码： 123456789101112import lombok.AllArgsConstructor;import lombok.NoArgsConstructor;@NoArgsConstructor@AllArgsConstructorpublic class Person &#123; private String firstName; private String lastName; private String job;&#125; ​ @NonNull :修饰方法、构造函数的参数或者类字段，Lombok自动生成一个非空检测语句。 示例代码： 12345678import lombok.NonNull;public class Person&#123; public String Example(@NonNull String sum)&#123; return null; &#125;&#125; ​ @Synchronized 将方法变成同步方法 @SneakyThrows：将受检异常转换为非受检异常，避免抛出或尝试语句。 ​ lombok 项目官网上还有一些其他注解的用法，此处就不列举了，附链接：https://projectlombok.org/features/all 参考资料： Lombok Official Website Lombok Github Lombok IntelliJ plugin]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Lombok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『Enterprise Java - Servlet』 在 Java8中使Servlet 3.1]]></title>
    <url>%2F2017%2F06%2F05%2Fentjava-servlet%2F</url>
    <content type="text"><![CDATA[前言：本文讲解了在 JAVA8的环境中使用 Servlet3.1的标准容器中使用 Http 上下文的方式来深入了解 Servlet，通过一个简单的Maven Web项目，可以通过您喜爱的浏览器或Postman来访问。 环境准备： Java Version : 1.8.0_121 Maven Version：Apache Maven 3.3.9 IDE：IntelliJ IDEA (2017.2.3) System：macOS Sierra Servlet - 简介:Servlet是基于Java技术的web组件，容器托管的，用于生成动态内容。它是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。像其他基于Java的组件技术一样，Servlet也是基于平台无关的Java类格式，被编译为平台无关的字节码，可以被基于Java技术的web server动态加载并运行。容器，有时候也叫做servlet引擎，是web server为支持servlet功能扩展的部分。客户端通过Servlet容器实现的请求/应答模型与Servlet交互。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势： 性能明显更好。 Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。 Servlet 是独立于平台的，因为它们是用 Java 编写的。 服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。 Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。 Servlet - 容器:Servlet容器是web server或application server的一部分，提供基于请求/响应发送模型的网络服务，解码基于MIME的请求，并且格式化基于MIME的响应。Servlet 容器也包含了管理Servlet生命周期。 Servlet容器可以嵌入到宿主的web server中，或者通过Web Server的本地扩展API单独作为附加组件安装。Servelt容器也可能内嵌或安装到包含web功能的application server中。 所有Servlet容器必须支持基于HTTP协议的请求/响应模型，比如像基于HTTPS（HTTP over SSL）协议的请求/应答模型可以选择性的支持。容器必须实现的HTTP协议版本包含HTTP/1.0 和 HTTP/1.1。因为容器或许支持RFC2616 (HTTP/1.1)描述的缓存机制，缓存机制可能在将客户端请求交给Servlet处理之前修改它们，也可能在将Servlet生成的响应发送给客户端之前修改它们，或者可能根据RFC2616规范直接对请求作出响应而不交给Servlet进行处理。 Servlet容器应该使Servlet执行在一个安全限制的环境中。在Java平台标准版（J2SE, v.1.3 或更高） 或者 Java平台企业版(Java EE, v.1.3 或更高) 的环境下，这些限制应该被放置在Java平台定义的安全许可架构中。比如，高端的application server为了保证容器的其他组件不受到负面影响可能会限制Thread对象的创建。 Java SE 6是构建Servlet容器最低的Java平台版本。 事件序列:以下是一个典型的事件序列： 1、客户端（如 web浏览器）发送一个HTTP请求到web服务器； 2、Web服务器接收到请求并且交给servlet容器处理，servlet容器可以运行在与宿主web服务器同一个进程中，也可以是同一主机的不同进程，或者位于不同的主机的web服务器中，对请求进行处理。 3、servlet容器根据servlet配置选择相应的servlet，并使用代表请求和响应对象的参数进行调用。 4、servlet通过请求对象得到远程用户，HTTP POST参数和其他有关数据可能作为请求的一部分随请求一起发送过来。Servlet执行我们编写的任意的逻辑，然后动态产生响应内容发送回客户端。发送数据到客户端是通过响应对象完成的。 5、一旦servlet完成请求的处理，servlet容器必须确保响应正确的刷出，并且将控制权还给宿主Web服务器。 Servlet - 规范:许多供应商已经实施了servlet规范（例如：Tomcat，Jetty），尽管规范的确发展，供应商最终还是为我们部署我们的Web应用程序提供了实现。 通过JSR 340的提案，servlet 3.1规范在大版本3.0（JSR 315）上进行了迭代，允许我们的Web应用程序利用非阻塞IO和HTTP协议升级机制等功能。 在Servlet 3.0规范发布后的一大特点是不再需要一个web.xml 作为描述为我们所有的Servlet、过滤器、Listeners、init-PARAMS在 xml 文件中进行配置，大多数元数据、配置现在可以通过注释来完成。 此次使用web.xml 仅仅是为了在尝试访问安全路由时配置容器的登录过程。 web.xml: 1234567891011&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;!-- 将以任何安全路由的基本身份验证来挑战用户 --&gt; &lt;login-config&gt; &lt;auth-method&gt;BASIC&lt;/auth-method&gt; &lt;realm-name&gt;servletbasics&lt;/realm-name&gt; &lt;/login-config&gt;&lt;/web-app&gt; Servlet - 生命周期：Servlet是按照一个严格定义的生命周期被管理，该生命周期规定了Servlet如何被加载、实例化、初始化、处理客户端请求，以及何时结束服务。该声明周期可以通过javax.servlet.Servlet接口中的init、service和destroy这些API来表示，所有Servlet必须直接或间接的实现GenericServlet或HttpServlet抽象类。 以下是典型servlet的生命周期。 init 实例化: 用户访问这个Servlet，由容器实例化，它的init()方法被调用一次。通常，Servlet被实例化一次，并且在使用中产生大量并发，尽管容器可以汇集实现SingleThreadModel的多个servlet来处理重负载。 调用Service服务:Servi为每个请求调用Servlets的service()方法，如果您的servlet实现了HttpServlet接口，那么该请求将被委派给与您给定的请求动词匹配的任何便利方法。 销毁 Servlet:destroy()方法被调用，允许我们钩入生命周期，并终止servlet使用的任何资源。 垃圾收集:垃圾收集器收集servlet。 Servlet - 过滤器:Servlet的过滤器旨在拦截对servlet，jsp或甚至静态HTML文件的请求。他们还将响应拦截回客户端，因此可用于修改请求/响应，有时甚至根据特定条件阻止或重定向它们。 其中包括： 身份验证：拦截请求以防止未经身份验证的用户 压缩：将响应压缩回客户端 更改请求/响应体的交换格式 跟踪请求/响应 Servlet - 监听器:servlet规范允许我们定义WebListener，它可以对Web应用程序中发生的某些事件做出反应。事件可以在会话，请求，应用程序级别，不同类型的WebListener被设计为对不同的事件做出反应。 对于不同的场景，存在以下WebListeners： Scope WebListener 接口 Event Web context ServletContextListenerServletContextAttributeListener ServletContextEventServletContextAttributeEvent Session HttpSessionListenerHttpSessionActivationListenerHttpSessionAttributeListener HttpSessionEventHttpSessionEventHttpSessionBindingEvent Request ServletRequestListenerServletRequestAttributeListener ServletRequestEventServletRequestAttributeEvent Servlet - Context：Servlet - 注解：在web应用中，使用注解的类仅当它们位于WEB-INF/classes目录中，或它们被打包到位于应用的WEB-INF/lib中的jar文件中时它们的注解才将被处理。 Web应用部署描述符的web-app元素包含一个新的“metadata-complete”属性。“metadata-complete”属性定义了web描述符是否是完整的，或是否应该在部署时检查jar包中的类文件和web fragments。如果“metadata-complete”设置为“true”，部署工具必须必须忽略存在于应用的类文件中的所有指定部署信息的servlet注解和web fragments。如果metadata-complete属性没有指定或设置为“false”，部署工具必须检查应用的类文件的注解，并扫描web fragments。 以下注解必须被Servlet 3.0兼容的容器支持。 @WebServlet:该注解用于在Web应用中定义Servlet组件。该注解在一个类上指定并包含声明Servlet的元数据。必须指定注解的urlPatterns或value属性。所有其他属性是可选的默认设置。@WebServlet注解的类必须继承javax.servlet.http.HttpServlet类。 使用示例: 1234@WebServlet(”/foo”)public class CalculatorServlet extends HttpServlet&#123;//...&#125; @WebFilter:该注解用于在Web应用中定义Filter。该注解在一个类上指定且包含声明过滤器的元数据。如果没有指定Filter名字则默认是全限定类名。注解的urlPatterns属性, servletNames 属性 或 value 属性必须被指定。所有其他属性是可选的默认设置。@WebFilter注解的类必须实现javax.servlet.Filter。 使用示例： 123456@WebFilter(“/foo”)public class MyFilter implements Filter &#123;public void doFilter(HttpServletRequest req, HttpServletResponse res) &#123;...&#125;&#125; @WebInitPara:该注解用于指定必须传递到Servlet或Filter的任何初始化参数。它是WebServlet和WebFilter注解的一个属性。 @WebListener:WebListener注解用于注解用来获得特定web应用上下文中的各种操作事件的监听器。@WebListener注解的类必须实现以下接口： javax.servlet.ServletContextListener javax.servlet.ServletContextAttributeListener javax.servlet.ServletRequestListener javax.servlet.ServletRequestAttributeListener javax.servlet.http.HttpSessionListener javax.servlet.http.HttpSessionAttributeListener javax.servlet.http.HttpSessionIdListener 使用示例： 12345678@WebListenerpublic class MyListener implements ServletContextListener&#123; public void contextInitialized(ServletContextEvent sce) &#123; ServletContext sc = sce.getServletContext(); sc.addServlet("myServlet", "Sample servlet", "foo.bar.MyServlet", null, -1); sc.addServletMapping("myServlet", new String[] &#123; "/urlpattern/*" &#125;); &#125;&#125; @MultipartConfig:该注解，当指定在Servlet上时，表示请求期望是mime/multipart类型。相应servlet的HttpServletRequest对象必须使用getParts和getPart方法遍历各个mime附件以获取mime附件。javax.servlet.annotation.MultipartConfig的location属性和的元素被解析为一个绝对路径且默认为javax.servlet.context.tempdir。如果指定了相对地址，它将是相对于tempdir位置。绝对路径与相对地址的测试必须使用java.io.File.isAbsolute。 Servlet - 异步操作:异步处理在重负载或在客户端和服务器之间以不同速度读取和写入大量数据的情况下特别有用，意味着两个实体之一可能会等待来自另一个的输入。 在servlet 3.0规范中，引入了servlet内部的异步处理，允许长时间运行的任务在一个单独的线程中完成，以允许请求线程返回到从它处理其他请求的池中。 通过servlet 3.1规范，我们得到了能够以异步方式在客户端和服务器之间读写数据的功能，从而允许以非阻塞方式异步处理客户端和服务器之间的长时间读写操作，特别适用于大型读取和写入时可能阻止的数据流以不同的速度完成。这些功能通过ReadListener和WriteListener接口来实现。 作为servlet 3.1规范的一部分，我们为servlet和过滤器提供异步处理支持。 参考资料：JCP(Java Servlet 3.1规范):https://jcp.org/en/jsr/detail?id=340]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『管理工具-NPM』相关内容整理]]></title>
    <url>%2F2017%2F05%2F09%2Fnpm-note%2F</url>
    <content type="text"><![CDATA[NPM是什么？ npm（全称 Node Package Manager，即node包管理器）是Node.js默认的、以JavaScript编写的软件包管理系统。 NPM的使用场景: 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用 NPM-工作原理： npm依赖解析的主要思想：尽可能地减少间接依赖安装目录的深度，最理想的情况是与直接依赖安装在同一目录下，通过这种方式来减少依赖目录的嵌套，缓解整个依赖目录层次过深的问题。（因为 Windows 中文件路径的长度不能大于 260 个字符。） 参考资料：NPM基本用法和使用技巧 NPM-基础操作：NPM是随同Node.js一起安装的包管理工具，所以我们只需要安装nodejs就可以同时安装成功NPM。 安装Node.js并更新npmWin系统：进入Node.js 官方网站，找到 Downloads 栏目，选择适合自己系统的安装包进行安装。 MacOS系统：在MacOS系统上建议先安装Homebrew，然后使用homebrew来安装NPM。 12brew search nodejs #搜索brew install nodejs #安装 CentOS系统：在CentOS系统上，我们可以使用yum命令来安装Node.js,前提是需要配置好yum源。 1yum -y install nodejs Ubuntu系统：在 Ubuntu系统上，我们可以使用apt-get方式来安装Node.js。 1apt-get install nodejs 安装完成并且配置好相关环境之后，我们可以再Terminal中输入node -v 和npm -v分别来测试nodejs和npm是否安装成功。 npm常用参数： -g, –global：安装全局依赖，如果没有指定依赖包名，则将当前目录中的包安装至全局 -S, –save：安装依赖的同时将该依赖写入 dependencies -D, –save-dev：安装依赖的同时将该依赖写入 devDependencies -O, –save-optional：安装依赖的同时将该依赖写入 optionalDependencies -E, –save-exact：写入 package.json 时带有确切版本号 –no-optional：不安装 optional dependencies，可继承 –only={dev[elopment]|prod[uction]}：无视 NODE_ENV，只安装 devDependencies 或仅安装除了 devDependencies 之外的依赖项 –dry-run：走一遍安装的过程并报告结果，但实际上没有安装任何依赖 在本地安装npm软件包有两种方法来安装NPM包：本地或全局，你选择哪一种安装使用基于你想如何使用包。 如果你想使用类似的Node.js依赖于包从自己的模块 require，然后要在本地安装，这是npm install的默认行为。在另一方面，如果你想使用它作为一个命令行工具，像繁重的CLI的东西，那么你要在全局安装它。 npm install命令的使用可在下文npm-cli部分查看。 init初始化项目：12npm init #在项目根目录下使用它会创建一个package.json文件,需要填写一些内容，详见下文npm init -y # 在package.json文件中全部使用默认选项 使用 package.json管理本地安装的npm软件包的最佳方法是创建一个package.json文件。 一个package.json文件为你提供了很多方便： - 它作为您的项目所依赖的包的文档。 - 它允许您使用语义版本控制规则来指定项目可以使用的包的版本。 - 使您的构建可重复，这意味着它的方式更容易与其他开发人员共享。 package.json语法： “name” 全部小写 一个字，没有空格 破折号和下划线允许 “version” 的形式 x.x.x 遵循semver spec命名规范 demo: 1234&#123; &quot;name&quot;: &quot;my-awesome-package&quot;, &quot;version&quot;: &quot;1.0.0&quot;&#125; 其他字段释义： 字段名称 说明 name 当前项目名称 version 项目版本信息，默认为1.0.0 description 来自readme的信息，否则为空字符串 “” main 默认为index.js scripts 默认情况下会创建一个空test脚本 keywords 关键词信息，默认空 author 作者信息，默认空 license 软件许可证 ISC bugs 来自当前项目的信息（如果存在） homepage 来自当前项目的信息（如果存在） dependencies 您的应用程序在生产中需要这些软件包 devDependencies 这些软件包仅用于开发和测试 安装npm软件包安装本地(local)软件包:1npm install &lt;packageName&gt; # 需要在当前项目项目根目录下，与package.json 文件在同一目录下 安装全局(global)软件包:1npm install -g &lt;packageName&gt; 在全局安装时出现Permission denied错误时，请在npm指令前加上 sudo(类UNIX系统下) 查看npm软件包查看本地(local)软件包:1npm list # 与package.json 在同一目录下运行 查看全局(global)软件包:1npm list -g # Terminal中运行 更新npm软件包1npm list -g # 查看系统中全局安装过的软件包 应该经常更新您依赖的软件包，以便您可以获得对上游代码进行的任何更改。 更新本地(local)软件包:1npm update &lt;packageName&gt; #对单个包升级 更新全局(global)软件包：npm -g是管理本地全局包的命令。 1234567891011121314➜ ~ npm -g outdated # 使用此命令可以查看那些包有更新：Package Current Wanted Latest Locationcordova 6.5.0 7.0.1 7.0.1create-react-app 1.3.0 1.3.3 1.3.3elf-cli 1.4.0 1.7.0 1.7.0express 4.15.2 4.15.3 4.15.3ionic 2.2.2 3.5.0 3.5.0node-gyp 3.6.0 3.6.2 3.6.2node-inspector 1.0.0 1.1.1 1.1.1npm 4.4.1 5.3.0 5.3.0wechat-api 1.32.0 1.33.0 1.33.0npm update -g &lt;packageName&gt; # 更新全局的软件包 参考:npm升级所有可更新包 卸载npm软件包卸载本地(local)软件包1npm uninstall &lt;packageName&gt; 删除本地模块时你应该思考的问题：是否将在package.json上的相应依赖信息也消除？ npm uninstall 模块: 删除模块，但不删除模块留在package.json中的对应信息 npm uninstall --save 模块: 删除模块，同时删除模块留在package.json中dependencies下的对应信息 npm uninstall --save-dev 模块: 删除模块，同时删除模块留在package.json中devDependencies下的对应信息 卸载全局(global)软件包1npm uninstall -g &lt;packageName&gt; 发布npm包你可以推送任何包含 package.json 文件的文件夹，比如一个 node module ####注册账号 要发布软件包，你必要有一个 npm 账号，如果没有可以使用 npm adduser 创建一个。然后使用 npm login 登录。 参考: 手把手教你用npm发布一个包 如何发布Node模块到NPM社区 Publishing npm packages npm的语义版本控制语义版本控制是许多项目用于传达此版本中的哪些更改的标准。沟通发布中的哪些更改很重要，因为有时这些更改将会破坏依赖于该包的代码。 semver:语义化版本标准Link 作为发布者：如果一个项目将与其他人共享，那么应该从1.0.0项目开始，尽管有些项目在npm不符合这个规则。之后，变更应处理如下： 错误修正和其他微小变化：修补程序释放，增加最后一个数字，例如1.0.1 不破坏现有功能的新功能：轻微释放，增加中间数字，例如1.1.0 破坏向后兼容性的更改：主要版本，增加第一个数字，例如2.0.0 作为使用者：作为开发者，可以指定应用程序在package.json文件中可以接受哪些类型的更新。 如果您从1.0.4开始，那么您将如何指定范围： 补丁版本：1.0或1.0.x或~1.0.4 次要版本：1或1.x或^1.0.4 主要版本：*或x NPM-私有模块：你可以使用 NPM 命令行工具来管理你在 NPM 仓库的私有模块代码，这使得在项目中使用公共模块变的更加方便。 准备工作你需要一个 2.7.0 以上版本的 npm ，并且需要有一个可以登陆 npm 仓库的账号。 12npm install -g npmnpm login 软件包配置所有的私有模块都是 scoped package 的。 scope 是 npm 的新特性。如果一个模块的名字以 “@” 开始，那么他就是一个scoped package。scope 就是”@”与”/“之间的部分。 1@scope/project-name 当你注册私有模块到一个用户下时，你的 scope 就是当前用户的用户名。 1@username/project-name 如果要使用npm init 初始化一个软件包，你可以通过自定义 --scope 选项设置你的 scope 1npm init --scope=&lt;your_scope&gt; 如果你在大多数时候使用的 scope 都是相同的，可以设置一个默认的 scope ，这样在我们初始化的时候会自动使用该 scope。 1npm config set scope &lt;your_scope&gt; 发布模块1npm publish 默认情况下，scoped package 会发布为私有模块，发布为私有模块是需要付费的，费用是每个月 $7。 一旦完成发布，你将会在npm库站点上看到你的 scoped package，有 private 标志，说明是非公共的模块，他人无法使用。 私有仓库授权访问如果你要授权给其他人使用你的模块，你可以在 package 的权限设置页面设置哪些用户可以拥有 只读或读写、权限。也可以通过命令行进行相关设置 1npm owner add &lt;user&gt; &lt;package name&gt; 安装私有模块如果要安装私有模块，你必须要有权限访问到要安装的私有模块。安装的时候可以使用 scope package name 1npm install @scope/project-name 当你在项目中使用这些代码模块时可以如下使用 1var project = require(&apos;@scope/project-name&apos;) 参考资料： NPM私有模块 创建一个私有的npm库 NPM-CLI命令： 命令 释义 npm install 安装模块 npm uninstall 卸载模块 npm update 更新模块 npm outdated 检查模块是否已经过时 npm ls 查看安装的模块 npm init 在项目中引导创建一个package.json文件 npm help 查看某条命令的详细帮助 npm root 查看包的安装路径 npm config 管理npm的配置路径 npm cache 管理模块的缓存 npm start 启动模块 npm stop 停止模块 npm restart 重新启动模块 npm test 测试模块 npm version 查看模块版本 npm view 查看模块的注册信息 npm adduser 用户登录 npm publish 发布模块 npm access 在发布的包上设置访问级别 npm package.json 的语法 参考资料： NPM官网 CLI Commands NPM-常用配置：常用配置项: cache：npm 本地缓存目录，默认 ~/.npm cache-max：保持缓存项目且不向 registry 检查的最长时间，单位秒，默认 Infinity，缓存中的数据不会自动删除除非执行 npm cache clean 命令 cache-min：保持缓存项目且不向 registry 检查的最短时间，单位秒，默认 10，可以置为 999999 等以尽量延长缓存生效时间 depth：npm ls 等命令中的默认深度，默认 Infinity editor：npm 默认使用的编辑器 engine-strict：如果置为 true，npm 将会拒绝安装不符合当前 Node.js 版本的模块 force：强力执行一些命令 生命周期脚本执行失败不再阻塞安装过程 发布会覆盖已经发布的版本 访问 registry 时会跳过缓存 global：全局模式 globalconfig：全局配置文件的路径 global-style：以安装全局依赖的方式安装局部依赖，只有直接依赖会被放在顶层依赖目录中 https-proxy：代理 if-present：如果置为 true，npm run-script 就不会在脚本找不到时报错 ignore-scripts：如果置为 true，npm 就不会运行 package.json 定义的脚本 init-module：指定 npm init 命令运行的模块 init-author-name：npm init 使用的默认作者名 init-author-email：npm init 使用的默认作者邮箱 init-author-url：npm init 使用的默认作者 URL init-license：npm init 使用的默认许可证 init-version：npm init 使用的默认版本号 json：npm ls 等命令输出 JSON 格式的数据 link：如果置为 true，如果全局依赖中有合适的包，安装局部依赖时将会直接链接到这个全局依赖的包；如果全局依赖中没有该包的任何版本，则全局安装这个包，并链接到局部依赖中；其他情况则在局部依赖中安装该包 long：npm ls 和 npm search 显示额外信息 message：npm version 写在 git 提交中的信息，%s 将被替换为版本号 npat：安装时运行测试 onload-script：指定一个在 npm 加载时 require() 的包，编程使用 npm 时可能会有用 only：与命令中的 --only 效果类似 optional：如果置为 false，则不安装 optionalDependencies 中的依赖 prefix：指定安装全局依赖的路径 production：如果置为 true，则开启生产模式，npm install 将不安装开发依赖，声明周期脚本运行时自动设置 NODE_ENV=&quot;production&quot; registry：指定 npm registry 的 URL rollback：移除安装失败的模块 save：与命令中的 --save 效果类似 scope：与命令中的 --scope 效果类似 shrinkwrap：如果置为 false，安装时忽略 npm-shrinkwrap.json progress：如果置为 false，不显示进度条 loglevel：设置输出日志的 level，置为 silly 可以显示全部日志 npmrc:配置文件有： 项目配置文件（/path/to/my/project/.npmrc） 用户配置文件（~/.npmrc） 全局配置文件（/path/to/node/etc/npmrc） 内置配置文件（/path/to/npm/npmrc） scripts:npm 支持的生命周期脚本有： prepublish: 发布模块之前执行，也在不带任何参数的局部 npm install 之前执行 publish、postpublish: 发布模块之后执行 preinstall: 安装该模块之前执行 install、postinstall: 安装该模块之后执行 preuninstall、uninstall: 移除该模块之前执行 postuninstall: 移除该模块之后执行 preversion、version: 修改模块版本号之前执行 postversion: 修改模块版本号之后执行 pretest、test、posttest: 在 test 命令的前后执行 prestop、stop、poststop: 在 stop 命令的前后执行 prestart、start、poststart: 在 start 命令的前后执行. prerestart、restart、postrestart: 在 restart 命令的前后执行，如果 restart 脚本没有提供，restart 命令将会执行 stop 脚本再执行 start 脚本 对于自定义名称的脚本，可以通过 npm run-script &lt;pkg&gt; &lt;stage&gt; 来执行，匹配名称的 pre 和 post 命令同样也会执行。 NPM-参考资料： 维基百科 NPM官网 淘宝镜像 NPM手册 NPM命令详解 NPM升级更新包 NPM基本用法和使用技巧 NPM脚本命令学习笔记]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>NPM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[『构建工具-Gulp』相关内容整理]]></title>
    <url>%2F2017%2F04%2F26%2Fgulp-note%2F</url>
    <content type="text"><![CDATA[Gulp- 简介 Automate and enhance your workflow | 用自动化构建工具增强你的工作流程 Gulp 是什么？gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用它，不仅可以很愉快的编写代码，而且大大提高我们的工作效率。 gulp是基于Nodejs的自动任务运行器，它能自动化地完成 javascript、coffee、sass、less、html/image、css 等文件的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。通过本文，我们将学习如何使用Gulp来改变开发流程，从而使开发更加快速高效。 gulp 和 grunt 非常类似，但相比于 grunt 的频繁 IO 操作，gulp 的流操作，能更快地更便捷地完成构建工作。 Gulp的核心概念？流，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向。流不但可以处理文件，还可以处理动态内存、网络数据等多种数据形式。 而gulp正是通过流和代码优于配置的策略来尽量简化任务编写的工作。这看起来有点“像jQuery”的方法，把动作串起来创建构建任务。早在Unix的初期，流就已经存在了。流在Node.js生态系统中也扮演了重要的角色，类似于*nix将几乎所有设备抽象为文件一样，Node将几乎所有IO操作都抽象成了stream的操作。因此用gulp编写任务也可看作是用Node.js编写任务。当使用流时，gulp去除了中间文件，只将最后的输出写入磁盘，整个过程因此变得更快。 Gulp的特点? 易于使用: 通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理。 构建快速:利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。 易于学习:通过最少的 API，掌握 gulp 毫不费力，构建工作尽在掌握：如同一系列流管道。 插件高质:gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。 Gulp- 环境搭建gulp 是基于 node 实现的，那么我们就需要先安装 node。 Node是一个基于Google V8 JavaScript引擎建立的一个平台，可以利用它实现Web服务，做类似PHP的事。 12345npm install -g gulp # 全局安装gulp gulp -v # 查看gulp是否安装成功➜ ~ gulp -v [20:17:32] CLI version 3.9.1 Gulp- 构建项目使用Gulp来构建项目:1234567891011121314151617mkdir Gulp &amp;&amp; cd Gulp &amp;&amp; npm init -y &amp;&amp; npm install gulp --save-dev#使用npm初始化项目并且安装Gulp模块,能够看到如下的package.json文件中已经包含了Gulp的相关信息。&#123; &quot;name&quot;: &quot;Gulp&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;gulp&quot;: &quot;^3.9.1&quot; &#125;&#125; gulpfile.js文件的使用： gulp也需要一个文件作为它的主文件，在gulp中这个文件叫做gulpfile.js。 创建gulpfile.js文件，与package.json文件一样放在项目根目录中，之后需要做的就是在gulpfile.js文件中定义任务了。 在gulpfile.js文件中写入以下内容： 1234var gulp = require(&apos;gulp&apos;);gulp.task(&apos;default&apos;, function() &#123; console.log(&quot;Gulp OK!&quot;);&#125;); 完成之后在Terminal中运行gulp命令，然后会看到刚才在task任务中要输出的内容.12345➜ gulp[00:35:29] Using gulpfile ~/WebStrom-Work/Gulp/gulpfile.js[00:35:29] Starting &apos;default&apos;...Gulp OK![00:35:29] Finished &apos;default&apos; after 141 μs Gulp- APIgulp.src()语法：1gulp.src(globs[, options]) 输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中。 名称 类型 含义 globs String 或 Array 所要读取的 glob 或者包含 globs 的数组。 options Object 通过 glob-stream 所传递给 node-glob 的参数。 gulp.dest()语法：1gulp.dest(path[, options]) 能被 pipe 进来，并且将会写文件。并且重新输出（emits）所有数据，因此你可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。 path 类型： String or Function ,文件将被写入的路径（输出目录）。也可以传入一个函数，在函数中返回相应路径，这个函数也可以由 vinyl 文件实例 来提供。 options类型： Object , 为一个可选的参数对象，通常我们不需要用到 gulp.task()语法：1gulp.task(name[, deps], fn) name 类型： String，任务的名字，如果你需要在命令行中运行你的某些任务，那么，请不要在名字中使用空格。 deps 类型： Array，一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。 demo 123gulp.task(&apos;mytask&apos;, [&apos;array&apos;, &apos;of&apos;, &apos;task&apos;, &apos;names&apos;], function() &#123; // 做一些事&#125;); 注意： 你的任务是否在这些前置依赖的任务完成之前运行了？请一定要确保你所依赖的任务列表中的任务都使用了正确的异步执行方式：使用一个 callback，或者返回一个 promise 或 stream。 fn该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：gulp.src().pipe(someplugin())。 gulp.watch()语法：1gulp.watch(glob[, opts], tasks) gulp.watch()用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务。 glob类型： String or Array ,一个 glob 字符串，或者一个包含多个 glob 字符串的数组，用来指定具体监控哪些文件的变动。 opts 类型： Object 传给 gaze 的参数。 cb(event) 类型： Function ,每次变动需要执行的 callback。 参考：Gulp-API Gulp- 常用插件压缩JS -&gt; gulp-uglify:安装 gulp-uglify:1npm install gulp-uglify --save-dev 示例代码：12345678var gulp = require(&apos;gulp&apos;);var uglify = require(&apos;gulp-uglify&apos;);gulp.task(&apos;javascript&apos;,function () &#123; // javascript: 任务名称 gulp.src(&apos;./src/js/*.js&apos;) // src: 定位到需要压缩的js文件目录下 .pipe(uglify()) // 执行压缩文件 .pipe(gulp.dest(&apos;./dist/js&apos;)); // 输出到指定目录&#125;); API参考：gulp-uglify 压缩CSS -&gt; gulp-minify-css:安装 gulp-minify-css：1npm install gulp-minify-css --save-dev 示例代码：12345678var gulp = require(&apos;gulp&apos;);var minify = require(&apos;gulp-minify-css&apos;)gulp.task(&apos;css&apos;,function () &#123; gulp.src(&apos;./src/css/*.css&apos;) .pipe(minify()) .pipe(gulp.dest(&apos;./dist/css&apos;));&#125;); API参考：gulp-minify-css 压缩图片 -&gt; gulp-imagemin：安装 gulp-imagemin：1npm install gulp-imagemin --save-dev 示例代码：12345678var gulp = require(&apos;gulp&apos;);var image = require(&apos;gulp-imagemin&apos;);gulp.task(&apos;image&apos;,function () &#123; gulp.src(&apos;./src/images/*.*&apos;) .pipe(imagemin()) .pipe(gulp.dest(&apos;./dist/images&apos;));&#125;); API参考：gulp-imagemin 编译Less-&gt; gulp-less:安装 gulp-less：1npm install gulp-less --save-dev 示例代码：12345678var gulp = require(&apos;gulp&apos;);var less = require(&apos;gulp-less&apos;);gulp.task(&apos;less&apos;,function () &#123; gulp.src(&apos;./src/less/*.*&apos;) .pipe(less()) .pipe(gulp.dest(&apos;./dist/less&apos;));&#125;); API参考：gulp-less 自动刷新-&gt; gulp-livereload：安装gulp-livereload：1npm install gulp-livereload --save-dev 示例代码：1在每个gulp.task()方法中的gulp.src()方法后追加 .pipe(livereload()); 即可。 需要配合谷歌浏览器插件 LiveReload插件来使用，实现自动刷新。 API参考：gulp-livereload Google Chrome Plugin：LiveReload 完整gulpfile.js文件：123456789101112131415161718192021222324252627282930313233343536var gulp = require(&apos;gulp&apos;); // Gulpvar uglify = require(&apos;gulp-uglify&apos;); // JavaScriptvar minify = require(&apos;gulp-minify-css&apos;); // CSSvar imagemin = require(&apos;gulp-imagemin&apos;); // Imagesvar less = require(&apos;gulp-less&apos;); // Lessvar livereload = require(&apos;gulp-livereload&apos;) // LiveReload// 执行所有任务gulp.task(&apos;default&apos;, [&apos;javascript&apos;,&apos;css&apos;,&apos;less&apos;,&apos;image&apos;]);gulp.task(&apos;javascript&apos;,function () &#123; // jsscript: 任务名称 gulp.src(&apos;./src/js/*.js&apos;) // src: 定位到需要压缩的js文件目录下 .pipe(uglify()) // 执行压缩文件 .pipe(gulp.dest(&apos;./dist/js&apos;)); // 输出到指定目录&#125;);gulp.task(&apos;css&apos;,function () &#123; gulp.src(&apos;./src/css/*.css&apos;) .pipe(minify()) .pipe(gulp.dest(&apos;./dist/css&apos;));&#125;);gulp.task(&apos;less&apos;,function () &#123; gulp.src(&apos;./src/less/*.*&apos;) .pipe(less()) .pipe(gulp.dest(&apos;./dist/css&apos;));&#125;);gulp.task(&apos;image&apos;,function () &#123; gulp.src(&apos;./src/images/*.*&apos;) .pipe(imagemin()) .pipe(gulp.dest(&apos;./dist/images&apos;));&#125;); Gulp- 参考资料 Gulp官网 Gulp中文网 一点CSS-Gulp npmjs Gulp-插件 Gulp常用插件介绍 Gulp使用介绍和技巧 Thenewboston-视频教程 常见web项目目录：在当前项目的根目录下执行tree命令，即可看到项目的整个目录结构，如果没有tree命令，在Mac系统下可以使用brew进行安装： 123456789101112131415161718192021222324➜ Glup tree ../Glup../Glup├── build # 项目构建脚本├── src # 源码目录│ ├── css # CSS文件│ ├── fonts # 字体文件│ ├── images # 图片文件│ ├── js # js脚本文件│ ├── less # less文件│ └── sass # sass文件├── dist # 编译出来的发布版本目录│ ├── css │ ├── fonts│ ├── images│ └── js ├── docs # 文档├── test # 测试脚本├── gulpfile.js # Gulp工具构建项目的主文件├── node_modules # npm包存放目录├── package-lock.json #npm5.0以上项目依赖文件├── package.json # npm包管理配置文件├── LICENSE # 授权协议└── README.md # 项目说明文件]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
</search>
